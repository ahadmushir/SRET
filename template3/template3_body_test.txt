<annotation_start_b>  if key is not contained in self,
  append key to self.keyOrder dictionary.
<annotation_end_b>#<body_start>          if key not in self :
              self . keyOrder . append ( key )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
<annotation_end_b>#<body_start> try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
<body_end><annotation_start_b>  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
<annotation_end_b>#<body_start>          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
<annotation_end_b>#<body_start>          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
<body_end><annotation_start_b>  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
<annotation_end_b>#<body_start>          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
<body_end><annotation_start_b>  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
<annotation_end_b>#<body_start> try :
              val = self [ key ]
  except KeyError :
<body_end><annotation_start_b>  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
<annotation_end_b>#<body_start>          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
<body_end><annotation_start_b>  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
<annotation_end_b>#<body_start>          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
<body_end><annotation_start_b>  try,
<annotation_end_b>#<body_start> try :
<body_end><annotation_start_b>  try,
  remove item from self dictionary.
  if KeyError exception is caught,
  do nothing.
  define the method __iter__ with an argument self.
  convert keys of dictionary self.dict into a iterable, return it.
  define the method __contains__ with 2 arguments: self and item.
  if item is contained in self.dict, return boolean True, otherwise return boolean False.
  define the method __nonzero__ with an argument self.
  convert self.dict into boolean, return the result.
  derive the class MultiValueDictKeyError from the KeyError base class.
  do nothing.
  derive the class MultiValueDict from the dict base class.
  define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
  return an empty list.
  define the method __setitem__ with 3 arguments: self, key and value.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
  return val.
  define the method getlist with 3 arguments: self, key and default set to None.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
  if KeyError exception is caught,
  if default is None,
<annotation_end_b>#<body_start>          try :
              self . remove ( item )
  except KeyError :
              pass
    def __iter__ ( self ) :
          return iter ( self . dict . keys ( ) )
   def __contains__ ( self , item ) :
          return item in self . dict
   def __nonzero__ ( self ) :
          return bool ( self . dict )
     class MultiValueDictKeyError ( KeyError ) :
      pass
    class MultiValueDict ( dict ) :
 def __init__ ( self , key_to_list_mapping = ( ) ) :
          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
              return [ ]
    def __setitem__ ( self , key , value ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
  return val
   def getlist ( self , key , default = None ) :
 try :
              return super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              if default is None :
<body_end><annotation_start_b>  delete entry under item key of self.dict dictionary.
  define the method discard with 2 arguments: self and item.
  try,
  remove item from self dictionary.
  if KeyError exception is caught,
  do nothing.
  define the method __iter__ with an argument self.
  convert keys of dictionary self.dict into a iterable, return it.
  define the method __contains__ with 2 arguments: self and item.
  if item is contained in self.dict, return boolean True, otherwise return boolean False.
  define the method __nonzero__ with an argument self.
  convert self.dict into boolean, return the result.
  derive the class MultiValueDictKeyError from the KeyError base class.
  do nothing.
  derive the class MultiValueDict from the dict base class.
  define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
  return an empty list.
  define the method __setitem__ with 3 arguments: self, key and value.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
  return val.
  define the method getlist with 3 arguments: self, key and default set to None.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
  if KeyError exception is caught,
  if default is None,
  return an empty list.
<annotation_end_b>#<body_start>          del self . dict [ item ]
   def discard ( self , item ) :
          try :
              self . remove ( item )
  except KeyError :
              pass
    def __iter__ ( self ) :
          return iter ( self . dict . keys ( ) )
   def __contains__ ( self , item ) :
          return item in self . dict
   def __nonzero__ ( self ) :
          return bool ( self . dict )
     class MultiValueDictKeyError ( KeyError ) :
      pass
    class MultiValueDict ( dict ) :
 def __init__ ( self , key_to_list_mapping = ( ) ) :
          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
              return [ ]
    def __setitem__ ( self , key , value ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
  return val
   def getlist ( self , key , default = None ) :
 try :
              return super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              if default is None :
                  return [ ]
<body_end><annotation_start_b>  if key is not contanied in self,
  substitute default for value under the key key of self dictionary.
<annotation_end_b>#<body_start>          if key not in self :
              self [ key ] = default
<body_end><annotation_start_b>  if key is not contained in self,
  if default_list is None,
  default_list is an empty list.
  call the method self.setlist with 2 arguments: key and default_list.
<annotation_end_b>#<body_start>          if key not in self :
              if default_list is None :
                  default_list = [ ]
  self . setlist ( key , default_list )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
<annotation_end_b>#<body_start>          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
<body_end><annotation_start_b>  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
<annotation_end_b>#<body_start> if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
<body_end><annotation_start_b>  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
<annotation_end_b>#<body_start>          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
<body_end><annotation_start_b>  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
<annotation_end_b>#<body_start>          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
<body_end><annotation_start_b>  if self.data.hour is greater than integer 11,
<annotation_end_b>#<body_start> if self . data . hour > 11 :
<body_end><annotation_start_b>  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
<annotation_end_b>#<body_start>          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
<body_end><annotation_start_b>  if self.data.hour is greater than integer 11,
<annotation_end_b>#<body_start> if self . data . hour > 11 :
<body_end><annotation_start_b>  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
<annotation_end_b>#<body_start>          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
<body_end><annotation_start_b>  if self.timezone is false,
<annotation_end_b>#<body_start> if not self . timezone :
<body_end><annotation_start_b>  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
<annotation_end_b>#<body_start> raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
<body_end><annotation_start_b>  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
<annotation_end_b>#<body_start> if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
<body_end><annotation_start_b>  if self.data.minute equals integer 0,
<annotation_end_b>#<body_start> if self . data . minute == 0 :
<body_end><annotation_start_b>  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
<annotation_end_b>#<body_start> for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
<body_end><annotation_start_b>  if self.data.hour equals integer 0,
<annotation_end_b>#<body_start> if self . data . hour == 0 :
<body_end><annotation_start_b>  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
<annotation_end_b>#<body_start> for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
<body_end><annotation_start_b>  call the method self.setlistdefault with an argument key, append value to the result.
  define the method _iteritems with an argument self.
  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
  subtract integer 12 from self.data.hour, return the result.
<annotation_end_b>#<body_start> self . setlistdefault ( key ) . append ( value )
   def _iteritems ( self ) :
 for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
              return self . data . hour - 12
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self.timezone is false,
<annotation_end_b>#<body_start> if not self . timezone :
<body_end><annotation_start_b>  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list_.
  define the method setdefault with 3 arguments: self, key and default set to None.
  if key is not contanied in self,
  substitute default for value under the key key of self dictionary.
  return value under the key key of self dictionary.
  define the method setlistdefault with 3 arguments: self, key and default_list set to None.
  if key is not contained in self,
  if default_list is None,
  default_list is an empty list.
  call the method self.setlist with 2 arguments: key and default_list.
  call the method self.getlist with an argument key, return the result.
  define the method appendlist with 3 arguments: self, key and value.
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method _iteritems with an argument self.
  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
  subtract integer 12 from self.data.hour, return the result.
  return self.data.hour.
  define the method G with an argument self.
  return self.data.hour.
  define the method h with an argument self.
  return a string '%02d' formated with the result of the function self.g.
  define the method H with an argument self.
  return a string '%02d' formated with the result of the function self.G.
  define the method i with an argument self.
  return a string '%02d' formated with self.data.minute.
  define the method O with an argument self.
  if self.timezone is false,
  return an empty string.
  call the method self.Z, substitute the result for seconds.
  if seconds smaller than integer 0, sign is '-', otherwise sign is '+',
  substitute absolute seconds for seconds.
<annotation_end_b>#<body_start>          super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
   def setdefault ( self , key , default = None ) :
          if key not in self :
              self [ key ] = default
    return self [ key ]
   def setlistdefault ( self , key , default_list = None ) :
          if key not in self :
              if default_list is None :
                  default_list = [ ]
  self . setlist ( key , default_list )
    return self . getlist ( key )
   def appendlist ( self , key , value ) :
 self . setlistdefault ( key ) . append ( value )
   def _iteritems ( self ) :
 for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
              return self . data . hour - 12
  return self . data . hour
   def G ( self ) :
 return self . data . hour
   def h ( self ) :
 return '%02d' % self . g ( )
   def H ( self ) :
 return '%02d' % self . G ( )
   def i ( self ) :
 return '%02d' % self . data . minute
   def O ( self ) :
 if not self . timezone :
              return ""
   seconds = self . Z ( )
 sign = '-' if seconds < 0 else '+'
 seconds = abs ( seconds )
<body_end><annotation_start_b>  if self.data.minute equals integer 0 and self.data.hour equals integer 0,
<annotation_end_b>#<body_start> if self . data . minute == 0 and self . data . hour == 0 :
<body_end><annotation_start_b>  value under the item key of self.dict dictionary is None.
  define the method remove with 2 arguments: self and item.
  delete entry under item key of self.dict dictionary.
  define the method discard with 2 arguments: self and item.
  try,
  remove item from self dictionary.
  if KeyError exception is caught,
  do nothing.
  define the method __iter__ with an argument self.
  convert keys of dictionary self.dict into a iterable, return it.
  define the method __contains__ with 2 arguments: self and item.
  if item is contained in self.dict, return boolean True, otherwise return boolean False.
  define the method __nonzero__ with an argument self.
  convert self.dict into boolean, return the result.
  derive the class MultiValueDictKeyError from the KeyError base class.
  do nothing.
  derive the class MultiValueDict from the dict base class.
  define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
  return an empty list.
  define the method __setitem__ with 3 arguments: self, key and value.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
  return val.
  define the method getlist with 3 arguments: self, key and default set to None.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
  if KeyError exception is caught,
  if default is None,
  return an empty list.
  return default.
  define the method setlist with 3 arguments: self, key and list_.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list_.
  define the method setdefault with 3 arguments: self, key and default set to None.
  if key is not contanied in self,
  substitute default for value under the key key of self dictionary.
  return value under the key key of self dictionary.
  define the method setlistdefault with 3 arguments: self, key and default_list set to None.
  if key is not contained in self,
  if default_list is None,
  default_list is an empty list.
  call the method self.setlist with 2 arguments: key and default_list.
  call the method self.getlist with an argument key, return the result.
  define the method appendlist with 3 arguments: self, key and value.
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method _iteritems with an argument self.
  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
  subtract integer 12 from self.data.hour, return the result.
  return self.data.hour.
  define the method G with an argument self.
  return self.data.hour.
  define the method h with an argument self.
  return a string '%02d' formated with the result of the function self.g.
  define the method H with an argument self.
  return a string '%02d' formated with the result of the function self.G.
  define the method i with an argument self.
  return a string '%02d' formated with self.data.minute.
  define the method O with an argument self.
  if self.timezone is false,
  return an empty string.
  call the method self.Z, substitute the result for seconds.
  if seconds smaller than integer 0, sign is '-', otherwise sign is '+',
  substitute absolute seconds for seconds.
  return a string "%s%02d%02d" formated with sign, floored result of the division of seconds by integer 3000,
  reminder of the division of floored result of division of seconds by 60, by integer 60.   define the method P with an argument self.
  if self.data.minute equals integer 0 and self.data.hour equals integer 0,
  call the function _ with an argument string 'midnight', return the result.
  if self.data.minute equals integer 0 and self.data.hour equals integer 12,
<annotation_end_b>#<body_start>          self . dict [ item ] = None
   def remove ( self , item ) :
          del self . dict [ item ]
   def discard ( self , item ) :
          try :
              self . remove ( item )
  except KeyError :
              pass
    def __iter__ ( self ) :
          return iter ( self . dict . keys ( ) )
   def __contains__ ( self , item ) :
          return item in self . dict
   def __nonzero__ ( self ) :
          return bool ( self . dict )
     class MultiValueDictKeyError ( KeyError ) :
      pass
    class MultiValueDict ( dict ) :
 def __init__ ( self , key_to_list_mapping = ( ) ) :
          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
              return [ ]
    def __setitem__ ( self , key , value ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
  return val
   def getlist ( self , key , default = None ) :
 try :
              return super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              if default is None :
                  return [ ]
  return default
    def setlist ( self , key , list_ ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
   def setdefault ( self , key , default = None ) :
          if key not in self :
              self [ key ] = default
    return self [ key ]
   def setlistdefault ( self , key , default_list = None ) :
          if key not in self :
              if default_list is None :
                  default_list = [ ]
  self . setlist ( key , default_list )
    return self . getlist ( key )
   def appendlist ( self , key , value ) :
 self . setlistdefault ( key ) . append ( value )
   def _iteritems ( self ) :
 for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
              return self . data . hour - 12
  return self . data . hour
   def G ( self ) :
 return self . data . hour
   def h ( self ) :
 return '%02d' % self . g ( )
   def H ( self ) :
 return '%02d' % self . G ( )
   def i ( self ) :
 return '%02d' % self . data . minute
   def O ( self ) :
 if not self . timezone :
              return ""
   seconds = self . Z ( )
 sign = '-' if seconds < 0 else '+'
 seconds = abs ( seconds )
 return "%s%02d%02d" % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )
   def P ( self ) :
 if self . data . minute == 0 and self . data . hour == 0 :
              return _ ( 'midnight' )
  if self . data . minute == 0 and self . data . hour == 12 :
<body_end><annotation_start_b>  self.dict is an instance of OrderedDict class, created with arguments: tuples with 2 argument x and None, for every x in iterables,
  if iterable is true, otherwise use an empty list as an argument.   define the method add with 2 arguments: self and item.
  value under the item key of self.dict dictionary is None.
  define the method remove with 2 arguments: self and item.
  delete entry under item key of self.dict dictionary.
  define the method discard with 2 arguments: self and item.
  try,
  remove item from self dictionary.
  if KeyError exception is caught,
  do nothing.
  define the method __iter__ with an argument self.
  convert keys of dictionary self.dict into a iterable, return it.
  define the method __contains__ with 2 arguments: self and item.
  if item is contained in self.dict, return boolean True, otherwise return boolean False.
  define the method __nonzero__ with an argument self.
  convert self.dict into boolean, return the result.
  derive the class MultiValueDictKeyError from the KeyError base class.
  do nothing.
  derive the class MultiValueDict from the dict base class.
  define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
  return an empty list.
  define the method __setitem__ with 3 arguments: self, key and value.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
  return val.
  define the method getlist with 3 arguments: self, key and default set to None.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
  if KeyError exception is caught,
  if default is None,
  return an empty list.
  return default.
  define the method setlist with 3 arguments: self, key and list_.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list_.
  define the method setdefault with 3 arguments: self, key and default set to None.
  if key is not contanied in self,
  substitute default for value under the key key of self dictionary.
  return value under the key key of self dictionary.
  define the method setlistdefault with 3 arguments: self, key and default_list set to None.
  if key is not contained in self,
  if default_list is None,
  default_list is an empty list.
  call the method self.setlist with 2 arguments: key and default_list.
  call the method self.getlist with an argument key, return the result.
  define the method appendlist with 3 arguments: self, key and value.
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method _iteritems with an argument self.
  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
  subtract integer 12 from self.data.hour, return the result.
  return self.data.hour.
  define the method G with an argument self.
  return self.data.hour.
  define the method h with an argument self.
  return a string '%02d' formated with the result of the function self.g.
  define the method H with an argument self.
  return a string '%02d' formated with the result of the function self.G.
  define the method i with an argument self.
  return a string '%02d' formated with self.data.minute.
  define the method O with an argument self.
  if self.timezone is false,
  return an empty string.
  call the method self.Z, substitute the result for seconds.
  if seconds smaller than integer 0, sign is '-', otherwise sign is '+',
  substitute absolute seconds for seconds.
  return a string "%s%02d%02d" formated with sign, floored result of the division of seconds by integer 3000,
  reminder of the division of floored result of division of seconds by 60, by integer 60.   define the method P with an argument self.
  if self.data.minute equals integer 0 and self.data.hour equals integer 0,
  call the function _ with an argument string 'midnight', return the result.
  if self.data.minute equals integer 0 and self.data.hour equals integer 12,
  call the function _ with an argument string 'noon', return the result.
<annotation_end_b>#<body_start>          self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )
   def add ( self , item ) :
          self . dict [ item ] = None
   def remove ( self , item ) :
          del self . dict [ item ]
   def discard ( self , item ) :
          try :
              self . remove ( item )
  except KeyError :
              pass
    def __iter__ ( self ) :
          return iter ( self . dict . keys ( ) )
   def __contains__ ( self , item ) :
          return item in self . dict
   def __nonzero__ ( self ) :
          return bool ( self . dict )
     class MultiValueDictKeyError ( KeyError ) :
      pass
    class MultiValueDict ( dict ) :
 def __init__ ( self , key_to_list_mapping = ( ) ) :
          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
              return [ ]
    def __setitem__ ( self , key , value ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
  return val
   def getlist ( self , key , default = None ) :
 try :
              return super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              if default is None :
                  return [ ]
  return default
    def setlist ( self , key , list_ ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
   def setdefault ( self , key , default = None ) :
          if key not in self :
              self [ key ] = default
    return self [ key ]
   def setlistdefault ( self , key , default_list = None ) :
          if key not in self :
              if default_list is None :
                  default_list = [ ]
  self . setlist ( key , default_list )
    return self . getlist ( key )
   def appendlist ( self , key , value ) :
 self . setlistdefault ( key ) . append ( value )
   def _iteritems ( self ) :
 for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
              return self . data . hour - 12
  return self . data . hour
   def G ( self ) :
 return self . data . hour
   def h ( self ) :
 return '%02d' % self . g ( )
   def H ( self ) :
 return '%02d' % self . G ( )
   def i ( self ) :
 return '%02d' % self . data . minute
   def O ( self ) :
 if not self . timezone :
              return ""
   seconds = self . Z ( )
 sign = '-' if seconds < 0 else '+'
 seconds = abs ( seconds )
 return "%s%02d%02d" % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )
   def P ( self ) :
 if self . data . minute == 0 and self . data . hour == 0 :
              return _ ( 'midnight' )
  if self . data . minute == 0 and self . data . hour == 12 :
              return _ ( 'noon' )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self.timezone is false,
<annotation_end_b>#<body_start> if not self . timezone :
<body_end><annotation_start_b>  call the method clear from the base class of the class SortedDict.
  self.keyOrder is an empty list.
  derive the class OrderedSet from the object base class.
  define the method __init__ with 2 arguments: self and iterable set to None.
  self.dict is an instance of OrderedDict class, created with arguments: tuples with 2 argument x and None, for every x in iterables,
  if iterable is true, otherwise use an empty list as an argument.   define the method add with 2 arguments: self and item.
  value under the item key of self.dict dictionary is None.
  define the method remove with 2 arguments: self and item.
  delete entry under item key of self.dict dictionary.
  define the method discard with 2 arguments: self and item.
  try,
  remove item from self dictionary.
  if KeyError exception is caught,
  do nothing.
  define the method __iter__ with an argument self.
  convert keys of dictionary self.dict into a iterable, return it.
  define the method __contains__ with 2 arguments: self and item.
  if item is contained in self.dict, return boolean True, otherwise return boolean False.
  define the method __nonzero__ with an argument self.
  convert self.dict into boolean, return the result.
  derive the class MultiValueDictKeyError from the KeyError base class.
  do nothing.
  derive the class MultiValueDict from the dict base class.
  define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
  return an empty list.
  define the method __setitem__ with 3 arguments: self, key and value.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
  return val.
  define the method getlist with 3 arguments: self, key and default set to None.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
  if KeyError exception is caught,
  if default is None,
  return an empty list.
  return default.
  define the method setlist with 3 arguments: self, key and list_.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list_.
  define the method setdefault with 3 arguments: self, key and default set to None.
  if key is not contanied in self,
  substitute default for value under the key key of self dictionary.
  return value under the key key of self dictionary.
  define the method setlistdefault with 3 arguments: self, key and default_list set to None.
  if key is not contained in self,
  if default_list is None,
  default_list is an empty list.
  call the method self.setlist with 2 arguments: key and default_list.
  call the method self.getlist with an argument key, return the result.
  define the method appendlist with 3 arguments: self, key and value.
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method _iteritems with an argument self.
  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
  subtract integer 12 from self.data.hour, return the result.
  return self.data.hour.
  define the method G with an argument self.
  return self.data.hour.
  define the method h with an argument self.
  return a string '%02d' formated with the result of the function self.g.
  define the method H with an argument self.
  return a string '%02d' formated with the result of the function self.G.
  define the method i with an argument self.
  return a string '%02d' formated with self.data.minute.
  define the method O with an argument self.
  if self.timezone is false,
  return an empty string.
  call the method self.Z, substitute the result for seconds.
  if seconds smaller than integer 0, sign is '-', otherwise sign is '+',
  substitute absolute seconds for seconds.
  return a string "%s%02d%02d" formated with sign, floored result of the division of seconds by integer 3000,
  reminder of the division of floored result of division of seconds by 60, by integer 60.   define the method P with an argument self.
  if self.data.minute equals integer 0 and self.data.hour equals integer 0,
  call the function _ with an argument string 'midnight', return the result.
  if self.data.minute equals integer 0 and self.data.hour equals integer 12,
  call the function _ with an argument string 'noon', return the result.
  return a string '%02d' formated with self.data.month.
  define the method s with an argument self.
  return a string '%02d' formated with self.data.second.
  define the method T with an argument self.
  if self.timezone is false,
  return an empty string.
  if self.timezone is true, call the method self.timezone.tzname with an argument self.data, substitute the result for name,
  otherwise name is None.   if name is None,
  call the method self.format with an argument string '0', substitute the result for name.
<annotation_end_b>#<body_start>          super ( SortedDict , self ) . clear ( )
 self . keyOrder = [ ]
     class OrderedSet ( object ) :
  def __init__ ( self , iterable = None ) :
          self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )
   def add ( self , item ) :
          self . dict [ item ] = None
   def remove ( self , item ) :
          del self . dict [ item ]
   def discard ( self , item ) :
          try :
              self . remove ( item )
  except KeyError :
              pass
    def __iter__ ( self ) :
          return iter ( self . dict . keys ( ) )
   def __contains__ ( self , item ) :
          return item in self . dict
   def __nonzero__ ( self ) :
          return bool ( self . dict )
     class MultiValueDictKeyError ( KeyError ) :
      pass
    class MultiValueDict ( dict ) :
 def __init__ ( self , key_to_list_mapping = ( ) ) :
          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
              return [ ]
    def __setitem__ ( self , key , value ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
  return val
   def getlist ( self , key , default = None ) :
 try :
              return super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              if default is None :
                  return [ ]
  return default
    def setlist ( self , key , list_ ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
   def setdefault ( self , key , default = None ) :
          if key not in self :
              self [ key ] = default
    return self [ key ]
   def setlistdefault ( self , key , default_list = None ) :
          if key not in self :
              if default_list is None :
                  default_list = [ ]
  self . setlist ( key , default_list )
    return self . getlist ( key )
   def appendlist ( self , key , value ) :
 self . setlistdefault ( key ) . append ( value )
   def _iteritems ( self ) :
 for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
              return self . data . hour - 12
  return self . data . hour
   def G ( self ) :
 return self . data . hour
   def h ( self ) :
 return '%02d' % self . g ( )
   def H ( self ) :
 return '%02d' % self . G ( )
   def i ( self ) :
 return '%02d' % self . data . minute
   def O ( self ) :
 if not self . timezone :
              return ""
   seconds = self . Z ( )
 sign = '-' if seconds < 0 else '+'
 seconds = abs ( seconds )
 return "%s%02d%02d" % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )
   def P ( self ) :
 if self . data . minute == 0 and self . data . hour == 0 :
              return _ ( 'midnight' )
  if self . data . minute == 0 and self . data . hour == 12 :
              return _ ( 'noon' )
  return '%s %s' % ( self . f ( ) , self . a ( ) )
   def s ( self ) :
 return '%02d' % self . data . second
   def T ( self ) :
 if not self . timezone :
              return ""
   name = self . timezone . tzname ( self . data ) if self . timezone else None
 if name is None :
              name = self . format ( 'O' )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self.timezone is true,
<annotation_end_b>#<body_start> if not self . timezone :
<body_end><annotation_start_b>  call the method six.iteritems with an argument dict_, for every k and v in the result,
  substitute v for value under the k key of self dictionary.
  define the method setdefault with 3 arguments: self, key and default.
  if key is not contained in self,
  append key to self.keyOrder dictionary.
  call the method setdefault from the base class of the class SortedDict, with 2 arguments key and default, return the result.
  define the method copy with an argument self.
  call the method self.__class__ with an argument self, return the result.
  define the method __repr__ with an argument self.
  for every k and v in result of the function six.iteritems,called with an argument self,
  joining string '%r: %r' formated with k and v into a string, separated with ', ', use it to format a string '{%s}', return it.   define the method clear with an argument self.
  call the method clear from the base class of the class SortedDict.
  self.keyOrder is an empty list.
  derive the class OrderedSet from the object base class.
  define the method __init__ with 2 arguments: self and iterable set to None.
  self.dict is an instance of OrderedDict class, created with arguments: tuples with 2 argument x and None, for every x in iterables,
  if iterable is true, otherwise use an empty list as an argument.   define the method add with 2 arguments: self and item.
  value under the item key of self.dict dictionary is None.
  define the method remove with 2 arguments: self and item.
  delete entry under item key of self.dict dictionary.
  define the method discard with 2 arguments: self and item.
  try,
  remove item from self dictionary.
  if KeyError exception is caught,
  do nothing.
  define the method __iter__ with an argument self.
  convert keys of dictionary self.dict into a iterable, return it.
  define the method __contains__ with 2 arguments: self and item.
  if item is contained in self.dict, return boolean True, otherwise return boolean False.
  define the method __nonzero__ with an argument self.
  convert self.dict into boolean, return the result.
  derive the class MultiValueDictKeyError from the KeyError base class.
  do nothing.
  derive the class MultiValueDict from the dict base class.
  define the method __init__ with 2 arguments: self and key_to_list_mapping set to an empty tuple.
  call the method __init__ from the base class of the class MultiValueDict, with an argument key_to_list_mapping.
  define the method __repr__ with an argument self.
  return a string "<%s: %s>" formated with self.__class__.__name__,
  and a result of the method __repr__ called from instance of base class of the MultiValueDict class.   define the method __getitem__ with 2 arguments: self and key.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, substitute the result for list_.
  if KeyError exception is caught,
  raise an MultiValueDictKeyError exception with printable representation of key.
  try,
  return last element of list_.
  if IndexError exception is caught,
  return an empty list.
  define the method __setitem__ with 3 arguments: self, key and value.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list containing element value.
  define the method __copy__ with an argument self.
  call the method self.__class__ with an argument list, with elements: tuples with 2 elements: k and hard copy of list v,
  for every k and v in result of method the self.lists.   define the method __deepcopy__ with 2 arguments: self and memo set to None.
  if memo is None,
  memo is an empty dictionary.
  call the method self.__class__, substitute the result for result.
  substitute result for value under the id of self key of memo dictionary.
  for every key and value in items of dictionary self,
  call the method dict.__setitem__ with 3 arguments: result, result of the function copy.deepcopy, called with 2 arguments: key,
  and memo, and result of the function copy.deepcopy called with 2 arguments: value and memo.   return result.
  define the method __getstate__ with an argument self.
  call the method self.__dict__.copy, substitute the result for obj_dict.
  value under '_data' key of obj_dict is a dictionary created with tuples containing 2 elements: k and result of the function,
  self.getlist with an argument k, for every k in self.   return obj_dict.
  define the method __setstate__ with 2 arguments: self and obj_dict.
  remove element under '_data' key of obj_dict dictionary, if it exists substitute it for data, if not data is an empty list.
  call the method data.items, for every k and v in the result,
  call the method self.setlist with 2 arguments: k and v.
  update self.__dict__ dictionary with obj_dict.
  define the method get with 3 arguments: self, key and default set to None.
  try,
  substitute value under the key key of self dictionary for val.
  if KeyError exception is caught,
  return default,
  if val equals an empty list.
  return default.
  return val.
  define the method getlist with 3 arguments: self, key and default set to None.
  try,
  call the method __getitem__ from the base class of the class MultiValueDict, with an argument key, return the result..
  if KeyError exception is caught,
  if default is None,
  return an empty list.
  return default.
  define the method setlist with 3 arguments: self, key and list_.
  call the method __setitem__ from the base class of the class MultiValueDict, with 2 arguments key and list_.
  define the method setdefault with 3 arguments: self, key and default set to None.
  if key is not contanied in self,
  substitute default for value under the key key of self dictionary.
  return value under the key key of self dictionary.
  define the method setlistdefault with 3 arguments: self, key and default_list set to None.
  if key is not contained in self,
  if default_list is None,
  default_list is an empty list.
  call the method self.setlist with 2 arguments: key and default_list.
  call the method self.getlist with an argument key, return the result.
  define the method appendlist with 3 arguments: self, key and value.
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method _iteritems with an argument self.
  for every key in self,
  yield key and value under the key key of self dictionary.
  define the method _iterlists with an argument self.
  call the function six.iteritems with an argument: instance of base class of the MultiValueDict class, return the result.
  define the method _itervalues with an argument self.
  for every key in self,
  yield value under key key of self dictionary.
  if six.PY3 is true,
  substitute _iteritems for items.
  substitute _iterlists for lists.
  substitute _itervalues for values.
  if not,
  substitute _iteritems for iteritems.
  substitute _iterlists for iterlists.
  substitute _itervalues for itervalues.
  define the method items with an argument self.
  call the method self.iteritems, return list of results.
  define the method lists with an argument self.
  call the method self.iterlists, return list of results.
  define the method values with an argument self.
  call the method self.itervalues, return list of results.
  define the method copy with an argument self.
  call the method copy.copy with an argument self, return the result.
  define the method update with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  if length of args is greater than integer 1,
  raise an TypeError with an argument string "update expected at most 1 arguments, got %d" formated with length of args.
  if args is true,
  substitute first args for other_dict.
  if other_dict is an instance of MultiValueDict.
  call the method other_dict.lists, for every key and value_list in result,
  call the method self.setlistdefault with an argument key, extend the result with value_list.
  if not,
  trym
  for every key and value in items of other_dict dictionary,
  call the method self.setlistdefault with an argument key, append value to the result.
  if TypeError exception is caught,
  raise an ValueError with an argument string "MultiValueDict.update() takes either a MultiValueDict or dictionary".
  call the function six.iteritems with an argument kwargs, for every key and value in the result,
  call the method self.setlistdefault with an argument key, append value to the result.
  define the method dict with an argument self.
  return dictionary created with tuples with 2 elements: key and value under the key key of self dictionary, for every key in self.
  derive the class ImmutableList from the tuple base class.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  if 'warning' is contained in kwargs,
  substitute value under 'warning' key of kwargs dictionary for warning.
  delete element under 'warning' key of kwargs dictionary.
  if not,
  warning is a string 'ImmutableList object is immutable.'.
  call the method tuple.__new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs, substitute the result for self.
  substitute warning for self.warning.
  return self.
  define the method complain with 3 arguments: self, unpacked dictionary wargs and unpacked dictionary kwargs.
  if self.warning is an instance of Exception class,
  raise self.warning.
  if not,
  raise an raise self.warning with an argument self.warning.
  substitute complain for __delitem__.
  substitute complain for __delslice__.
  substitute complain for __iadd__.
  substitute complain for __imul__.
  substitute complain for __setitem__.
  substitute complain for __setslice__.
  substitute complain for append.
  substitute complain for extend.
  substitute complain for insert.
  substitute complain for pop.
  substitute complain for remove.
  substitute complain for sort.
  substitute complain for reverse.
  derive the class DictWrapper from the dict base class.
  define the method __init__ with 4 arguments: self, data, func and prefix.
  call the method __init__ with an argument data, from the base class of the class DictWrapper.
  substitute func for self.func.
  substitute prefix for self.prefix.
  define the method __getitem__ with 2 arguments: self and key.
  if key starts with self.prefix.
  use_func is boolean True.
  key is a list with elements of list key from length of self.prefixes index to the end,
  if not,
  use_func is boolean False.
  call the method __getitem__ with an argument key from the base class of the class DictWrapper, substitute the result for value.
  if use_func is true,
  call the method self.func with an argument value.
  return value.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module time.
  import module calendar.
  import module datetime.
  from django.utils.dates import MONTHS, MONTHS_3, MONTHS_ALT, MONTHS_AP, WEEKDAYS and WEEKDAYS_ABBR into default name space.
  from django.utils.translation import ugettext as _ into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils import six into default name space.
  from django.utils.timezone import get_default_timezone, is_aware and is_naive into default name space.
  compile regex from a string '(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])', substitute it for re_formatchars.
  compile regex from a string '\\(.)', substitute it for re_escaped.
  derive the class Formatter from object base class.
  define the function format with 2 arguments self and formatstr.
  pieces is an empty list.
  call the function force_text with an argument formatstr, use the result as an argument for the call to the method,
  re_formatchars.split, for every i and piece in enumerated result,   if i is even number,
  get attribute piece of the self object, call it and use the result as an argument for the call to the function force_text,
  append the result to pieces.   otherwise if piece is true,
  call the method re_escaped.sub with 2 arguments: raw string '\1' and piece, append the result to pieces.
  join elements of pieces into a string, return it.
  derive the class TimeFormat from the base class Formatter.
  define the method __init__ with 2 arguments: self and obj.
  substitute obj for self.data.
  self.timezone is None.
  if obj is an instance of datetime.datetime,
  call the function is_naive with an argument obj.
  call the function get_default_timezone, substitute the result for self.timezone.
  if not,
  substitute obj.tzinfo for self.timezone.
  define the method a with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'p.m.', return the result.
  call the function _ with an argument string 'a.m.', return the result.
  define the method A with an argument self.
  if self.data.hour is greater than integer 11,
  call the function _ with an argument string 'PM', return the result.
  call the function _ with an argument string 'AM', return the result.
  define the method B with an argument self.
  raise an NotImplementedError exception with an argument string 'may be implemented in a future release'.
  define the method e with an argument self.
  if self.timezone is false,
  return an empty string.
  try,
  is self.data has an attribute 'tzinfo' and self.data.tzinfo is true,
  call the method self.data.tzinfo.tzname with an argument self.data, if it is true, return it, otherwise return an empty string.
  if NotImplementedError exception is caught,
  do nothing.
  return an empty string.
  define the method f with an argument self.
  if self.data.minute equals integer 0,
  call the method self.g, return the result.
  return a string '%s:%s' formated with the results of the functions self.g and self.i, respectivley.
  define the method g with an argument self.
  if self.data.hour equals integer 0,
  return integer 12.
  if self.data.hour is greater than inreger 12,
  subtract integer 12 from self.data.hour, return the result.
  return self.data.hour.
  define the method G with an argument self.
  return self.data.hour.
  define the method h with an argument self.
  return a string '%02d' formated with the result of the function self.g.
  define the method H with an argument self.
  return a string '%02d' formated with the result of the function self.G.
  define the method i with an argument self.
  return a string '%02d' formated with self.data.minute.
  define the method O with an argument self.
  if self.timezone is false,
  return an empty string.
  call the method self.Z, substitute the result for seconds.
  if seconds smaller than integer 0, sign is '-', otherwise sign is '+',
  substitute absolute seconds for seconds.
  return a string "%s%02d%02d" formated with sign, floored result of the division of seconds by integer 3000,
  reminder of the division of floored result of division of seconds by 60, by integer 60.   define the method P with an argument self.
  if self.data.minute equals integer 0 and self.data.hour equals integer 0,
  call the function _ with an argument string 'midnight', return the result.
  if self.data.minute equals integer 0 and self.data.hour equals integer 12,
  call the function _ with an argument string 'noon', return the result.
  return a string '%02d' formated with self.data.month.
  define the method s with an argument self.
  return a string '%02d' formated with self.data.second.
  define the method T with an argument self.
  if self.timezone is false,
  return an empty string.
  if self.timezone is true, call the method self.timezone.tzname with an argument self.data, substitute the result for name,
  otherwise name is None.   if name is None,
  call the method self.format with an argument string '0', substitute the result for name.
  call the function six.text_type with an argument name, return the result.
  define the method u with an argument self.
  return a string '%06d' formated with self.data.microsecond.
  define the method Z with an argument self.
  if self.timezone is true,
  return an empty string.
  call the method self.timezone.utcoffset with an argument self.data, substitute the result for offset.
<annotation_end_b>#<body_start>          for k , v in six . iteritems ( dict_ ) :
              self [ k ] = v
    def setdefault ( self , key , default ) :
          if key not in self :
              self . keyOrder . append ( key )
  return super ( SortedDict , self ) . setdefault ( key , default )
   def copy ( self ) :
  return self . __class__ ( self )
   def __repr__ ( self ) :
 return '{%s}' % ', ' . join ( '%r: %r' % ( k , v ) for k , v in six . iteritems ( self ) )
   def clear ( self ) :
          super ( SortedDict , self ) . clear ( )
 self . keyOrder = [ ]
     class OrderedSet ( object ) :
  def __init__ ( self , iterable = None ) :
          self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )
   def add ( self , item ) :
          self . dict [ item ] = None
   def remove ( self , item ) :
          del self . dict [ item ]
   def discard ( self , item ) :
          try :
              self . remove ( item )
  except KeyError :
              pass
    def __iter__ ( self ) :
          return iter ( self . dict . keys ( ) )
   def __contains__ ( self , item ) :
          return item in self . dict
   def __nonzero__ ( self ) :
          return bool ( self . dict )
     class MultiValueDictKeyError ( KeyError ) :
      pass
    class MultiValueDict ( dict ) :
 def __init__ ( self , key_to_list_mapping = ( ) ) :
          super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
   def __repr__ ( self ) :
          return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
   def __getitem__ ( self , key ) :
 try :
              list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              raise MultiValueDictKeyError ( repr ( key ) )
  try :
              return list_ [ - 1 ]
  except IndexError :
              return [ ]
    def __setitem__ ( self , key , value ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
   def __copy__ ( self ) :
          return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
   def __deepcopy__ ( self , memo = None ) :
          if memo is None :
              memo = { }
  result = self . __class__ ( )
 memo [ id ( self ) ] = result
 for key , value in dict . items ( self ) :
              dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
  return result
   def __getstate__ ( self ) :
          obj_dict = self . __dict__ . copy ( )
 obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
 return obj_dict
   def __setstate__ ( self , obj_dict ) :
          data = obj_dict . pop ( '_data' , { } )
 for k , v in data . items ( ) :
              self . setlist ( k , v )
  self . __dict__ . update ( obj_dict )
   def get ( self , key , default = None ) :
 try :
              val = self [ key ]
  except KeyError :
              return default
  if val == [ ] :
              return default
  return val
   def getlist ( self , key , default = None ) :
 try :
              return super ( MultiValueDict , self ) . __getitem__ ( key )
  except KeyError :
              if default is None :
                  return [ ]
  return default
    def setlist ( self , key , list_ ) :
          super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
   def setdefault ( self , key , default = None ) :
          if key not in self :
              self [ key ] = default
    return self [ key ]
   def setlistdefault ( self , key , default_list = None ) :
          if key not in self :
              if default_list is None :
                  default_list = [ ]
  self . setlist ( key , default_list )
    return self . getlist ( key )
   def appendlist ( self , key , value ) :
 self . setlistdefault ( key ) . append ( value )
   def _iteritems ( self ) :
 for key in self :
              yield key , self [ key ]
    def _iterlists ( self ) :
 return six . iteritems ( super ( MultiValueDict , self ) )
   def _itervalues ( self ) :
 for key in self :
              yield self [ key ]
    if six . PY3 :
          items = _iteritems
 lists = _iterlists
 values = _itervalues
  else :
          iteritems = _iteritems
 iterlists = _iterlists
 itervalues = _itervalues
  def items ( self ) :
              return list ( self . iteritems ( ) )
   def lists ( self ) :
              return list ( self . iterlists ( ) )
   def values ( self ) :
              return list ( self . itervalues ( ) )
    def copy ( self ) :
 return copy . copy ( self )
   def update ( self , * args , ** kwargs ) :
 if len ( args ) > 1 :
              raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
  if args :
              other_dict = args [ 0 ]
 if isinstance ( other_dict , MultiValueDict ) :
                  for key , value_list in other_dict . lists ( ) :
                      self . setlistdefault ( key ) . extend ( value_list )
   else :
                  try :
                      for key , value in other_dict . items ( ) :
                          self . setlistdefault ( key ) . append ( value )
   except TypeError :
                      raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
    for key , value in six . iteritems ( kwargs ) :
              self . setlistdefault ( key ) . append ( value )
    def dict ( self ) :
 return dict ( ( key , self [ key ] ) for key in self )
     class ImmutableList ( tuple ) :
  def __new__ ( cls , * args , ** kwargs ) :
          if 'warning' in kwargs :
              warning = kwargs [ 'warning' ]
 del kwargs [ 'warning' ]
  else :
              warning = 'ImmutableList object is immutable.'
  self = tuple . __new__ ( cls , * args , ** kwargs )
 self . warning = warning
 return self
   def complain ( self , * wargs , ** kwargs ) :
          if isinstance ( self . warning , Exception ) :
              raise self . warning
  else :
              raise AttributeError ( self . warning )
     __delitem__ = complain
 __delslice__ = complain
 __iadd__ = complain
 __imul__ = complain
 __setitem__ = complain
 __setslice__ = complain
 append = complain
 extend = complain
 insert = complain
 pop = complain
 remove = complain
 sort = complain
 reverse = complain
    class DictWrapper ( dict ) :
 def __init__ ( self , data , func , prefix ) :
          super ( DictWrapper , self ) . __init__ ( data )
 self . func = func
 self . prefix = prefix
   def __getitem__ ( self , key ) :
 if key . startswith ( self . prefix ) :
              use_func = True
 key = key [ len ( self . prefix ) : ]
  else :
              use_func = False
  value = super ( DictWrapper , self ) . __getitem__ ( key )
 if use_func :
              return self . func ( value )
  return value
 from __future__ import unicode_literals
  import re
 import time
 import calendar
 import datetime
  from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
 from django . utils . translation import ugettext as _
 from django . utils . encoding import force_text
 from django . utils import six
 from django . utils . timezone import get_default_timezone , is_aware , is_naive
  re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
 re_escaped = re . compile ( r'\\(.)' )
   class Formatter ( object ) :
      def format ( self , formatstr ) :
          pieces = [ ]
 for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
              if i % 2 :
                  pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
  elif piece :
                  pieces . append ( re_escaped . sub ( r'\1' , piece ) )
   return '' . join ( pieces )
     class TimeFormat ( Formatter ) :
       def __init__ ( self , obj ) :
          self . data = obj
 self . timezone = None
     if isinstance ( obj , datetime . datetime ) :
              if is_naive ( obj ) :
                  self . timezone = get_default_timezone ( )
  else :
                  self . timezone = obj . tzinfo
     def a ( self ) :
 if self . data . hour > 11 :
              return _ ( 'p.m.' )
  return _ ( 'a.m.' )
   def A ( self ) :
 if self . data . hour > 11 :
              return _ ( 'PM' )
  return _ ( 'AM' )
   def B ( self ) :
 raise NotImplementedError ( 'may be implemented in a future release' )
   def e ( self ) :
 if not self . timezone :
              return ""
   try :
              if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
                    return self . data . tzinfo . tzname ( self . data ) or ""
   except NotImplementedError :
              pass
  return ""
   def f ( self ) :
 if self . data . minute == 0 :
              return self . g ( )
  return '%s:%s' % ( self . g ( ) , self . i ( ) )
   def g ( self ) :
 if self . data . hour == 0 :
              return 12
  if self . data . hour > 12 :
              return self . data . hour - 12
  return self . data . hour
   def G ( self ) :
 return self . data . hour
   def h ( self ) :
 return '%02d' % self . g ( )
   def H ( self ) :
 return '%02d' % self . G ( )
   def i ( self ) :
 return '%02d' % self . data . minute
   def O ( self ) :
 if not self . timezone :
              return ""
   seconds = self . Z ( )
 sign = '-' if seconds < 0 else '+'
 seconds = abs ( seconds )
 return "%s%02d%02d" % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )
   def P ( self ) :
 if self . data . minute == 0 and self . data . hour == 0 :
              return _ ( 'midnight' )
  if self . data . minute == 0 and self . data . hour == 12 :
              return _ ( 'noon' )
  return '%s %s' % ( self . f ( ) , self . a ( ) )
   def s ( self ) :
 return '%02d' % self . data . second
   def T ( self ) :
 if not self . timezone :
              return ""
   name = self . timezone . tzname ( self . data ) if self . timezone else None
 if name is None :
              name = self . format ( 'O' )
  return six . text_type ( name )
   def u ( self ) :
 return '%06d' % self . data . microsecond
   def Z ( self ) :
 if not self . timezone :
              return ""
   offset = self . timezone . utcoffset ( self . data )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self.timezone is true and call to the method self.timezone.dst with an argument self.data, evaluates to true,
<annotation_end_b>#<body_start> if self . timezone and self . timezone . dst ( self . data ) :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self.data.day equals integer 11, 12 or 13,
<annotation_end_b>#<body_start> if self . data . day in ( 11 , 12 , 13 ) :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self.data is an instance of datetime.datetime and result of the function is_aware called with an argument self.data evaluates to true,
<annotation_end_b>#<body_start> if isinstance ( self . data , datetime . datetime ) and is_aware ( self . data ) :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  week_number is None.
  call the method self.data.replace with 2 arguments: month as integer 1 and day as integer 1, on the result call the method,
  weekday, increment the result by integer 1 and substitute it for jan1_weekday.   call the method self.data.weekday, increment the result by integer 1, substitute the result for weekday.
  call the method self.z, substitute the result for day_of_year.
  if day_of_year is smaller than or equalt to jan1_weekday subtracted from integer 8 and jan1_weekday is greater than integer 4,
  if jan1_weekday equals integer 5, or if jan1_weekday equals integer 6 and call to the function calendar.isleap,
  with an argument self.data.year decremented by 1, evaluates to true,   week_number is integer 53.
  if not,
  week_number is integer 52.
  if not,
  call the function calendar.isleap with an argument self.data.year, if it evaluates to true,
  i is integer 366.
  if not,
  i is integer 365.
  subtract day_of_year from i, if the result is smaller than the result of subtraction of weekday from integer 4,
  week_number is integer 1.
  if not,
  sum day_of_year, result of the subtraction of weekday from integer 7 and subtraction of integer 1 from jan1_weekday.
  divide j by integer 7, substitute the floored result for week_number.
  if jan1_weekday is greater than integer 4,
  decrement week_number by integer 1.
<annotation_end_b>#<body_start>  week_number = None
 jan1_weekday = self . data . replace ( month = 1 , day = 1 ) . weekday ( ) + 1
 weekday = self . data . weekday ( ) + 1
 day_of_year = self . z ( )
 if day_of_year <= ( 8 - jan1_weekday ) and jan1_weekday > 4 :
              if jan1_weekday == 5 or ( jan1_weekday == 6 and calendar . isleap ( self . data . year - 1 ) ) :
                  week_number = 53
  else :
                  week_number = 52
   else :
              if calendar . isleap ( self . data . year ) :
                  i = 366
  else :
                  i = 365
  if ( i - day_of_year ) < ( 4 - weekday ) :
                  week_number = 1
  else :
                  j = day_of_year + ( 7 - weekday ) + ( jan1_weekday - 1 )
 week_number = j // 7
 if jan1_weekday > 4 :
                      week_number -= 1
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  append self.data.day to the value under the self.data.month key of the self.year_days dictionary, substitute the result for doy.
  if call to the method self.L evaluates to true, and result of the call to the method self.data.month is greater than integer 2,
  increment doy by integer 1.
<annotation_end_b>#<body_start> doy = self . year_days [ self . data . month ] + self . data . day
 if self . L ( ) and self . data . month > 2 :
              doy += 1
<body_end><annotation_start_b>  df is an instance of DateFormat class, created with an argument value.
<annotation_end_b>#<body_start> df = DateFormat ( value )
<body_end><annotation_start_b>  tf is an instance of TimeFormat class, created with an argument value.
<annotation_end_b>#<body_start> tf = TimeFormat ( value )
<body_end><annotation_start_b>  match regex date_re with value, substitute the result for match.
  if match is true,
  call the method match.groupdict, use the result as an argument for the call to the function six.iteritems,
<annotation_end_b>#<body_start> match = date_re . match ( value )
 if match :
          kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( match . groupdict ( ) ) )
<body_end><annotation_start_b>  match regex time_re with value, substitute the result for match.
  if match is true,
  call the method match.groupdict, substitute the result for kw.
  if value under the 'microsecond' key of the kw dictionary is true,
  left justify value under the 'microsecond' key of the kw dictionary, in the field of width 6, fill the rest with '0',
  substitute the result for value under the 'microsecond' key of the kw dictionary.   update a dictionary with an entry v converted to an integer for k, for every k and v in result of the function six.iteritems,
<annotation_end_b>#<body_start> match = time_re . match ( value )
 if match :
          kw = match . groupdict ( )
 if kw [ 'microsecond' ] :
              kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' )
  kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
<body_end><annotation_start_b>  match regex datetime_re with value, substitute the result for match.
  if match is true,
  call the method match.groupdict, substitute the result for kw.
  if value under the 'microsecond' key of the kw dictionary is true,
  left justify value under the 'microsecond' key of the kw dictionary, in the field of width 6, fill the rest with '0',
  substitute the result for value under the 'microsecond' key of the kw dictionary.   remove entry under the 'tzinfo' key of the kw dictionary, substitute it for tzinfo.
  if tzinfo equals a string 'Z',
  substitute utc for tzinfo.
  otherwise if tzinfo is not None,
  if length of tzinfo is greater than integer 3, convert elements of tzinfo from indexes 1 to 3 to an integer,
  substitute the result for offset_mins, otherwise offset_mins is integer 0.   convert elements of tzinfo from indexes 1 to 3 to an integer, multiply it by integer 60 and increment it by offset_mins,
  substitute the result for offset.   if first element of tzinfo equals '-',
  multiply offset by integer -1.
  call the function get_fixed_timezone with an argument offset, substitute the result for tzinfo.
  update a dictionary with an entry v converted to an integer for k, for every k and v in result of the function six.iteritems,
  called with an argument kw, only if v is not None, substitute the result for kw.   substitute tzinfo for value under the 'tzinfo' key of the kw dictionary.
<annotation_end_b>#<body_start> match = datetime_re . match ( value )
 if match :
          kw = match . groupdict ( )
 if kw [ 'microsecond' ] :
              kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' )
  tzinfo = kw . pop ( 'tzinfo' )
 if tzinfo == 'Z' :
              tzinfo = utc
  elif tzinfo is not None :
              offset_mins = int ( tzinfo [ - 2 : ] ) if len ( tzinfo ) > 3 else 0
 offset = 60 * int ( tzinfo [ 1 : 3 ] ) + offset_mins
 if tzinfo [ 0 ] == '-' :
                  offset = - offset
  tzinfo = get_fixed_timezone ( offset )
  kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
 kw [ 'tzinfo' ] = tzinfo
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  kw is a list with 3 elements: d.year, d.month and d.day.
  if d is an instance of real_datetime class,
  extend list kw with a list with 5 elements: d.hour, d.minute, d.second, d.microsecond and d.tzinfo.
<annotation_end_b>#<body_start> kw = [ d . year , d . month , d . day ]
 if isinstance ( d , real_datetime ) :
          kw . extend ( [ d . hour , d . minute , d . second , d . microsecond , d . tzinfo ] )
<body_end><annotation_start_b>  sites is an empty list.
  i is integer 0.
  endless loop,
  call the method text.find with 2 arguments: substr and i, substitute the result for j.
  if j equals to integer -1,
  break from the loop execution.
  append j to sites.
  add j and integer 1, substitute the result for i.
<annotation_end_b>#<body_start>       sites = [ ]
 i = 0
 while 1 :
          j = text . find ( substr , i )
 if j == - 1 :
              break
  sites . append ( j )
 i = j + 1
<body_end><annotation_start_b>  if dt.year is greater than or equal to integer 1900,
<annotation_end_b>#<body_start>      if dt . year >= 1900 :
<body_end><annotation_start_b>  call the method __new__ with an argument cls from the base class of the klass function.
  obj._constructor_args is a tuple with 2 elements: args and kwargs.
<annotation_end_b>#<body_start>               obj = super ( klass , cls ) . __new__ ( cls )
 obj . _constructor_args = ( args , kwargs )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  call the method __new__ with an argument cls from the base class of the klass function.
  obj._constructor_args is a tuple with 2 elements: args and kwargs.
  return obj.
  define the function deconstruct with an argument obj.
  return a tuple with 3 elements: if path is true, path, in not, a string '%s.%s' formated with obj.__class__.__module__,
  and obj.__class__.__name__, first element of obj._constructor_args and second element of obj._constructor_args.   klass.__new__ is a static method of the function __new__.
  substitute deconstruct for klass.deconstruct.
<annotation_end_b>#<body_start>          def __new__ ( cls , * args , ** kwargs ) :
               obj = super ( klass , cls ) . __new__ ( cls )
 obj . _constructor_args = ( args , kwargs )
 return obj
   def deconstruct ( obj ) :
 return (  path or '%s.%s' % ( obj . __class__ . __module__ , obj . __class__ . __name__ ) ,  obj . _constructor_args [ 0 ] ,  obj . _constructor_args [ 1 ] ,  )
   klass . __new__ = staticmethod ( __new__ )
 klass . deconstruct = deconstruct
<body_end><annotation_start_b>  remove elements under the 'path' key of the kwargs dictionary, if it exists substitute it for path, if not path is None.
  define the function decorator with an argument klass.
  define the method __new__ with 3 arguments: cls, unpacked list args and unpacked dictionary kwargs.
  call the method __new__ with an argument cls from the base class of the klass function.
  obj._constructor_args is a tuple with 2 elements: args and kwargs.
  return obj.
  define the function deconstruct with an argument obj.
  return a tuple with 3 elements: if path is true, path, in not, a string '%s.%s' formated with obj.__class__.__module__,
  and obj.__class__.__name__, first element of obj._constructor_args and second element of obj._constructor_args.   klass.__new__ is a static method of the function __new__.
  substitute deconstruct for klass.deconstruct.
  return klass.
  if args is true,
<annotation_end_b>#<body_start> path = kwargs . pop ( 'path' , None )
  def decorator ( klass ) :
          def __new__ ( cls , * args , ** kwargs ) :
               obj = super ( klass , cls ) . __new__ ( cls )
 obj . _constructor_args = ( args , kwargs )
 return obj
   def deconstruct ( obj ) :
 return (  path or '%s.%s' % ( obj . __class__ . __module__ , obj . __class__ . __name__ ) ,  obj . _constructor_args [ 0 ] ,  obj . _constructor_args [ 1 ] ,  )
   klass . __new__ = staticmethod ( __new__ )
 klass . deconstruct = deconstruct
  return klass
   if not args :
<body_end><annotation_start_b>  if instance is not None,
  raise an AttributeError exception with an argument string "This method is available only on the view class.".
<annotation_end_b>#<body_start>          if instance is not None :
              raise AttributeError ( "This method is available only on the view class." )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  decorator decorator.
  define the function bound_func with 2 arguments: unpacked list args2 and unpacked dictionary kwargs2.
  call the method func.__get__ with 2 arguments: self and type of self object, call the result with 2 arguments:
<annotation_end_b>#<body_start>              @ decorator
 def bound_func ( * args2 , ** kwargs2 ) :
                  return func . __get__ ( self , type ( self ) ) ( * args2 , ** kwargs2 )
<body_end><annotation_start_b>  do nothing.
  call the function update_wrapper with 2 arguments: _wrapper and dummy.
  call the function update_wrapper with 2 arguments: _wrapper and func.
<annotation_end_b>#<body_start>              pass
  update_wrapper ( _wrapper , dummy )
  update_wrapper ( _wrapper , func )
<body_end><annotation_start_b>  define the method _wrapper with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  decorator decorator.
  define the function bound_func with 2 arguments: unpacked list args2 and unpacked dictionary kwargs2.
  call the method func.__get__ with 2 arguments: self and type of self object, call the result with 2 arguments:
  unpacked list args2 and unpacked dictionary kwargs2, return the result.   call the function bound_func with 2 arguments: unpacked list args and unpacked dictionary kwargs, return the result.
  decorator decorator.
  define the function dummy with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  do nothing.
  call the function update_wrapper with 2 arguments: _wrapper and dummy.
  call the function update_wrapper with 2 arguments: _wrapper and func.
  return _wrapper.
  call the function update_wrapper with 3 arguments: _dec, decorator and assigned as result of the function available_attrs,
  called with an argument decorator.   if decorator has an attribute 'process_view',
  _dec.__name__ is a string 'method_decorator(%s)' formated with decorator.__name__.
  if not,
  _dec.__name__ is a string 'method_decorator(%s)' formated with decorator.__class__.__name__.
<annotation_end_b>#<body_start>          def _wrapper ( self , * args , ** kwargs ) :
              @ decorator
 def bound_func ( * args2 , ** kwargs2 ) :
                  return func . __get__ ( self , type ( self ) ) ( * args2 , ** kwargs2 )
     return bound_func ( * args , ** kwargs )
      @ decorator
 def dummy ( * args , ** kwargs ) :
              pass
  update_wrapper ( _wrapper , dummy )
  update_wrapper ( _wrapper , func )
  return _wrapper
   update_wrapper ( _dec , decorator , assigned = available_attrs ( decorator ) )
  if hasattr ( decorator , '__name__' ) :
          _dec . __name__ = 'method_decorator(%s)' % decorator . __name__
  else :
          _dec . __name__ = 'method_decorator(%s)' % decorator . __class__ . __name__
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if six.PY3 is true,
<annotation_end_b>#<body_start> if six . PY3 :
<body_end><annotation_start_b>  define the function _dec with an argument func.
  define the method _wrapper with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  decorator decorator.
  define the function bound_func with 2 arguments: unpacked list args2 and unpacked dictionary kwargs2.
  call the method func.__get__ with 2 arguments: self and type of self object, call the result with 2 arguments:
  unpacked list args2 and unpacked dictionary kwargs2, return the result.   call the function bound_func with 2 arguments: unpacked list args and unpacked dictionary kwargs, return the result.
  decorator decorator.
  define the function dummy with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  do nothing.
  call the function update_wrapper with 2 arguments: _wrapper and dummy.
  call the function update_wrapper with 2 arguments: _wrapper and func.
  return _wrapper.
  call the function update_wrapper with 3 arguments: _dec, decorator and assigned as result of the function available_attrs,
  called with an argument decorator.   if decorator has an attribute 'process_view',
  _dec.__name__ is a string 'method_decorator(%s)' formated with decorator.__name__.
  if not,
  _dec.__name__ is a string 'method_decorator(%s)' formated with decorator.__class__.__name__.
  return _dec.
  define the function decorator_from_middleware_with_args with an argument middleware_class.
  call the function make_middleware_decorator with an argument middleware_class, return the result.
  define the function decorator_from_middleware with an argument middleware_class.
  call the function make_middleware_decorator with an argument middleware_class, call the result, return the new result.
  define the function available_attrs with an argument fn.
  if six.PY3 is true,
  return WRAPPER_ASSIGNMENTS.
  if not,
<annotation_end_b>#<body_start>   def _dec ( func ) :
          def _wrapper ( self , * args , ** kwargs ) :
              @ decorator
 def bound_func ( * args2 , ** kwargs2 ) :
                  return func . __get__ ( self , type ( self ) ) ( * args2 , ** kwargs2 )
     return bound_func ( * args , ** kwargs )
      @ decorator
 def dummy ( * args , ** kwargs ) :
              pass
  update_wrapper ( _wrapper , dummy )
  update_wrapper ( _wrapper , func )
  return _wrapper
   update_wrapper ( _dec , decorator , assigned = available_attrs ( decorator ) )
  if hasattr ( decorator , '__name__' ) :
          _dec . __name__ = 'method_decorator(%s)' % decorator . __name__
  else :
          _dec . __name__ = 'method_decorator(%s)' % decorator . __class__ . __name__
  return _dec
    def decorator_from_middleware_with_args ( middleware_class ) :
 return make_middleware_decorator ( middleware_class )
    def decorator_from_middleware ( middleware_class ) :
 return make_middleware_decorator ( middleware_class ) ( )
    def available_attrs ( fn ) :
 if six . PY3 :
          return WRAPPER_ASSIGNMENTS
  else :
<body_end><annotation_start_b>  if middleware has an attribute 'process_request',
  call the method middleware.process_request with an argument request, substitute the result for result.
  if result is not None,
<annotation_end_b>#<body_start>                  if hasattr ( middleware , 'process_request' ) :
                      result = middleware . process_request ( request )
 if result is not None :
<body_end><annotation_start_b>  decorator function wraps with 2 arguments: view_func and assigned set to result of the function available_attrs,
  called with an argument view_func.   define the function _wrapped_view with 3 arguments: request, unpacked list args and unpacked dictionary kwargs.
  if middleware has an attribute 'process_request',
  call the method middleware.process_request with an argument request, substitute the result for result.
  if result is not None,
  return result.
  if middleware has an attribute 'process_view',
  call the method middleware.process_view with 4 arguments: request, view_func, args and kwargs, substitute the result for result.
  if result is not None,
<annotation_end_b>#<body_start>              @ wraps ( view_func , assigned = available_attrs ( view_func ) )
 def _wrapped_view ( request , * args , ** kwargs ) :
                  if hasattr ( middleware , 'process_request' ) :
                      result = middleware . process_request ( request )
 if result is not None :
                          return result
   if hasattr ( middleware , 'process_view' ) :
                      result = middleware . process_view ( request , view_func , args , kwargs )
 if result is not None :
<body_end><annotation_start_b>  call the function middleware_class with 2 arguments: unpacked list m_args and unpacked dictionary m_kwargs,
  substitute the middleware.   define the function _decorator with an argument view_func.
  decorator function wraps with 2 arguments: view_func and assigned set to result of the function available_attrs,
  called with an argument view_func.   define the function _wrapped_view with 3 arguments: request, unpacked list args and unpacked dictionary kwargs.
  if middleware has an attribute 'process_request',
  call the method middleware.process_request with an argument request, substitute the result for result.
  if result is not None,
  return result.
  if middleware has an attribute 'process_view',
  call the method middleware.process_view with 4 arguments: request, view_func, args and kwargs, substitute the result for result.
  if result is not None,
  return result.
  try,
  call the function view_func with 3 arguments: request, unpacked list args, unpacked dictionary kwargs, substitute the result for response.
  if Exception, renamed to e, exception is caught,
   if middleware has an attribute 'process_exception',
  call the method middleware.process_exception with 2 arguments: request and e, substitute the result for result.
  if result is not None,
<annotation_end_b>#<body_start>          middleware = middleware_class ( * m_args , ** m_kwargs )
  def _decorator ( view_func ) :
              @ wraps ( view_func , assigned = available_attrs ( view_func ) )
 def _wrapped_view ( request , * args , ** kwargs ) :
                  if hasattr ( middleware , 'process_request' ) :
                      result = middleware . process_request ( request )
 if result is not None :
                          return result
   if hasattr ( middleware , 'process_view' ) :
                      result = middleware . process_view ( request , view_func , args , kwargs )
 if result is not None :
                          return result
   try :
                      response = view_func ( request , * args , ** kwargs )
  except Exception as e :
                      if hasattr ( middleware , 'process_exception' ) :
                          result = middleware . process_exception ( request , e )
 if result is not None :
<body_end><annotation_start_b>  define the function make_decorator with 2 arguments: unpacked list m_args and unpacked dictionary m_kwargs.
  call the function middleware_class with 2 arguments: unpacked list m_args and unpacked dictionary m_kwargs,
  substitute the middleware.   define the function _decorator with an argument view_func.
  decorator function wraps with 2 arguments: view_func and assigned set to result of the function available_attrs,
  called with an argument view_func.   define the function _wrapped_view with 3 arguments: request, unpacked list args and unpacked dictionary kwargs.
  if middleware has an attribute 'process_request',
  call the method middleware.process_request with an argument request, substitute the result for result.
  if result is not None,
  return result.
  if middleware has an attribute 'process_view',
  call the method middleware.process_view with 4 arguments: request, view_func, args and kwargs, substitute the result for result.
  if result is not None,
  return result.
  try,
  call the function view_func with 3 arguments: request, unpacked list args, unpacked dictionary kwargs, substitute the result for response.
  if Exception, renamed to e, exception is caught,
   if middleware has an attribute 'process_exception',
  call the method middleware.process_exception with 2 arguments: request and e, substitute the result for result.
  if result is not None,
  return result,
  raise an exception.
  if response has an attribute 'render' and response.render is a callable object,
  if middleware has an attribute 'process_response',
  call the method middleware.process_template_response with 2 arguments: request and response, substitute the result for response.
  if middleware has an attribute 'process_response',
  callback is an lambda function with an argument response and with return value result of the method middleware.process_response,
  called with 2 arguments: request and response.   call the method response.add_post_render_callback with an argument callback.
  if not,
  if middleware has an attribute 'process_response',
<annotation_end_b>#<body_start>      def _make_decorator ( * m_args , ** m_kwargs ) :
          middleware = middleware_class ( * m_args , ** m_kwargs )
  def _decorator ( view_func ) :
              @ wraps ( view_func , assigned = available_attrs ( view_func ) )
 def _wrapped_view ( request , * args , ** kwargs ) :
                  if hasattr ( middleware , 'process_request' ) :
                      result = middleware . process_request ( request )
 if result is not None :
                          return result
   if hasattr ( middleware , 'process_view' ) :
                      result = middleware . process_view ( request , view_func , args , kwargs )
 if result is not None :
                          return result
   try :
                      response = view_func ( request , * args , ** kwargs )
  except Exception as e :
                      if hasattr ( middleware , 'process_exception' ) :
                          result = middleware . process_exception ( request , e )
 if result is not None :
                              return result
   raise
  if hasattr ( response , 'render' ) and callable ( response . render ) :
                      if hasattr ( middleware , 'process_template_response' ) :
                          response = middleware . process_template_response ( request , response )
    if hasattr ( middleware , 'process_response' ) :
                          callback = lambda response : middleware . process_response ( request , response )
 response . add_post_render_callback ( callback )
   else :
                      if hasattr ( middleware , 'process_response' ) :
<body_end><annotation_start_b>  call the function warnings.warn with 3 arguments: string "`%s.%s` is deprecated, use `%s` instead.",
<annotation_end_b>#<body_start>              warnings . warn (  "`%s.%s` is deprecated, use `%s` instead." %  ( self . class_name , self . old_method_name , self . new_method_name ) ,  self . deprecation_warning , 2 )
<body_end><annotation_start_b>  define the function wrapped with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  call the function warnings.warn with 3 arguments: string "`%s.%s` is deprecated, use `%s` instead.",
  formated with 3 elements: self.class_name, self.old_method_name and self.new_method_name, self.deprecation_warning and integer 2.   call the function f with a arguments: unpacked list args and unpacked dictionary kwargs, return the result.
<annotation_end_b>#<body_start>          def wrapped ( * args , ** kwargs ) :
              warnings . warn (  "`%s.%s` is deprecated, use `%s` instead." %  ( self . class_name , self . old_method_name , self . new_method_name ) ,  self . deprecation_warning , 2 )
 return f ( * args , ** kwargs )
<body_end><annotation_start_b>  call the method __new__ with 4 arguments: cls, name, bases and attrs, from the base class of the class RenameMethodsBase.
  call the method inspect.getmro with an argument new_class, for every base in the result,
  substitute base.__name__ for class_name.
  for every renamed_method in cls.renamed_methods,
  substitute first element of renamed_method for old_method_name.
  get the value under the old_method_name key of the base.__dict__ dictionary, substitute it for old_method.
  substitute second element of renamed_method for new_method_name.
  get the value under the new_method_name key of the base.__dict__ dictionary, substitute it for new_method.
  substitute third element of renamed_method for deprecation_warning.
  call the function warn_about_renamed_method with 2 arguments: class_name and unpacked list renamed_method, substitute the result for wrapper.
  if new_method is false and old_method is true,
  call the function warnings.warn with 3 arguments: string "`%s.%s` method should be renamed `%s`.",
  formated with 3 elements: class_name, old_method_name and new_method_name, deprecation_warning and integer 2.   set new_method_name attribute of the base object to old_method.
  set old_method_name attribute of the base object to the result of the function wrapper called with an argument old_method.
  if old_method is false and new_method is true,
  set old_method_name attribute of the base object to the result of the function wrapper called with an argument new_method.
<annotation_end_b>#<body_start>          new_class = super ( RenameMethodsBase , cls ) . __new__ ( cls , name , bases , attrs )
  for base in inspect . getmro ( new_class ) :
              class_name = base . __name__
 for renamed_method in cls . renamed_methods :
                  old_method_name = renamed_method [ 0 ]
 old_method = base . __dict__ . get ( old_method_name )
 new_method_name = renamed_method [ 1 ]
 new_method = base . __dict__ . get ( new_method_name )
 deprecation_warning = renamed_method [ 2 ]
 wrapper = warn_about_renamed_method ( class_name , * renamed_method )
   if not new_method and old_method :
                      warnings . warn (  "`%s.%s` method should be renamed `%s`." %  ( class_name , old_method_name , new_method_name ) ,  deprecation_warning , 2 )
 setattr ( base , new_method_name , old_method )
 setattr ( base , old_method_name , wrapper ( old_method ) )
    if not old_method and new_method :
                      setattr ( base , old_method_name , wrapper ( new_method ) )
<body_end><annotation_start_b>  match string s with regex IDENTIFIER, substitute the result for m.
  if m is false,
  raise an ValueError exception with an argument string 'Not a valid Python identifier: %r' formated with s.
<annotation_end_b>#<body_start>      m = IDENTIFIER . match ( s )
 if not m :
          raise ValueError ( 'Not a valid Python identifier: %r' % s )
<body_end><annotation_start_b>  if level is an instance of int type,
  substitute level for rv.
  otherwise if level converted into a string equals level,
  if level is not contained in logging._levelNames,
  raise an ValueError exception with an argument string 'Unknown level: %r' formated with level.
  substitute value under level key of logging._levelNames dictionary for rv.
  if not,
  raise an TypeError exception with an argument string 'Level not an integer or a valid string: %r' formated with level.
<annotation_end_b>#<body_start>          if isinstance ( level , int ) :
              rv = level
  elif str ( level ) == level :
              if level not in logging . _levelNames :
                  raise ValueError ( 'Unknown level: %r' % level )
  rv = logging . _levelNames [ level ]
  else :
              raise TypeError ( 'Level not an integer or a '  'valid string: %r' % level )
<body_end><annotation_start_b>  call the method dict.__getitem__ with 2 arguments self and key, substitute the result for value.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  substitute result for self dictionary under key key.
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
<annotation_end_b>#<body_start>          value = dict . __getitem__ ( self , key )
 result = self . configurator . convert ( value )
  if value is not result :
              self [ key ] = result
 if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
<body_end><annotation_start_b>  get value under key key of self dictionary, if it doesnt exists return default, substitute the result for value.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  substitute result for value under key key of self dictionary.
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
<annotation_end_b>#<body_start>          value = dict . get ( self , key , default )
 result = self . configurator . convert ( value )
  if value is not result :
              self [ key ] = result
 if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
<body_end><annotation_start_b>  remove value under key key of self dictionary, if it doesnt exists return default, substitute the result for value.
  call the method self.configurator.convert with an argument value.
  if value is not contained in result,
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
<annotation_end_b>#<body_start>          value = dict . pop ( self , key , default )
 result = self . configurator . convert ( value )
 if value is not result :
              if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
<body_end><annotation_start_b>  call the method list.__getitem__ with 2 arguments self and key, substitute the result for value.
  call the method self.configurator.convert with an arugment value, substitute the result for result.
  if value is not contained in result,
  substitute result for value under key key of self dictionary.
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
<annotation_end_b>#<body_start>          value = list . __getitem__ ( self , key )
 result = self . configurator . convert ( value )
  if value is not result :
              self [ key ] = result
 if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
<body_end><annotation_start_b>  remove idx-th element from self list.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
<annotation_end_b>#<body_start>          value = list . pop ( self , idx )
 result = self . configurator . convert ( value )
 if value is not result :
              if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
<body_end><annotation_start_b>  call the method tuple.__getitem__ with 2 arguments: self and key, substitute the result for value.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
<annotation_end_b>#<body_start>          value = tuple . __getitem__ ( self , key )
 result = self . configurator . convert ( value )
 if value is not result :
              if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
<body_end><annotation_start_b>  split s into parts by '.', substitute the result for name.
  remove first element from name, substitute the result for used.
  try,
  call the method self.importer with an argument used, substitute the result for found.
  for every frag in name.
  append '.' to frag, append the result to used.
  try,
  get frag attribute from found object, substitute it for found.
  if AttributeError exception is caught,
  call the method self.importer with an argument used.
  get frag attribute from found object, substitute it for found.
<annotation_end_b>#<body_start> name = s . split ( '.' )
 used = name . pop ( 0 )
 try :
              found = self . importer ( used )
 for frag in name :
                  used += '.' + frag
 try :
                      found = getattr ( found , frag )
  except AttributeError :
                      self . importer ( used )
 found = getattr ( found , frag )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  substitute value for rest.
  match rest string with self.WORD_PATTERN regex, substitute the result for m.
  if m is None,
  raise an ValueError exception with an argument string "Unable to convert %r" formated with value.
  if not,
  call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
  call the method m.groups, use the first element of the result as key for obtaining value from self.config dictionary,
  substitute it for d.   while rest is true,
  match rest string with self.DOT_PATTERN regex, substitute the result for m.
  if m is true,
  call the method m.groups, use the first element of the result as key for obtaining value from d dictionary,
  if not,
  match rest string with self.INDEX_PATTERN regex, substitute the result for m.
  if m is true,
  call the method m.groups, substitute the first element of the result for idx.
  match rest string with self.DIGIT_PATTERN regex, if it evaluates to false,
  substitute value under idx key of dictionary d for d.
  if not,
  try,
  convert idx to an integer, substitute it or n.
  substitute value under n key of dictionary d for d.
  if TypeError exception is caught,
  substitute value under idx key of dictionary d for d.
  if m is true,
  call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
  if not,
  raise an ValueError exception with an argument string 'Unable to convert %r at %r' formated with value and rest.
<annotation_end_b>#<body_start> rest = value
 m = self . WORD_PATTERN . match ( rest )
 if m is None :
              raise ValueError ( "Unable to convert %r" % value )
  else :
              rest = rest [ m . end ( ) : ]
 d = self . config [ m . groups ( ) [ 0 ] ]
  while rest :
                  m = self . DOT_PATTERN . match ( rest )
 if m :
                      d = d [ m . groups ( ) [ 0 ] ]
  else :
                      m = self . INDEX_PATTERN . match ( rest )
 if m :
                          idx = m . groups ( ) [ 0 ]
 if not self . DIGIT_PATTERN . match ( idx ) :
                              d = d [ idx ]
  else :
                              try :
                                  n = int ( idx )
 d = d [ n ]
  except TypeError :
                                  d = d [ idx ]
     if m :
                      rest = rest [ m . end ( ) : ]
  else :
                      raise ValueError ( 'Unable to convert '  '%r at %r' % ( value , rest ) )
<body_end><annotation_start_b>  if vale is not an instance of ConvertingDict and value is an instance of dict type,
  value is an instance of ConvertingDict class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is not an instance of ConvertingList and value is an instance of list type,
  value is an instance of ConvertingList class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is not an instance of ConvertingTuple and value is an instance of tuple type,
  value is an instance of ConvertingTuple class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is an instance of value,
  match value string with regex self.CONVERT_PATTERN, substitute the result for m.
  if m is true,
  call the method m.groupdict, substitute the result for d.
  substitute value under the 'prefix' key of dictionary d, substitute it for prefix.
  remove self.value_converters dictionary element under prefix key, if it exists substitute it for converter, if not, converter is None.
  if converter is true,
  substitute value under the 'suffix' key of dictionary d, substitute it for suffix.
  get converter attribute from self object, substitute it for converter.
  call the function converter with an argument suffix, substitute the result for value.
<annotation_end_b>#<body_start> if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :
              value = ConvertingDict ( value )
 value . configurator = self
  elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :
              value = ConvertingList ( value )
 value . configurator = self
  elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :
              value = ConvertingTuple ( value )
 value . configurator = self
  elif isinstance ( value , six . string_types ) :
              m = self . CONVERT_PATTERN . match ( value )
 if m :
                  d = m . groupdict ( )
 prefix = d [ 'prefix' ]
 converter = self . value_converters . get ( prefix , None )
 if converter :
                      suffix = d [ 'suffix' ]
 converter = getattr ( self , converter )
 value = converter ( suffix )
<body_end><annotation_start_b>  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__' and types has an 'ClassType' attribute and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  remove config dictionary element under '.' key, if it exists substitute it for props, if not, props is None.
  kwargs is a dictionary with elements: config dictionary element under k key for k, for every k in result of function valid_ident,
  called with an argument k.   call the function c with an argument unpacked dictionary kwargs, substitute the result for result.
  if props is true,
  for every name and value in items of props dictionary,
  set result attribute name to value value.
<annotation_end_b>#<body_start> c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
              c = self . resolve ( c )
  props = config . pop ( '.' , None )
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 result = c ( ** kwargs )
 if props :
              for name , value in props . items ( ) :
                  setattr ( result , name , value )
<body_end><annotation_start_b>  if valu is an instance of list type,
  convery value into a tuple, substitute it for value.
<annotation_end_b>#<body_start> if isinstance ( value , list ) :
              value = tuple ( value )
<body_end><annotation_start_b>  if string '()' is contained in config,
  substitute config dictionary value under '()' key for factory.
  try,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if string "'format'" is not contained in e converted into a string,
  raise an exception.
  remove config dictionary entry under 'format' key, substitute it for value under 'fmt' key of config dictionary.
  substitute factory for value under '()' key of config dictionary.
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  get config dictionary element under 'format' key, if it exists substitute it for fmt, if not, fmt is None.
  get config dictionary element under 'datefmt' key, if it exists substitute it for dfmt, if not, dfmt is None.
  call the method logging.Formatter with 2 arguments: fmt and dfmt, substitute the result for result.
<annotation_end_b>#<body_start> if '()' in config :
              factory = config [ '()' ]
 try :
                  result = self . configure_custom ( config )
  except TypeError as te :
                  if "'format'" not in str ( te ) :
                      raise
      config [ 'fmt' ] = config . pop ( 'format' )
 config [ '()' ] = factory
 result = self . configure_custom ( config )
   else :
              fmt = config . get ( 'format' , None )
 dfmt = config . get ( 'datefmt' , None )
 result = logging . Formatter ( fmt , dfmt )
<body_end><annotation_start_b>  if string '()' is contained in config,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  remove config dictionary element under 'name' key, if it exists substitute it for name, if not, name is an empty string.
  call the method logging.Filter with an argument name, substitute the result for result.
<annotation_end_b>#<body_start> if '()' in config :
              result = self . configure_custom ( config )
  else :
              name = config . get ( 'name' , '' )
 result = logging . Filter ( name )
<body_end><annotation_start_b>  remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
  if formatter is true,
  try,
  get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
  remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
  if string '()' is contained in config,
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  substitute c for factory.
  if not,
  remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
  substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
  try,
  get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
  under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
  formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
  call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
  substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
  call the method self.as_tuple with an argument value under 'address' key of config dictionary,
  substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
  kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
  for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if "'stream'" is not contained in te converted into a string,
  raise an exception.
  remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if formatter is true,
  call the method result.setFormatter with an argument formatter.
  if level is not None,
  call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
  if filters is true,
  call the method self.add_filters with 2 arguments: result and filters.
<annotation_end_b>#<body_start> formatter = config . pop ( 'formatter' , None )
 if formatter :
              try :
                  formatter = self . config [ 'formatters' ] [ formatter ]
  except StandardError as e :
                  raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
   level = config . pop ( 'level' , None )
 filters = config . pop ( 'filters' , None )
 if '()' in config :
              c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
                  c = self . resolve ( c )
  factory = c
  else :
              klass = self . resolve ( config . pop ( 'class' ) )
  if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
                  try :
                      config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
  except StandardError as e :
                      raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
   elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
                  config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
  elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
                  config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
  factory = klass
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 try :
              result = factory ( ** kwargs )
  except TypeError as te :
              if "'stream'" not in str ( te ) :
                  raise
      kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
 result = factory ( ** kwargs )
  if formatter :
              result . setFormatter ( formatter )
  if level is not None :
              result . setLevel ( _checkLevel ( level ) )
  if filters :
              self . add_filters ( result , filters )
<body_end><annotation_start_b>  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
<annotation_end_b>#<body_start>          original = UnicodeDecodeError . __str__ ( self )
<body_end><annotation_start_b>  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
<annotation_end_b>#<body_start> if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
<body_end><annotation_start_b>  if s is instance of a class Promise,
<annotation_end_b>#<body_start> if isinstance ( s , Promise ) :
<body_end><annotation_start_b>  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
<annotation_end_b>#<body_start>          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if s is the instance of the object six.text_type,
<annotation_end_b>#<body_start>  if isinstance ( s , six . text_type ) :
<body_end><annotation_start_b>  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
<annotation_end_b>#<body_start> dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
<body_end><annotation_start_b>  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
<annotation_end_b>#<body_start> root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
<body_end><annotation_start_b>  if s is an instance of an object Promise.
<annotation_end_b>#<body_start> if isinstance ( s , Promise ) :
<body_end><annotation_start_b>  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
<annotation_end_b>#<body_start> logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
<body_end><annotation_start_b>  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
<annotation_end_b>#<body_start>  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
<body_end><annotation_start_b>  get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
  if level is not None,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
  if incremental is true,
  for every h in elements of logger.handlers list,
  call the method logger.removeHandler with an argument h.
  get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
  if handlers is true,
  call the method self.add_handlers with 2 arguments: logger and handlers.
  get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
  if filters is true,
  call the method self.add_filters with 2 arguments: logger and filters.
  define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
  evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
  define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
  return s.
  if not,
<annotation_end_b>#<body_start> level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
<body_end><annotation_start_b>  for every h in handlers,
  try,
  call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
  define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
  get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
  if level is not None,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
  if incremental is true,
  for every h in elements of logger.handlers list,
  call the method logger.removeHandler with an argument h.
  get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
  if handlers is true,
  call the method self.add_handlers with 2 arguments: logger and handlers.
  get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
  if filters is true,
  call the method self.add_filters with 2 arguments: logger and filters.
  define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
  evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
  define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
  return s.
  if not,
  evaluate the method s.decode with string 'utf-8' and errors as the arguments,
  on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
<annotation_end_b>#<body_start> for h in handlers :
              try :
                  logger . addHandler ( self . config [ 'handlers' ] [ h ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
     def common_logger_config ( self , logger , config , incremental = False ) :
 level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
              return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
   if strings_only and is_protected_type ( s ) :
<body_end><annotation_start_b>  for every f in filters,
  try,
  get the value under f key of dictionary under 'filters' key of self.config dictionary,
  use the result as an argument for the call to the method filterer.addFilter.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add filter %r: %s' formated with f and e.
  define the method configure_handler with 2 arguments: self and config.
  remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
  if formatter is true,
  try,
  get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
  remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
  if string '()' is contained in config,
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  substitute c for factory.
  if not,
  remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
  substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
  try,
  get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
  under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
  formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
  call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
  substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
  call the method self.as_tuple with an argument value under 'address' key of config dictionary,
  substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
  kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
  for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if "'stream'" is not contained in te converted into a string,
  raise an exception.
  remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if formatter is true,
  call the method result.setFormatter with an argument formatter.
  if level is not None,
  call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
  if filters is true,
  call the method self.add_filters with 2 arguments: result and filters.
  return result.
  define the method add_handlers with 3 arguments: self, logger and handlers.
  for every h in handlers,
  try,
  call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
  define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
  get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
  if level is not None,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
  if incremental is true,
  for every h in elements of logger.handlers list,
  call the method logger.removeHandler with an argument h.
  get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
  if handlers is true,
  call the method self.add_handlers with 2 arguments: logger and handlers.
  get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
  if filters is true,
  call the method self.add_filters with 2 arguments: logger and filters.
  define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
  evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
  define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
  return s.
  if not,
  evaluate the method s.decode with string 'utf-8' and errors as the arguments,
  on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
  return s.
  if s is an instance of an object six.memoryview.
<annotation_end_b>#<body_start> for f in filters :
              try :
                  filterer . addFilter ( self . config [ 'filters' ] [ f ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )
     def configure_handler ( self , config ) :
 formatter = config . pop ( 'formatter' , None )
 if formatter :
              try :
                  formatter = self . config [ 'formatters' ] [ formatter ]
  except StandardError as e :
                  raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
   level = config . pop ( 'level' , None )
 filters = config . pop ( 'filters' , None )
 if '()' in config :
              c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
                  c = self . resolve ( c )
  factory = c
  else :
              klass = self . resolve ( config . pop ( 'class' ) )
  if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
                  try :
                      config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
  except StandardError as e :
                      raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
   elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
                  config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
  elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
                  config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
  factory = klass
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 try :
              result = factory ( ** kwargs )
  except TypeError as te :
              if "'stream'" not in str ( te ) :
                  raise
      kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
 result = factory ( ** kwargs )
  if formatter :
              result . setFormatter ( formatter )
  if level is not None :
              result . setLevel ( _checkLevel ( level ) )
  if filters :
              self . add_filters ( result , filters )
  return result
   def add_handlers ( self , logger , handlers ) :
 for h in handlers :
              try :
                  logger . addHandler ( self . config [ 'handlers' ] [ h ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
     def common_logger_config ( self , logger , config , incremental = False ) :
 level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
              return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
   if strings_only and is_protected_type ( s ) :
          return s
  if isinstance ( s , six . memoryview ) :
<body_end><annotation_start_b>  substitute self.config for config.
  if string 'version' is not contained in config,
  raise an ValueError exception with an argument string "dictionary doesn't specify a version".
  if config dictionary value under 'version' key is not equal to integer 1,
  raise an ValueError exception with an argument string "Unsupported version: %s" formated with value under 'version' key of config dictionary.
  get config dictionary element under 'incremental' key, if it exists substitute it for incremental, if not,
  incremental is boolean False.   EMPTY_DICT is an empty dictionary.
  call the method logging._acquireLock.
  try,
  if incremental is true,
  get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
  if first two elements of sys.version_info equal to integers 2 ant 7, respectively,
  for every name in handlers,
  if name is not contained in logging._handlers,
  raise an ValueError exception with an argument string 'No handler found with name %r' formated with name.
  if not,
  try,
  substitute value under name key of logging._handlers dictionary for handler.
  substitute value under name key of handlers dictionary for handler_config.
  get handler_config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  if level is true,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the function handler.setLevel.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
  get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
  for every name in loggers,
  try,
  call the method self.configure_logger with 3 arguments: name, value under name key of loggers dictionary and boolean True.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
  get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
  if root is true,
  try,
  call the method self.configure_root with 2 arguments: root and boolean True.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure root logger: %s' formated with e.
  if not,
  remove config dictionary element under 'disable_existing_loggers' key, if it exists substitute it for disable_existing, if not,
  disable_existing is boolean True.   call the method logging._handler.clear.
  delete logging._handlerList list.
  get config dictionary element under 'formatters' key, if it exists substitute it for formatters, if not, formatters is EMPTY_DICT.
  for every name in formatters,
  try,
  call the method self.configure_filter with an argument value under name key of formatters dictionary,
  substitute the result for formatters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure formatter %r: %s' formated with name and e.
  get config dictionary element under 'filters' key, if it exists substitute it for filters, if not, filters is EMPTY_DICT.
  for every name in filters,
  try,
  call the method self.configure_filter with an argument value under name key of filters dictionary,
  substitute the result for filters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure filter %r: %s' formated with name and e.
  get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
  sort elements of handlers, for every name in result,
  try,
  call the method self.configure_handler with an argument value under name key of handlers dictionary, substitute the result for handler.
  substitute name for handler.name.
  substitute handler for value under name key of handlers dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
  substitute logging.root for root.
  convert root.manager.loggerDict into a list, substitute it for existing.
  sort elements of list existing.
  child_loggers is an empty list.
  get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
  for every name in loggers,
  if name is contained in existing,
  get the index of first occurrence of name in existing, substitute it for i.
  append '.' to name, substitute the result for prefixed.
  substitute length of prefixed for pflen.
  substitute length of existing for num_existing.
  increment i by integer 1, substitute the result for i.
  while i is lesser than num_existing and first pflen elements of i-th element of existing equals prefixed,
  append i-th element of existing to child_loggers.
  increment i by integer 1, substitute the result for i.
  remove name from existing.
  try,
  call the method self.configure_logger with 2 arguments: name and value under loggers dictionary key name.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
  for every log in existing,
  get the value under log key of root.manager.loggerDict dictionary, substitute it for logger.
  if log is contained in child_loggers,
  substitute logging.NOTSET for logger.level.
  logger.handlers is an empty list.
  logger.propagate is boolean True.
  otherwise if disable_existing is true,
  logger.disabled is boolean True.
  get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
  if root is true,
  try,
  call the method self.configure_root with an argument root.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string ''Unable to configure root logger: %s' formated with e.
  finally perform,
  call the method logging._releaseLock.
  define the method configure_formatter with 2 arguments: self and config.
  if string '()' is contained in config,
  substitute config dictionary value under '()' key for factory.
  try,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if string "'format'" is not contained in e converted into a string,
  raise an exception.
  remove config dictionary entry under 'format' key, substitute it for value under 'fmt' key of config dictionary.
  substitute factory for value under '()' key of config dictionary.
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  get config dictionary element under 'format' key, if it exists substitute it for fmt, if not, fmt is None.
  get config dictionary element under 'datefmt' key, if it exists substitute it for dfmt, if not, dfmt is None.
  call the method logging.Formatter with 2 arguments: fmt and dfmt, substitute the result for result.
  return result.
  define the method configure_filter with 2 arguments: self and config.
  if string '()' is contained in config,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  remove config dictionary element under 'name' key, if it exists substitute it for name, if not, name is an empty string.
  call the method logging.Filter with an argument name, substitute the result for result.
  return result.
  define the method add_filters with 3 arguments: self, filterer and filters.
  for every f in filters,
  try,
  get the value under f key of dictionary under 'filters' key of self.config dictionary,
  use the result as an argument for the call to the method filterer.addFilter.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add filter %r: %s' formated with f and e.
  define the method configure_handler with 2 arguments: self and config.
  remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
  if formatter is true,
  try,
  get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
  remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
  if string '()' is contained in config,
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  substitute c for factory.
  if not,
  remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
  substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
  try,
  get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
  under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
  formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
  call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
  substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
  call the method self.as_tuple with an argument value under 'address' key of config dictionary,
  substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
  kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
  for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if "'stream'" is not contained in te converted into a string,
  raise an exception.
  remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if formatter is true,
  call the method result.setFormatter with an argument formatter.
  if level is not None,
  call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
  if filters is true,
  call the method self.add_filters with 2 arguments: result and filters.
  return result.
  define the method add_handlers with 3 arguments: self, logger and handlers.
  for every h in handlers,
  try,
  call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
  define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
  get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
  if level is not None,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
  if incremental is true,
  for every h in elements of logger.handlers list,
  call the method logger.removeHandler with an argument h.
  get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
  if handlers is true,
  call the method self.add_handlers with 2 arguments: logger and handlers.
  get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
  if filters is true,
  call the method self.add_filters with 2 arguments: logger and filters.
  define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
  evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
  define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
  return s.
  if not,
  evaluate the method s.decode with string 'utf-8' and errors as the arguments,
  on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
  return s.
  if s is an instance of an object six.memoryview.
  evaluate the function bytes with the argument s, and return the result.
  if s is an instance of an object Promise.
<annotation_end_b>#<body_start>  config = self . config
 if 'version' not in config :
              raise ValueError ( "dictionary doesn't specify a version" )
  if config [ 'version' ] != 1 :
              raise ValueError ( "Unsupported version: %s" % config [ 'version' ] )
  incremental = config . pop ( 'incremental' , False )
 EMPTY_DICT = { }
 logging . _acquireLock ( )
 try :
              if incremental :
                  handlers = config . get ( 'handlers' , EMPTY_DICT )
   if sys . version_info [ : 2 ] == ( 2 , 7 ) :
                      for name in handlers :
                          if name not in logging . _handlers :
                              raise ValueError ( 'No handler found with '  'name %r' % name )
  else :
                              try :
                                  handler = logging . _handlers [ name ]
 handler_config = handlers [ name ]
 level = handler_config . get ( 'level' , None )
 if level :
                                      handler . setLevel ( _checkLevel ( level ) )
   except StandardError as e :
                                  raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
     loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      try :
                          self . configure_logger ( name , loggers [ name ] , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
   root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
    else :
                  disable_existing = config . pop ( 'disable_existing_loggers' , True )
  logging . _handlers . clear ( )
 del logging . _handlerList [ : ]
   formatters = config . get ( 'formatters' , EMPTY_DICT )
 for name in formatters :
                      try :
                          formatters [ name ] = self . configure_formatter (  formatters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )
    filters = config . get ( 'filters' , EMPTY_DICT )
 for name in filters :
                      try :
                          filters [ name ] = self . configure_filter ( filters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )
       handlers = config . get ( 'handlers' , EMPTY_DICT )
 for name in sorted ( handlers ) :
                      try :
                          handler = self . configure_handler ( handlers [ name ] )
 handler . name = name
 handlers [ name ] = handler
  except StandardError as e :
                          raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
             root = logging . root
 existing = list ( root . manager . loggerDict )
     existing . sort ( )
   child_loggers = [ ]
  loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      if name in existing :
                          i = existing . index ( name )
 prefixed = name + "."
 pflen = len ( prefixed )
 num_existing = len ( existing )
 i = i + 1
 while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :
                              child_loggers . append ( existing [ i ] )
 i = i + 1
  existing . remove ( name )
  try :
                          self . configure_logger ( name , loggers [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
         for log in existing :
                      logger = root . manager . loggerDict [ log ]
 if log in child_loggers :
                          logger . level = logging . NOTSET
 logger . handlers = [ ]
 logger . propagate = True
  elif disable_existing :
                          logger . disabled = True
     root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
     finally :
              logging . _releaseLock ( )
    def configure_formatter ( self , config ) :
 if '()' in config :
              factory = config [ '()' ]
 try :
                  result = self . configure_custom ( config )
  except TypeError as te :
                  if "'format'" not in str ( te ) :
                      raise
      config [ 'fmt' ] = config . pop ( 'format' )
 config [ '()' ] = factory
 result = self . configure_custom ( config )
   else :
              fmt = config . get ( 'format' , None )
 dfmt = config . get ( 'datefmt' , None )
 result = logging . Formatter ( fmt , dfmt )
  return result
   def configure_filter ( self , config ) :
 if '()' in config :
              result = self . configure_custom ( config )
  else :
              name = config . get ( 'name' , '' )
 result = logging . Filter ( name )
  return result
   def add_filters ( self , filterer , filters ) :
 for f in filters :
              try :
                  filterer . addFilter ( self . config [ 'filters' ] [ f ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )
     def configure_handler ( self , config ) :
 formatter = config . pop ( 'formatter' , None )
 if formatter :
              try :
                  formatter = self . config [ 'formatters' ] [ formatter ]
  except StandardError as e :
                  raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
   level = config . pop ( 'level' , None )
 filters = config . pop ( 'filters' , None )
 if '()' in config :
              c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
                  c = self . resolve ( c )
  factory = c
  else :
              klass = self . resolve ( config . pop ( 'class' ) )
  if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
                  try :
                      config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
  except StandardError as e :
                      raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
   elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
                  config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
  elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
                  config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
  factory = klass
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 try :
              result = factory ( ** kwargs )
  except TypeError as te :
              if "'stream'" not in str ( te ) :
                  raise
      kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
 result = factory ( ** kwargs )
  if formatter :
              result . setFormatter ( formatter )
  if level is not None :
              result . setLevel ( _checkLevel ( level ) )
  if filters :
              self . add_filters ( result , filters )
  return result
   def add_handlers ( self , logger , handlers ) :
 for h in handlers :
              try :
                  logger . addHandler ( self . config [ 'handlers' ] [ h ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
     def common_logger_config ( self , logger , config , incremental = False ) :
 level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
              return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
   if strings_only and is_protected_type ( s ) :
          return s
  if isinstance ( s , six . memoryview ) :
          return bytes ( s )
  if isinstance ( s , Promise ) :
<body_end><annotation_start_b>  self.config is an instance of ConvertingDict, called with an argument config.
  substitute self for self.config.configurator.
  define the method resolve with 2 arguments: self and s.
  split s into parts by '.', substitute the result for name.
  remove first element from name, substitute the result for used.
  try,
  call the method self.importer with an argument used, substitute the result for found.
  for every frag in name.
  append '.' to frag, append the result to used.
  try,
  get frag attribute from found object, substitute it for found.
  if AttributeError exception is caught,
  call the method self.importer with an argument used.
  get frag attribute from found object, substitute it for found.
  return found.
  if ImportError exception is caught,
  call the method sys.exc_info, substitute the result without the first element for e and tb.
  raise an ValueError exception with an argument string 'Cannot resolve %r: %s', formated with s and e.
  substitute e and tb for v.__cause__ and v.__traceback__.
  raise an v exception.
  define the method ext_convert with 2 arguments: self and value.
  call the method self.resolve with an argument value, return the result.
  define the method cfg_convert with 2 arguments: self and value.
  substitute value for rest.
  match rest string with self.WORD_PATTERN regex, substitute the result for m.
  if m is None,
  raise an ValueError exception with an argument string "Unable to convert %r" formated with value.
  if not,
  call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
  call the method m.groups, use the first element of the result as key for obtaining value from self.config dictionary,
  substitute it for d.   while rest is true,
  match rest string with self.DOT_PATTERN regex, substitute the result for m.
  if m is true,
  call the method m.groups, use the first element of the result as key for obtaining value from d dictionary,
  if not,
  match rest string with self.INDEX_PATTERN regex, substitute the result for m.
  if m is true,
  call the method m.groups, substitute the first element of the result for idx.
  match rest string with self.DIGIT_PATTERN regex, if it evaluates to false,
  substitute value under idx key of dictionary d for d.
  if not,
  try,
  convert idx to an integer, substitute it or n.
  substitute value under n key of dictionary d for d.
  if TypeError exception is caught,
  substitute value under idx key of dictionary d for d.
  if m is true,
  call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
  if not,
  raise an ValueError exception with an argument string 'Unable to convert %r at %r' formated with value and rest.
  return d.
  define the method convert with 2 arguments: self and value.
  if vale is not an instance of ConvertingDict and value is an instance of dict type,
  value is an instance of ConvertingDict class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is not an instance of ConvertingList and value is an instance of list type,
  value is an instance of ConvertingList class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is not an instance of ConvertingTuple and value is an instance of tuple type,
  value is an instance of ConvertingTuple class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is an instance of value,
  match value string with regex self.CONVERT_PATTERN, substitute the result for m.
  if m is true,
  call the method m.groupdict, substitute the result for d.
  substitute value under the 'prefix' key of dictionary d, substitute it for prefix.
  remove self.value_converters dictionary element under prefix key, if it exists substitute it for converter, if not, converter is None.
  if converter is true,
  substitute value under the 'suffix' key of dictionary d, substitute it for suffix.
  get converter attribute from self object, substitute it for converter.
  call the function converter with an argument suffix, substitute the result for value.
  return value.
  define the method configure_custom with 2 arguments: self and config.
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__' and types has an 'ClassType' attribute and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  remove config dictionary element under '.' key, if it exists substitute it for props, if not, props is None.
  kwargs is a dictionary with elements: config dictionary element under k key for k, for every k in result of function valid_ident,
  called with an argument k.   call the function c with an argument unpacked dictionary kwargs, substitute the result for result.
  if props is true,
  for every name and value in items of props dictionary,
  set result attribute name to value value.
  return result.
  define the method as_tuple with 2 arguments: self and value.
  if valu is an instance of list type,
  convery value into a tuple, substitute it for value.
  return value.
  derive the class DictConfigurator from the BaseConfigurator base class.
  define the method configure with an argument self.
  substitute self.config for config.
  if string 'version' is not contained in config,
  raise an ValueError exception with an argument string "dictionary doesn't specify a version".
  if config dictionary value under 'version' key is not equal to integer 1,
  raise an ValueError exception with an argument string "Unsupported version: %s" formated with value under 'version' key of config dictionary.
  get config dictionary element under 'incremental' key, if it exists substitute it for incremental, if not,
  incremental is boolean False.   EMPTY_DICT is an empty dictionary.
  call the method logging._acquireLock.
  try,
  if incremental is true,
  get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
  if first two elements of sys.version_info equal to integers 2 ant 7, respectively,
  for every name in handlers,
  if name is not contained in logging._handlers,
  raise an ValueError exception with an argument string 'No handler found with name %r' formated with name.
  if not,
  try,
  substitute value under name key of logging._handlers dictionary for handler.
  substitute value under name key of handlers dictionary for handler_config.
  get handler_config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  if level is true,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the function handler.setLevel.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
  get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
  for every name in loggers,
  try,
  call the method self.configure_logger with 3 arguments: name, value under name key of loggers dictionary and boolean True.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
  get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
  if root is true,
  try,
  call the method self.configure_root with 2 arguments: root and boolean True.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure root logger: %s' formated with e.
  if not,
  remove config dictionary element under 'disable_existing_loggers' key, if it exists substitute it for disable_existing, if not,
  disable_existing is boolean True.   call the method logging._handler.clear.
  delete logging._handlerList list.
  get config dictionary element under 'formatters' key, if it exists substitute it for formatters, if not, formatters is EMPTY_DICT.
  for every name in formatters,
  try,
  call the method self.configure_filter with an argument value under name key of formatters dictionary,
  substitute the result for formatters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure formatter %r: %s' formated with name and e.
  get config dictionary element under 'filters' key, if it exists substitute it for filters, if not, filters is EMPTY_DICT.
  for every name in filters,
  try,
  call the method self.configure_filter with an argument value under name key of filters dictionary,
  substitute the result for filters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure filter %r: %s' formated with name and e.
  get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
  sort elements of handlers, for every name in result,
  try,
  call the method self.configure_handler with an argument value under name key of handlers dictionary, substitute the result for handler.
  substitute name for handler.name.
  substitute handler for value under name key of handlers dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
  substitute logging.root for root.
  convert root.manager.loggerDict into a list, substitute it for existing.
  sort elements of list existing.
  child_loggers is an empty list.
  get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
  for every name in loggers,
  if name is contained in existing,
  get the index of first occurrence of name in existing, substitute it for i.
  append '.' to name, substitute the result for prefixed.
  substitute length of prefixed for pflen.
  substitute length of existing for num_existing.
  increment i by integer 1, substitute the result for i.
  while i is lesser than num_existing and first pflen elements of i-th element of existing equals prefixed,
  append i-th element of existing to child_loggers.
  increment i by integer 1, substitute the result for i.
  remove name from existing.
  try,
  call the method self.configure_logger with 2 arguments: name and value under loggers dictionary key name.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
  for every log in existing,
  get the value under log key of root.manager.loggerDict dictionary, substitute it for logger.
  if log is contained in child_loggers,
  substitute logging.NOTSET for logger.level.
  logger.handlers is an empty list.
  logger.propagate is boolean True.
  otherwise if disable_existing is true,
  logger.disabled is boolean True.
  get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
  if root is true,
  try,
  call the method self.configure_root with an argument root.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string ''Unable to configure root logger: %s' formated with e.
  finally perform,
  call the method logging._releaseLock.
  define the method configure_formatter with 2 arguments: self and config.
  if string '()' is contained in config,
  substitute config dictionary value under '()' key for factory.
  try,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if string "'format'" is not contained in e converted into a string,
  raise an exception.
  remove config dictionary entry under 'format' key, substitute it for value under 'fmt' key of config dictionary.
  substitute factory for value under '()' key of config dictionary.
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  get config dictionary element under 'format' key, if it exists substitute it for fmt, if not, fmt is None.
  get config dictionary element under 'datefmt' key, if it exists substitute it for dfmt, if not, dfmt is None.
  call the method logging.Formatter with 2 arguments: fmt and dfmt, substitute the result for result.
  return result.
  define the method configure_filter with 2 arguments: self and config.
  if string '()' is contained in config,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  remove config dictionary element under 'name' key, if it exists substitute it for name, if not, name is an empty string.
  call the method logging.Filter with an argument name, substitute the result for result.
  return result.
  define the method add_filters with 3 arguments: self, filterer and filters.
  for every f in filters,
  try,
  get the value under f key of dictionary under 'filters' key of self.config dictionary,
  use the result as an argument for the call to the method filterer.addFilter.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add filter %r: %s' formated with f and e.
  define the method configure_handler with 2 arguments: self and config.
  remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
  if formatter is true,
  try,
  get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
  remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
  if string '()' is contained in config,
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  substitute c for factory.
  if not,
  remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
  substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
  try,
  get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
  under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
  formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
  call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
  substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
  call the method self.as_tuple with an argument value under 'address' key of config dictionary,
  substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
  kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
  for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if "'stream'" is not contained in te converted into a string,
  raise an exception.
  remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if formatter is true,
  call the method result.setFormatter with an argument formatter.
  if level is not None,
  call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
  if filters is true,
  call the method self.add_filters with 2 arguments: result and filters.
  return result.
  define the method add_handlers with 3 arguments: self, logger and handlers.
  for every h in handlers,
  try,
  call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
  define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
  get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
  if level is not None,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
  if incremental is true,
  for every h in elements of logger.handlers list,
  call the method logger.removeHandler with an argument h.
  get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
  if handlers is true,
  call the method self.add_handlers with 2 arguments: logger and handlers.
  get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
  if filters is true,
  call the method self.add_filters with 2 arguments: logger and filters.
  define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
  evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
  define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
  return s.
  if not,
  evaluate the method s.decode with string 'utf-8' and errors as the arguments,
  on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
  return s.
  if s is an instance of an object six.memoryview.
  evaluate the function bytes with the argument s, and return the result.
  if s is an instance of an object Promise.
  return six.text_type(s).encode(encoding, errors).
  if s is not an instance of the object six.string_types,
  try,
  if PY3 field of six is boolean True,
<annotation_end_b>#<body_start>          self . config = ConvertingDict ( config )
 self . config . configurator = self
   def resolve ( self , s ) :
 name = s . split ( '.' )
 used = name . pop ( 0 )
 try :
              found = self . importer ( used )
 for frag in name :
                  used += '.' + frag
 try :
                      found = getattr ( found , frag )
  except AttributeError :
                      self . importer ( used )
 found = getattr ( found , frag )
   return found
  except ImportError :
              e , tb = sys . exc_info ( ) [ 1 : ]
 v = ValueError ( 'Cannot resolve %r: %s' % ( s , e ) )
 v . __cause__ , v . __traceback__ = e , tb
 raise v
    def ext_convert ( self , value ) :
 return self . resolve ( value )
   def cfg_convert ( self , value ) :
 rest = value
 m = self . WORD_PATTERN . match ( rest )
 if m is None :
              raise ValueError ( "Unable to convert %r" % value )
  else :
              rest = rest [ m . end ( ) : ]
 d = self . config [ m . groups ( ) [ 0 ] ]
  while rest :
                  m = self . DOT_PATTERN . match ( rest )
 if m :
                      d = d [ m . groups ( ) [ 0 ] ]
  else :
                      m = self . INDEX_PATTERN . match ( rest )
 if m :
                          idx = m . groups ( ) [ 0 ]
 if not self . DIGIT_PATTERN . match ( idx ) :
                              d = d [ idx ]
  else :
                              try :
                                  n = int ( idx )
 d = d [ n ]
  except TypeError :
                                  d = d [ idx ]
     if m :
                      rest = rest [ m . end ( ) : ]
  else :
                      raise ValueError ( 'Unable to convert '  '%r at %r' % ( value , rest ) )
     return d
   def convert ( self , value ) :
 if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :
              value = ConvertingDict ( value )
 value . configurator = self
  elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :
              value = ConvertingList ( value )
 value . configurator = self
  elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :
              value = ConvertingTuple ( value )
 value . configurator = self
  elif isinstance ( value , six . string_types ) :
              m = self . CONVERT_PATTERN . match ( value )
 if m :
                  d = m . groupdict ( )
 prefix = d [ 'prefix' ]
 converter = self . value_converters . get ( prefix , None )
 if converter :
                      suffix = d [ 'suffix' ]
 converter = getattr ( self , converter )
 value = converter ( suffix )
    return value
   def configure_custom ( self , config ) :
 c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
              c = self . resolve ( c )
  props = config . pop ( '.' , None )
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 result = c ( ** kwargs )
 if props :
              for name , value in props . items ( ) :
                  setattr ( result , name , value )
   return result
   def as_tuple ( self , value ) :
 if isinstance ( value , list ) :
              value = tuple ( value )
  return value
     class DictConfigurator ( BaseConfigurator ) :
  def configure ( self ) :
  config = self . config
 if 'version' not in config :
              raise ValueError ( "dictionary doesn't specify a version" )
  if config [ 'version' ] != 1 :
              raise ValueError ( "Unsupported version: %s" % config [ 'version' ] )
  incremental = config . pop ( 'incremental' , False )
 EMPTY_DICT = { }
 logging . _acquireLock ( )
 try :
              if incremental :
                  handlers = config . get ( 'handlers' , EMPTY_DICT )
   if sys . version_info [ : 2 ] == ( 2 , 7 ) :
                      for name in handlers :
                          if name not in logging . _handlers :
                              raise ValueError ( 'No handler found with '  'name %r' % name )
  else :
                              try :
                                  handler = logging . _handlers [ name ]
 handler_config = handlers [ name ]
 level = handler_config . get ( 'level' , None )
 if level :
                                      handler . setLevel ( _checkLevel ( level ) )
   except StandardError as e :
                                  raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
     loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      try :
                          self . configure_logger ( name , loggers [ name ] , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
   root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
    else :
                  disable_existing = config . pop ( 'disable_existing_loggers' , True )
  logging . _handlers . clear ( )
 del logging . _handlerList [ : ]
   formatters = config . get ( 'formatters' , EMPTY_DICT )
 for name in formatters :
                      try :
                          formatters [ name ] = self . configure_formatter (  formatters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )
    filters = config . get ( 'filters' , EMPTY_DICT )
 for name in filters :
                      try :
                          filters [ name ] = self . configure_filter ( filters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )
       handlers = config . get ( 'handlers' , EMPTY_DICT )
 for name in sorted ( handlers ) :
                      try :
                          handler = self . configure_handler ( handlers [ name ] )
 handler . name = name
 handlers [ name ] = handler
  except StandardError as e :
                          raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
             root = logging . root
 existing = list ( root . manager . loggerDict )
     existing . sort ( )
   child_loggers = [ ]
  loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      if name in existing :
                          i = existing . index ( name )
 prefixed = name + "."
 pflen = len ( prefixed )
 num_existing = len ( existing )
 i = i + 1
 while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :
                              child_loggers . append ( existing [ i ] )
 i = i + 1
  existing . remove ( name )
  try :
                          self . configure_logger ( name , loggers [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
         for log in existing :
                      logger = root . manager . loggerDict [ log ]
 if log in child_loggers :
                          logger . level = logging . NOTSET
 logger . handlers = [ ]
 logger . propagate = True
  elif disable_existing :
                          logger . disabled = True
     root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
     finally :
              logging . _releaseLock ( )
    def configure_formatter ( self , config ) :
 if '()' in config :
              factory = config [ '()' ]
 try :
                  result = self . configure_custom ( config )
  except TypeError as te :
                  if "'format'" not in str ( te ) :
                      raise
      config [ 'fmt' ] = config . pop ( 'format' )
 config [ '()' ] = factory
 result = self . configure_custom ( config )
   else :
              fmt = config . get ( 'format' , None )
 dfmt = config . get ( 'datefmt' , None )
 result = logging . Formatter ( fmt , dfmt )
  return result
   def configure_filter ( self , config ) :
 if '()' in config :
              result = self . configure_custom ( config )
  else :
              name = config . get ( 'name' , '' )
 result = logging . Filter ( name )
  return result
   def add_filters ( self , filterer , filters ) :
 for f in filters :
              try :
                  filterer . addFilter ( self . config [ 'filters' ] [ f ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )
     def configure_handler ( self , config ) :
 formatter = config . pop ( 'formatter' , None )
 if formatter :
              try :
                  formatter = self . config [ 'formatters' ] [ formatter ]
  except StandardError as e :
                  raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
   level = config . pop ( 'level' , None )
 filters = config . pop ( 'filters' , None )
 if '()' in config :
              c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
                  c = self . resolve ( c )
  factory = c
  else :
              klass = self . resolve ( config . pop ( 'class' ) )
  if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
                  try :
                      config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
  except StandardError as e :
                      raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
   elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
                  config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
  elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
                  config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
  factory = klass
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 try :
              result = factory ( ** kwargs )
  except TypeError as te :
              if "'stream'" not in str ( te ) :
                  raise
      kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
 result = factory ( ** kwargs )
  if formatter :
              result . setFormatter ( formatter )
  if level is not None :
              result . setLevel ( _checkLevel ( level ) )
  if filters :
              self . add_filters ( result , filters )
  return result
   def add_handlers ( self , logger , handlers ) :
 for h in handlers :
              try :
                  logger . addHandler ( self . config [ 'handlers' ] [ h ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
     def common_logger_config ( self , logger , config , incremental = False ) :
 level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
              return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
   if strings_only and is_protected_type ( s ) :
          return s
  if isinstance ( s , six . memoryview ) :
          return bytes ( s )
  if isinstance ( s , Promise ) :
          return six . text_type ( s ) . encode ( encoding , errors )
  if not isinstance ( s , six . string_types ) :
          try :
              if six . PY3 :
<body_end><annotation_start_b>  substitute class_name for self.class_name.
  substitute old_method_name for self.old_method_name.
  substitute new_method_name for new_method_name.
  substitute deprecation_warning for self.deprecation_warning.
  define the method __call__ with 2 arguments: self and f.
  define the function wrapped with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  call the function warnings.warn with 3 arguments: string "`%s.%s` is deprecated, use `%s` instead.",
  formated with 3 elements: self.class_name, self.old_method_name and self.new_method_name, self.deprecation_warning and integer 2.   call the function f with a arguments: unpacked list args and unpacked dictionary kwargs, return the result.
  return wrapped.
  derive the class RenameMethodsBase from type base class.
  renamed_methods is an tuple.
  define the method __new__ with 4 arguments: cls, name, bases and attrs.
  call the method __new__ with 4 arguments: cls, name, bases and attrs, from the base class of the class RenameMethodsBase.
  call the method inspect.getmro with an argument new_class, for every base in the result,
  substitute base.__name__ for class_name.
  for every renamed_method in cls.renamed_methods,
  substitute first element of renamed_method for old_method_name.
  get the value under the old_method_name key of the base.__dict__ dictionary, substitute it for old_method.
  substitute second element of renamed_method for new_method_name.
  get the value under the new_method_name key of the base.__dict__ dictionary, substitute it for new_method.
  substitute third element of renamed_method for deprecation_warning.
  call the function warn_about_renamed_method with 2 arguments: class_name and unpacked list renamed_method, substitute the result for wrapper.
  if new_method is false and old_method is true,
  call the function warnings.warn with 3 arguments: string "`%s.%s` method should be renamed `%s`.",
  formated with 3 elements: class_name, old_method_name and new_method_name, deprecation_warning and integer 2.   set new_method_name attribute of the base object to old_method.
  set old_method_name attribute of the base object to the result of the function wrapper called with an argument old_method.
  if old_method is false and new_method is true,
  set old_method_name attribute of the base object to the result of the function wrapper called with an argument new_method.
  return new_class.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  call the function warnings.warn with 3 arguments: string "django.utils.dictconfig will be removed in Django 1.9.",
  RemovedInDjango19Warning and stacklevel set to integer 2.   import module logging.handlers.
  import module re.
  import module sys.
  import module types.
  from django.utils import six into default name space.
  compile regex from string '^[a-z_][a-z0-9_]*$' in case insensitive mode, substitute it for IDENTIFIER.
  define the function valid_ident with an argument s.
  match string s with regex IDENTIFIER, substitute the result for m.
  if m is false,
  raise an ValueError exception with an argument string 'Not a valid Python identifier: %r' formated with s.
  return boolean True.
  try,
  from logging import _checkLevel.
  if ImportError exception is caught,
  define the function _checkLevel with an argument level.
  if level is an instance of int type,
  substitute level for rv.
  otherwise if level converted into a string equals level,
  if level is not contained in logging._levelNames,
  raise an ValueError exception with an argument string 'Unknown level: %r' formated with level.
  substitute value under level key of logging._levelNames dictionary for rv.
  if not,
  raise an TypeError exception with an argument string 'Level not an integer or a valid string: %r' formated with level.
  return rv.
  derive the class ConvertingDict from dict base class.
  define the method __getitem__ with 2 arguments: self and key.
  call the method dict.__getitem__ with 2 arguments self and key, substitute the result for value.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  substitute result for self dictionary under key key.
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
  return result.
  define the method get with 3 arguments: self, key and default set to None.
  get value under key key of self dictionary, if it doesnt exists return default, substitute the result for value.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  substitute result for value under key key of self dictionary.
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
  return result.
  define the method pop with 3 arguments: self, key and default set to None.
  remove value under key key of self dictionary, if it doesnt exists return default, substitute the result for value.
  call the method self.configurator.convert with an argument value.
  if value is not contained in result,
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
  return result.
  derive the class ConvertingList from list base class.
  define the method __getitem__ with 2 arguments: self and key.
  call the method list.__getitem__ with 2 arguments self and key, substitute the result for value.
  call the method self.configurator.convert with an arugment value, substitute the result for result.
  if value is not contained in result,
  substitute result for value under key key of self dictionary.
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
  return result.
  define the method pop with 2 arguments: self and idx set to negative integer 1.
  remove idx-th element from self list.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  return result.
  derive the class ConvertingTuple from tuple base class.
  define the method __getitem__ with 2 arguments: self and key.
  call the method tuple.__getitem__ with 2 arguments: self and key, substitute the result for value.
  call the method self.configurator.convert with an argument value, substitute the result for result.
  if value is not contained in result,
  if type of result is ConvertingDict, ConvertingList or ConvertingTuple,
  substitute self for result.parent.
  substitute key for result.key.
  return result.
  derive the class BaseConfigurator from object base class.
  compile a regex from raw string '^(?P<prefix>[a-z]+)://(?P<suffix>.*)$', substitute it for CONVERT_PATTERN.
  compile a regex from raw string '^\s*(\w+)\s*', substitute it for WORD_PATTERN.
  compile a regex from raw string '^\.\s*(\w+)\s*', substitute it for DOT_PATTERN.
  compile a regex from raw string '^\[\s*(\w+)\s*\]\s*', substitute it for INDEX_PATTERN.
  compile a regex from raw string '^\d+$', substitute it for DIGIT_PATTERN.
  value_converters is a dictionary with 2 entries: 'ext_convert' for 'ext' and 'cfg_convert' for 'cfg'.
  substitute __import__ for importer.
  define the method __init__ with 2 arguments: self and config.
  self.config is an instance of ConvertingDict, called with an argument config.
  substitute self for self.config.configurator.
  define the method resolve with 2 arguments: self and s.
  split s into parts by '.', substitute the result for name.
  remove first element from name, substitute the result for used.
  try,
  call the method self.importer with an argument used, substitute the result for found.
  for every frag in name.
  append '.' to frag, append the result to used.
  try,
  get frag attribute from found object, substitute it for found.
  if AttributeError exception is caught,
  call the method self.importer with an argument used.
  get frag attribute from found object, substitute it for found.
  return found.
  if ImportError exception is caught,
  call the method sys.exc_info, substitute the result without the first element for e and tb.
  raise an ValueError exception with an argument string 'Cannot resolve %r: %s', formated with s and e.
  substitute e and tb for v.__cause__ and v.__traceback__.
  raise an v exception.
  define the method ext_convert with 2 arguments: self and value.
  call the method self.resolve with an argument value, return the result.
  define the method cfg_convert with 2 arguments: self and value.
  substitute value for rest.
  match rest string with self.WORD_PATTERN regex, substitute the result for m.
  if m is None,
  raise an ValueError exception with an argument string "Unable to convert %r" formated with value.
  if not,
  call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
  call the method m.groups, use the first element of the result as key for obtaining value from self.config dictionary,
  substitute it for d.   while rest is true,
  match rest string with self.DOT_PATTERN regex, substitute the result for m.
  if m is true,
  call the method m.groups, use the first element of the result as key for obtaining value from d dictionary,
  if not,
  match rest string with self.INDEX_PATTERN regex, substitute the result for m.
  if m is true,
  call the method m.groups, substitute the first element of the result for idx.
  match rest string with self.DIGIT_PATTERN regex, if it evaluates to false,
  substitute value under idx key of dictionary d for d.
  if not,
  try,
  convert idx to an integer, substitute it or n.
  substitute value under n key of dictionary d for d.
  if TypeError exception is caught,
  substitute value under idx key of dictionary d for d.
  if m is true,
  call the method m.end, slice list rest from previous result as starting index to the end, substitute the result for rest.
  if not,
  raise an ValueError exception with an argument string 'Unable to convert %r at %r' formated with value and rest.
  return d.
  define the method convert with 2 arguments: self and value.
  if vale is not an instance of ConvertingDict and value is an instance of dict type,
  value is an instance of ConvertingDict class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is not an instance of ConvertingList and value is an instance of list type,
  value is an instance of ConvertingList class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is not an instance of ConvertingTuple and value is an instance of tuple type,
  value is an instance of ConvertingTuple class, created with an argument value.
  substitute self for value.configurator.
  otherwise if vale is an instance of value,
  match value string with regex self.CONVERT_PATTERN, substitute the result for m.
  if m is true,
  call the method m.groupdict, substitute the result for d.
  substitute value under the 'prefix' key of dictionary d, substitute it for prefix.
  remove self.value_converters dictionary element under prefix key, if it exists substitute it for converter, if not, converter is None.
  if converter is true,
  substitute value under the 'suffix' key of dictionary d, substitute it for suffix.
  get converter attribute from self object, substitute it for converter.
  call the function converter with an argument suffix, substitute the result for value.
  return value.
  define the method configure_custom with 2 arguments: self and config.
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__' and types has an 'ClassType' attribute and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  remove config dictionary element under '.' key, if it exists substitute it for props, if not, props is None.
  kwargs is a dictionary with elements: config dictionary element under k key for k, for every k in result of function valid_ident,
  called with an argument k.   call the function c with an argument unpacked dictionary kwargs, substitute the result for result.
  if props is true,
  for every name and value in items of props dictionary,
  set result attribute name to value value.
  return result.
  define the method as_tuple with 2 arguments: self and value.
  if valu is an instance of list type,
  convery value into a tuple, substitute it for value.
  return value.
  derive the class DictConfigurator from the BaseConfigurator base class.
  define the method configure with an argument self.
  substitute self.config for config.
  if string 'version' is not contained in config,
  raise an ValueError exception with an argument string "dictionary doesn't specify a version".
  if config dictionary value under 'version' key is not equal to integer 1,
  raise an ValueError exception with an argument string "Unsupported version: %s" formated with value under 'version' key of config dictionary.
  get config dictionary element under 'incremental' key, if it exists substitute it for incremental, if not,
  incremental is boolean False.   EMPTY_DICT is an empty dictionary.
  call the method logging._acquireLock.
  try,
  if incremental is true,
  get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
  if first two elements of sys.version_info equal to integers 2 ant 7, respectively,
  for every name in handlers,
  if name is not contained in logging._handlers,
  raise an ValueError exception with an argument string 'No handler found with name %r' formated with name.
  if not,
  try,
  substitute value under name key of logging._handlers dictionary for handler.
  substitute value under name key of handlers dictionary for handler_config.
  get handler_config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  if level is true,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the function handler.setLevel.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
  get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
  for every name in loggers,
  try,
  call the method self.configure_logger with 3 arguments: name, value under name key of loggers dictionary and boolean True.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
  get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
  if root is true,
  try,
  call the method self.configure_root with 2 arguments: root and boolean True.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure root logger: %s' formated with e.
  if not,
  remove config dictionary element under 'disable_existing_loggers' key, if it exists substitute it for disable_existing, if not,
  disable_existing is boolean True.   call the method logging._handler.clear.
  delete logging._handlerList list.
  get config dictionary element under 'formatters' key, if it exists substitute it for formatters, if not, formatters is EMPTY_DICT.
  for every name in formatters,
  try,
  call the method self.configure_filter with an argument value under name key of formatters dictionary,
  substitute the result for formatters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure formatter %r: %s' formated with name and e.
  get config dictionary element under 'filters' key, if it exists substitute it for filters, if not, filters is EMPTY_DICT.
  for every name in filters,
  try,
  call the method self.configure_filter with an argument value under name key of filters dictionary,
  substitute the result for filters dictionary value under name key.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure filter %r: %s' formated with name and e.
  get config dictionary element under 'handlers' key, if it exists substitute it for handlers, if not, handlers is EMPTY_DICT.
  sort elements of handlers, for every name in result,
  try,
  call the method self.configure_handler with an argument value under name key of handlers dictionary, substitute the result for handler.
  substitute name for handler.name.
  substitute handler for value under name key of handlers dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure handler %r: %s' formated with name and e.
  substitute logging.root for root.
  convert root.manager.loggerDict into a list, substitute it for existing.
  sort elements of list existing.
  child_loggers is an empty list.
  get config dictionary element under 'loggers' key, if it exists substitute it for loggers, if not, loggers is EMPTY_DICT.
  for every name in loggers,
  if name is contained in existing,
  get the index of first occurrence of name in existing, substitute it for i.
  append '.' to name, substitute the result for prefixed.
  substitute length of prefixed for pflen.
  substitute length of existing for num_existing.
  increment i by integer 1, substitute the result for i.
  while i is lesser than num_existing and first pflen elements of i-th element of existing equals prefixed,
  append i-th element of existing to child_loggers.
  increment i by integer 1, substitute the result for i.
  remove name from existing.
  try,
  call the method self.configure_logger with 2 arguments: name and value under loggers dictionary key name.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to configure logger %r: %s' formated with name and e.
  for every log in existing,
  get the value under log key of root.manager.loggerDict dictionary, substitute it for logger.
  if log is contained in child_loggers,
  substitute logging.NOTSET for logger.level.
  logger.handlers is an empty list.
  logger.propagate is boolean True.
  otherwise if disable_existing is true,
  logger.disabled is boolean True.
  get config dictionary element under 'root' key, if it exists substitute it for root, if not, root is None.
  if root is true,
  try,
  call the method self.configure_root with an argument root.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string ''Unable to configure root logger: %s' formated with e.
  finally perform,
  call the method logging._releaseLock.
  define the method configure_formatter with 2 arguments: self and config.
  if string '()' is contained in config,
  substitute config dictionary value under '()' key for factory.
  try,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if string "'format'" is not contained in e converted into a string,
  raise an exception.
  remove config dictionary entry under 'format' key, substitute it for value under 'fmt' key of config dictionary.
  substitute factory for value under '()' key of config dictionary.
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  get config dictionary element under 'format' key, if it exists substitute it for fmt, if not, fmt is None.
  get config dictionary element under 'datefmt' key, if it exists substitute it for dfmt, if not, dfmt is None.
  call the method logging.Formatter with 2 arguments: fmt and dfmt, substitute the result for result.
  return result.
  define the method configure_filter with 2 arguments: self and config.
  if string '()' is contained in config,
  call the method self.configure_custom with an argument config, substitute the result for result.
  if not,
  remove config dictionary element under 'name' key, if it exists substitute it for name, if not, name is an empty string.
  call the method logging.Filter with an argument name, substitute the result for result.
  return result.
  define the method add_filters with 3 arguments: self, filterer and filters.
  for every f in filters,
  try,
  get the value under f key of dictionary under 'filters' key of self.config dictionary,
  use the result as an argument for the call to the method filterer.addFilter.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add filter %r: %s' formated with f and e.
  define the method configure_handler with 2 arguments: self and config.
  remove config dictionary element under 'formatter' key, if it exists substitute it for formatter, if not, formatter is None.
  if formatter is true,
  try,
  get the value under formatter key of dictionary under 'formatters' key of self.config dictionary, substitute the result for formatter.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set formatter %r: %s' formated with formatter and e.
  remove config dictionary element under 'level' key, if it exists substitute it for level, if not, level is None.
  remove config dictionary element under 'filter' key, if it exists substitute it for filters, if not, filters is None.
  if string '()' is contained in config,
  remove config dictionary element under '()' key, substitute it for c.
  if c doesnt have an attribute '__call__', and types has an attribute 'ClassType', and type of c is not equal to types.ClassType,
  call the method self.resolve with an argument c, substitute the result for c.
  substitute c for factory.
  if not,
  remove config dictionary element under 'class' key, use it as an argument for the call to the method self.resolve,
  substitute the result for klass.   if klass is a subclass of logging.handlers.MemoryHandler base class and string 'target' is contained in config,
  try,
  get value under 'target' key of config dictionary, use it as a key to get the value from the dictionary,
  under the 'handlers' key of self.config dictionary, substitute the result for value under 'target' key of config dictioanry.   if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to set target handler %r: %s',
  formated with value under 'target' key of config dictionary and e.   otherwise if klass is a subclass of logging.handlers.SMTPHandler and string 'mailhost' is contained in config,
  call the method self.as_tuple with an argument value under 'mailhost' key of config dictionary,
  substitute the result for value under 'mailhost' key of config dictionary.   otherwise if klass is subclass of logging.handlers.SysLogHandler class, and string 'address' is contained in config,
  call the method self.as_tuple with an argument value under 'address' key of config dictionary,
  substitute the result for value under 'address' key of config dictionary.   substitute klass for factory.
  kwargs is a dictionary created with tuples with 2 elements: k and value under k key of config dictionary,
  for every k in config, only if result of the function valid_ident called with an argument k evaluates to true.   try,
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if TypeError, renamed to te, exception is caught,
  if "'stream'" is not contained in te converted into a string,
  raise an exception.
  remove element under 'stream' key of kwargs dictionary, substitute the result for value under 'strm' key of kwargs dictionary.
  call the function factory with an argument unpacked dictionary kwargs, substitute the result for result.
  if formatter is true,
  call the method result.setFormatter with an argument formatter.
  if level is not None,
  call function _checkLevel with an argument level, use the result as an argument for the method result.setLevel.
  if filters is true,
  call the method self.add_filters with 2 arguments: result and filters.
  return result.
  define the method add_handlers with 3 arguments: self, logger and handlers.
  for every h in handlers,
  try,
  call the method logger.addHandler with an argument: h-th element of value under 'handlers' key of self.config dictionary.
  if StandardError, renamed to e, exception is caught,
  raise an ValueError exception with an argument string 'Unable to add handler %r: %s' formated with h and e.
  define the method common_logger_config with 4 arguments: self, logger, config and incremental set to boolean False.
  get value under the 'level' key of the config dictioanry, if it exists substitute it for level, if not level is None.
  if level is not None,
  call the function _checkLevel with an argument level, use the result as an argument for the call to the method logger.setLevel.
  if incremental is true,
  for every h in elements of logger.handlers list,
  call the method logger.removeHandler with an argument h.
  get value under the 'handlers' key of the config dictioanry, if it exists substitute it for handlers, if not handlers is None.
  if handlers is true,
  call the method self.add_handlers with 2 arguments: logger and handlers.
  get value under the 'filters' key of the config dictioanry, if it exists substitute it for filters, if not filters is None.
  if filters is true,
  call the method self.add_filters with 2 arguments: logger and filters.
  define the method configure_logger with 4 arguments: self, name, config, incremental set to boolean False.
  call the method logging.getLogger with an argument name, substitute the result for logger.
  call the method self.common_logger_config with 3 arguments: logger, config and incremental.
  get value under the 'propagate' key of the config dictioanry, if it exists substitute it for propagate, if not propagate is None.
  if propagate is not None,
  substitute propagate for logger.propagate.
  define the method configure_root with 3 arguments: self, config and incremental set to boolean False.
  call the method logging.getLogger, substitute the result for root.
  call the method self.common_logger_config with 3 arguments: root, config and incremental.
  substitute DictConfigurator for dictConfigClass.
  define the function dictConfig with an argument config.
  call the method dictConfigClass with an argument config, call the method configure on the result.
  from __future__ import unicode_literals into default name space.
  import module codecs.
  import module datetime.
  from decimal import Decimal into default name space.
  import module locale.
  from django.utils.functional import Promise into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote into default name space.
  derive the class DjangoUnicodeDecodeError from the base class UnicodeDecodeError.
  define the private method __init__, with self instance of this class, obj and list of arbitrary length *args as arguments.
  assign obj to the obj field of self instance of this class.
  call the initialization method UnicodeDecodeError.__init__, with self instance of this class and *args as arguments.
  define the private method __str__, with self instance of this class as the only argument.
  call the method UnicodeDecodeError.__str__, with self as the argument, substitute the result for original.
  in the string '%s. You passed in %r (%s)' replace every %s with original and type of the object self.obj as strings, respectively,
  and replace %r with self.obj, return the result.   define function python_2_unicode_compatible, with klass as an argument.
  if field PY2 of the module six is boolean True,
  if string '__str__' is not contained in __dict__ field of klass,
  raise the exception ValueError, with string as argument, "@python_2_unicode_compatible cannot be applied",
  "to %s because it doesn't define __str__().", replace %s with string value of klass.__name__.   substitute __str__ filed of klass for __unicode__ field of klass.
  define lambda function with self class instance as the argument, lambda function body encapsulates the call to the method,
  str.__unicode__().encode('utf-8'), call the lambda function and put the result in the __str__ filed of klass.   return klass.
  define the function smart_text, with s, encoding set to string 'utf-8', strings_only set to False, errors set to 'strict' as arguments.
  if s is instance of a class Promise,
  return s.
  return the result of the call to the function force_text, with s, encoding, string_only and errors as arguments.
  _PROTECTED_TYPES is a tuple containing next elements, six.integer_types, type of None, type of float, Decimal, detetime.datetime,
  datetime.date and datetime.time.   define the function is_protected_type with obj as the only argument.
  check if obj is instance of the object _PROTECTED_TYPES, return the boolean result.
  define the function force_text, with s, encoding set to 'utf-8', strings_only set to False, errors set to string 'strict' as arguments.
  if s is the instance of the object six.text_type,
  return s.
  if the boolean return vale of the call to the function is_protected_type(s) and string_onlys are boolean True,
  return s.
  try,
  if s is not an instance of the object six/string_types,
  if PY3 filed of six is boolean True,
  if s is an instance of object bytes,
  call the function six.text_type with s, encoding and errors as the arguments, substitute the result for s.
  if not,
  call the function six.text_type with s as an argument, substitute the result for s.
  otherwise, if s has an attribute '__unicode__',
  call the function six.text_type with s as an argument, substitute result for s.
  if not,
  call the function six.text_type with return value of the function bytes(s), encoding and errors as the arguments,
  substitute the result for s.   if not,
  call the method s.decode with encoding and errors as the arguments, substitute the result for s.
  if an exception of the type UnicodeDecodeError, renamed to e, is caught,
  if s is not an instance of the object Exception,
  raise an exception DjingoUnicodeDecodeError, with s and list of arguments *args from object e, as the arguments.
  if not,
  for every arg in s, call the function force_text with arg, encoding, strings_only and errors as arguments,
  join the result in a string separated by whitespaces, substitute it for s.   return s.
  define function smart_bytes with s, encoding set to string 'utf-8', strings_only set to False and errors set to string 'strict', as arguments.
  if s is an instance of an object Promise.
  return s.
  evaluate the function force_bytes, with the arguments s, encoding, strings_only and errors, return the result.
  define function force_bytes with s, encoding set to 'utf-8', strings_only set to False and errors set to 'strict' as arguments.
  if s is an instance of an object bytes.
  if encoding equals to string 'utf-8'.
  return s.
  if not,
  evaluate the method s.decode with string 'utf-8' and errors as the arguments,
  on the result call the method encode with the arguments encoding and errors, return the result.   if strings_only and boolean return value of the call to the function is_protected_type for argument s are boolean True,
  return s.
  if s is an instance of an object six.memoryview.
  evaluate the function bytes with the argument s, and return the result.
  if s is an instance of an object Promise.
  return six.text_type(s).encode(encoding, errors).
  if s is not an instance of the object six.string_types,
  try,
  if PY3 field of six is boolean True,
  evaluate the method six.text_type(s), on the result call the method encode with encoding as an argument, return the result.
  if not,
<annotation_end_b>#<body_start>          self . class_name = class_name
 self . old_method_name = old_method_name
 self . new_method_name = new_method_name
 self . deprecation_warning = deprecation_warning
   def __call__ ( self , f ) :
          def wrapped ( * args , ** kwargs ) :
              warnings . warn (  "`%s.%s` is deprecated, use `%s` instead." %  ( self . class_name , self . old_method_name , self . new_method_name ) ,  self . deprecation_warning , 2 )
 return f ( * args , ** kwargs )
  return wrapped
     class RenameMethodsBase ( type ) :
  renamed_methods = ( )
  def __new__ ( cls , name , bases , attrs ) :
          new_class = super ( RenameMethodsBase , cls ) . __new__ ( cls , name , bases , attrs )
  for base in inspect . getmro ( new_class ) :
              class_name = base . __name__
 for renamed_method in cls . renamed_methods :
                  old_method_name = renamed_method [ 0 ]
 old_method = base . __dict__ . get ( old_method_name )
 new_method_name = renamed_method [ 1 ]
 new_method = base . __dict__ . get ( new_method_name )
 deprecation_warning = renamed_method [ 2 ]
 wrapper = warn_about_renamed_method ( class_name , * renamed_method )
   if not new_method and old_method :
                      warnings . warn (  "`%s.%s` method should be renamed `%s`." %  ( class_name , old_method_name , new_method_name ) ,  deprecation_warning , 2 )
 setattr ( base , new_method_name , old_method )
 setattr ( base , old_method_name , wrapper ( old_method ) )
    if not old_method and new_method :
                      setattr ( base , old_method_name , wrapper ( new_method ) )
     return new_class
import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
  warnings . warn ( "django.utils.dictconfig will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
                      import logging . handlers
 import re
 import sys
 import types
  from django . utils import six
  IDENTIFIER = re . compile ( '^[a-z_][a-z0-9_]*$' , re . I )
   def valid_ident ( s ) :
      m = IDENTIFIER . match ( s )
 if not m :
          raise ValueError ( 'Not a valid Python identifier: %r' % s )
  return True
      try :
      from logging import _checkLevel
  except ImportError :
      def _checkLevel ( level ) :
          if isinstance ( level , int ) :
              rv = level
  elif str ( level ) == level :
              if level not in logging . _levelNames :
                  raise ValueError ( 'Unknown level: %r' % level )
  rv = logging . _levelNames [ level ]
  else :
              raise TypeError ( 'Level not an integer or a '  'valid string: %r' % level )
  return rv
              class ConvertingDict ( dict ) :
  def __getitem__ ( self , key ) :
          value = dict . __getitem__ ( self , key )
 result = self . configurator . convert ( value )
  if value is not result :
              self [ key ] = result
 if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
   return result
   def get ( self , key , default = None ) :
          value = dict . get ( self , key , default )
 result = self . configurator . convert ( value )
  if value is not result :
              self [ key ] = result
 if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
   return result
   def pop ( self , key , default = None ) :
          value = dict . pop ( self , key , default )
 result = self . configurator . convert ( value )
 if value is not result :
              if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
   return result
     class ConvertingList ( list ) :
 def __getitem__ ( self , key ) :
          value = list . __getitem__ ( self , key )
 result = self . configurator . convert ( value )
  if value is not result :
              self [ key ] = result
 if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
   return result
   def pop ( self , idx = - 1 ) :
          value = list . pop ( self , idx )
 result = self . configurator . convert ( value )
 if value is not result :
              if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
   return result
     class ConvertingTuple ( tuple ) :
 def __getitem__ ( self , key ) :
          value = tuple . __getitem__ ( self , key )
 result = self . configurator . convert ( value )
 if value is not result :
              if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
                  result . parent = self
 result . key = key
   return result
     class BaseConfigurator ( object ) :
  CONVERT_PATTERN = re . compile ( r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$' )
  WORD_PATTERN = re . compile ( r'^\s*(\w+)\s*' )
 DOT_PATTERN = re . compile ( r'^\.\s*(\w+)\s*' )
 INDEX_PATTERN = re . compile ( r'^\[\s*(\w+)\s*\]\s*' )
 DIGIT_PATTERN = re . compile ( r'^\d+$' )
  value_converters = {  'ext' : 'ext_convert' ,  'cfg' : 'cfg_convert' ,  }
   importer = __import__
  def __init__ ( self , config ) :
          self . config = ConvertingDict ( config )
 self . config . configurator = self
   def resolve ( self , s ) :
 name = s . split ( '.' )
 used = name . pop ( 0 )
 try :
              found = self . importer ( used )
 for frag in name :
                  used += '.' + frag
 try :
                      found = getattr ( found , frag )
  except AttributeError :
                      self . importer ( used )
 found = getattr ( found , frag )
   return found
  except ImportError :
              e , tb = sys . exc_info ( ) [ 1 : ]
 v = ValueError ( 'Cannot resolve %r: %s' % ( s , e ) )
 v . __cause__ , v . __traceback__ = e , tb
 raise v
    def ext_convert ( self , value ) :
 return self . resolve ( value )
   def cfg_convert ( self , value ) :
 rest = value
 m = self . WORD_PATTERN . match ( rest )
 if m is None :
              raise ValueError ( "Unable to convert %r" % value )
  else :
              rest = rest [ m . end ( ) : ]
 d = self . config [ m . groups ( ) [ 0 ] ]
  while rest :
                  m = self . DOT_PATTERN . match ( rest )
 if m :
                      d = d [ m . groups ( ) [ 0 ] ]
  else :
                      m = self . INDEX_PATTERN . match ( rest )
 if m :
                          idx = m . groups ( ) [ 0 ]
 if not self . DIGIT_PATTERN . match ( idx ) :
                              d = d [ idx ]
  else :
                              try :
                                  n = int ( idx )
 d = d [ n ]
  except TypeError :
                                  d = d [ idx ]
     if m :
                      rest = rest [ m . end ( ) : ]
  else :
                      raise ValueError ( 'Unable to convert '  '%r at %r' % ( value , rest ) )
     return d
   def convert ( self , value ) :
 if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :
              value = ConvertingDict ( value )
 value . configurator = self
  elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :
              value = ConvertingList ( value )
 value . configurator = self
  elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :
              value = ConvertingTuple ( value )
 value . configurator = self
  elif isinstance ( value , six . string_types ) :
              m = self . CONVERT_PATTERN . match ( value )
 if m :
                  d = m . groupdict ( )
 prefix = d [ 'prefix' ]
 converter = self . value_converters . get ( prefix , None )
 if converter :
                      suffix = d [ 'suffix' ]
 converter = getattr ( self , converter )
 value = converter ( suffix )
    return value
   def configure_custom ( self , config ) :
 c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
              c = self . resolve ( c )
  props = config . pop ( '.' , None )
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 result = c ( ** kwargs )
 if props :
              for name , value in props . items ( ) :
                  setattr ( result , name , value )
   return result
   def as_tuple ( self , value ) :
 if isinstance ( value , list ) :
              value = tuple ( value )
  return value
     class DictConfigurator ( BaseConfigurator ) :
  def configure ( self ) :
  config = self . config
 if 'version' not in config :
              raise ValueError ( "dictionary doesn't specify a version" )
  if config [ 'version' ] != 1 :
              raise ValueError ( "Unsupported version: %s" % config [ 'version' ] )
  incremental = config . pop ( 'incremental' , False )
 EMPTY_DICT = { }
 logging . _acquireLock ( )
 try :
              if incremental :
                  handlers = config . get ( 'handlers' , EMPTY_DICT )
   if sys . version_info [ : 2 ] == ( 2 , 7 ) :
                      for name in handlers :
                          if name not in logging . _handlers :
                              raise ValueError ( 'No handler found with '  'name %r' % name )
  else :
                              try :
                                  handler = logging . _handlers [ name ]
 handler_config = handlers [ name ]
 level = handler_config . get ( 'level' , None )
 if level :
                                      handler . setLevel ( _checkLevel ( level ) )
   except StandardError as e :
                                  raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
     loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      try :
                          self . configure_logger ( name , loggers [ name ] , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
   root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root , True )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
    else :
                  disable_existing = config . pop ( 'disable_existing_loggers' , True )
  logging . _handlers . clear ( )
 del logging . _handlerList [ : ]
   formatters = config . get ( 'formatters' , EMPTY_DICT )
 for name in formatters :
                      try :
                          formatters [ name ] = self . configure_formatter (  formatters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )
    filters = config . get ( 'filters' , EMPTY_DICT )
 for name in filters :
                      try :
                          filters [ name ] = self . configure_filter ( filters [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )
       handlers = config . get ( 'handlers' , EMPTY_DICT )
 for name in sorted ( handlers ) :
                      try :
                          handler = self . configure_handler ( handlers [ name ] )
 handler . name = name
 handlers [ name ] = handler
  except StandardError as e :
                          raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
             root = logging . root
 existing = list ( root . manager . loggerDict )
     existing . sort ( )
   child_loggers = [ ]
  loggers = config . get ( 'loggers' , EMPTY_DICT )
 for name in loggers :
                      if name in existing :
                          i = existing . index ( name )
 prefixed = name + "."
 pflen = len ( prefixed )
 num_existing = len ( existing )
 i = i + 1
 while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :
                              child_loggers . append ( existing [ i ] )
 i = i + 1
  existing . remove ( name )
  try :
                          self . configure_logger ( name , loggers [ name ] )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
         for log in existing :
                      logger = root . manager . loggerDict [ log ]
 if log in child_loggers :
                          logger . level = logging . NOTSET
 logger . handlers = [ ]
 logger . propagate = True
  elif disable_existing :
                          logger . disabled = True
     root = config . get ( 'root' , None )
 if root :
                      try :
                          self . configure_root ( root )
  except StandardError as e :
                          raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
     finally :
              logging . _releaseLock ( )
    def configure_formatter ( self , config ) :
 if '()' in config :
              factory = config [ '()' ]
 try :
                  result = self . configure_custom ( config )
  except TypeError as te :
                  if "'format'" not in str ( te ) :
                      raise
      config [ 'fmt' ] = config . pop ( 'format' )
 config [ '()' ] = factory
 result = self . configure_custom ( config )
   else :
              fmt = config . get ( 'format' , None )
 dfmt = config . get ( 'datefmt' , None )
 result = logging . Formatter ( fmt , dfmt )
  return result
   def configure_filter ( self , config ) :
 if '()' in config :
              result = self . configure_custom ( config )
  else :
              name = config . get ( 'name' , '' )
 result = logging . Filter ( name )
  return result
   def add_filters ( self , filterer , filters ) :
 for f in filters :
              try :
                  filterer . addFilter ( self . config [ 'filters' ] [ f ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )
     def configure_handler ( self , config ) :
 formatter = config . pop ( 'formatter' , None )
 if formatter :
              try :
                  formatter = self . config [ 'formatters' ] [ formatter ]
  except StandardError as e :
                  raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
   level = config . pop ( 'level' , None )
 filters = config . pop ( 'filters' , None )
 if '()' in config :
              c = config . pop ( '()' )
 if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
                  c = self . resolve ( c )
  factory = c
  else :
              klass = self . resolve ( config . pop ( 'class' ) )
  if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
                  try :
                      config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
  except StandardError as e :
                      raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
   elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
                  config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
  elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
                  config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
  factory = klass
  kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
 try :
              result = factory ( ** kwargs )
  except TypeError as te :
              if "'stream'" not in str ( te ) :
                  raise
      kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
 result = factory ( ** kwargs )
  if formatter :
              result . setFormatter ( formatter )
  if level is not None :
              result . setLevel ( _checkLevel ( level ) )
  if filters :
              self . add_filters ( result , filters )
  return result
   def add_handlers ( self , logger , handlers ) :
 for h in handlers :
              try :
                  logger . addHandler ( self . config [ 'handlers' ] [ h ] )
  except StandardError as e :
                  raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
     def common_logger_config ( self , logger , config , incremental = False ) :
 level = config . get ( 'level' , None )
 if level is not None :
              logger . setLevel ( _checkLevel ( level ) )
  if not incremental :
               for h in logger . handlers [ : ] :
                  logger . removeHandler ( h )
  handlers = config . get ( 'handlers' , None )
 if handlers :
                  self . add_handlers ( logger , handlers )
  filters = config . get ( 'filters' , None )
 if filters :
                  self . add_filters ( logger , filters )
     def configure_logger ( self , name , config , incremental = False ) :
 logger = logging . getLogger ( name )
 self . common_logger_config ( logger , config , incremental )
 propagate = config . get ( 'propagate' , None )
 if propagate is not None :
              logger . propagate = propagate
    def configure_root ( self , config , incremental = False ) :
 root = logging . getLogger ( )
 self . common_logger_config ( root , config , incremental )
    dictConfigClass = DictConfigurator
   def dictConfig ( config ) :
 dictConfigClass ( config ) . configure ( )
from __future__ import unicode_literals
  import codecs
 import datetime
 from decimal import Decimal
 import locale
  from django . utils . functional import Promise
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote
   class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
      def __init__ ( self , obj , * args ) :
          self . obj = obj
 UnicodeDecodeError . __init__ ( self , * args )
   def __str__ ( self ) :
          original = UnicodeDecodeError . __str__ ( self )
 return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
     def python_2_unicode_compatible ( klass ) :
 if six . PY2 :
          if '__str__' not in klass . __dict__ :
              raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
  klass . __unicode__ = klass . __str__
 klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
  return klass
    def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_text ( s , encoding , strings_only , errors )
    _PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
   def is_protected_type ( obj ) :
 return isinstance ( obj , _PROTECTED_TYPES )
    def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , six . text_type ) :
          return s
  if strings_only and is_protected_type ( s ) :
          return s
  try :
          if not isinstance ( s , six . string_types ) :
              if six . PY3 :
                  if isinstance ( s , bytes ) :
                      s = six . text_type ( s , encoding , errors )
  else :
                      s = six . text_type ( s )
   elif hasattr ( s , '__unicode__' ) :
                  s = six . text_type ( s )
  else :
                  s = six . text_type ( bytes ( s ) , encoding , errors )
   else :
                 s = s . decode ( encoding , errors )
   except UnicodeDecodeError as e :
          if not isinstance ( s , Exception ) :
              raise DjangoUnicodeDecodeError ( s , * e . args )
  else :
                   s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
   return s
    def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
 if isinstance ( s , Promise ) :
           return s
  return force_bytes ( s , encoding , strings_only , errors )
    def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
  if isinstance ( s , bytes ) :
          if encoding == 'utf-8' :
              return s
  else :
              return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
   if strings_only and is_protected_type ( s ) :
          return s
  if isinstance ( s , six . memoryview ) :
          return bytes ( s )
  if isinstance ( s , Promise ) :
          return six . text_type ( s ) . encode ( encoding , errors )
  if not isinstance ( s , six . string_types ) :
          try :
              if six . PY3 :
                  return six . text_type ( s ) . encode ( encoding )
  else :
<body_end><annotation_start_b>  if iri is not initialized,
<annotation_end_b>#<body_start>             if iri is None :
<body_end><annotation_start_b>  if path is not initialized,
<annotation_end_b>#<body_start> if path is None :
<body_end><annotation_start_b>  try,
  evaluate the function getdefaultlocale from the module locale, if second element of return value exists assign it to encoding,
  otherwise assign string 'ascii' to encoding.   call the method lookup with the encoding as the argument.
  if the Exception exception is caught,
  substitute string 'ascii' for encoding.
<annotation_end_b>#<body_start> try :
          encoding = locale . getdefaultlocale ( ) [ 1 ] or 'ascii'
 codecs . lookup ( encoding )
  except Exception :
          encoding = 'ascii'
<body_end><annotation_start_b>  months is a tuple with 12 elements: strings 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov' and 'Dec'.
  days is a tuple with 7 elements: strings 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' and 'Sun'.
  call the method datetime_safe.new_datetime with an argument date, substitute the result for date.
  call the method date.weekday, use the result as an key to obtain the value from the days dictionary, substitute it for dow.
  decrement date.month by integer 1, use the result as an key to obtain the value from the months dictionary, substitute it for month.
  call the function date.strftime with an argument string '%s, %%d %s %%Y %%H:%%M:%%S ' formated with dow and month,
  substitute the result for time_str.   if six.PY2 is true,
  call the method time_str.decode with an argument string 'utf-8', substitute the result for time_str.
  call the function is_aware with an argument date, if it evaluates to true,
  call the method date.tzinfo.utcoffset with an argument date, substitute the result for offset.
  multiply offset.days, integer 24 and integer 60, sum the result with floored result of dividing offset.seconds by integer 60,
  substitute the result for timezone.   divide timezone by integer 60, substitute the quotient of the division for hour and reminder for minute.
<annotation_end_b>#<body_start>        months = ( 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' , )
 days = ( 'Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun' )
  date = datetime_safe . new_datetime ( date )
  dow = days [ date . weekday ( ) ]
 month = months [ date . month - 1 ]
 time_str = date . strftime ( '%s, %%d %s %%Y %%H:%%M:%%S ' % ( dow , month ) )
 if six . PY2 :
          time_str = time_str . decode ( 'utf-8' )
  if is_aware ( date ) :
          offset = date . tzinfo . utcoffset ( date )
 timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
 hour , minute = divmod ( timezone , 60 )
<body_end><annotation_start_b>  call the function datetime_safe.new_datetime with an argument date, substitute the result for date.
  call the function date.strftime with an argument string '%Y-%m-%dT%H:%M:%S', substitute the result for time_str.
  if six.PY2,
  call the method time_str.decode with an argument string 'utf-8', substitute the result for time_str.
  call the function is_aware with an argument date, if it evaluates to true,
  call the method date.tzinfo.utcoffset with an argument date, substitute the result for offset.
  multiply offset.days, integer 24 and integer 60, sum the result with floored result of division of offset.seconds,
  and integer 60, substitute the result for timezone.   divide timezone by integer 60, substitute the quotient of the division for hour and reminder for minute.
<annotation_end_b>#<body_start>       date = datetime_safe . new_datetime ( date )
 time_str = date . strftime ( '%Y-%m-%dT%H:%M:%S' )
 if six . PY2 :
          time_str = time_str . decode ( 'utf-8' )
  if is_aware ( date ) :
          offset = date . tzinfo . utcoffset ( date )
 timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
 hour , minute = divmod ( timezone , 60 )
<body_end><annotation_start_b>  call the method urlparse with an argument url, substitute the result for bits.
  d is an empty string.
  if date is not None,
  call the function datetime_safe.new_datetime with an argument date, on the result call the method strftime with an argument,
<annotation_end_b>#<body_start> bits = urlparse ( url )
 d = ''
 if date is not None :
          d = ',%s' % datetime_safe . new_datetime ( date ) . strftime ( '%Y-%m-%d' )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  s is an instance of StringIO class.
  call the method self.write with 2 arguments: s and encoding.
<annotation_end_b>#<body_start> s = StringIO ( )
 self . write ( s , encoding )
<body_end><annotation_start_b>  latest_date is None.
  date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
  for every item in self.items,
  for every date_key in date_keys,
  get the value under the date_key key of the item dictionary, substitute it for item_date.
  if item_date is true,
  if latest_date is None or item_date is greater than latest_date,
  substitute item_date for latest_date.
<annotation_end_b>#<body_start> latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if value under the 'language' key of the self.feed dictionary is not None,
<annotation_end_b>#<body_start>          if self . feed [ 'language' ] is not None :
<body_end><annotation_start_b>  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
<annotation_end_b>#<body_start>          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
<body_end><annotation_start_b>  call the function check_for_language with an argument lang, if it evaluates to false,
<annotation_end_b>#<body_start> if not check_for_language ( lang ) :
<body_end><annotation_start_b>  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
<annotation_end_b>#<body_start> if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
<body_end><annotation_start_b>  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
<annotation_end_b>#<body_start> global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
<body_end><annotation_start_b>  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
<annotation_end_b>#<body_start> format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
<body_end><annotation_start_b>  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
<annotation_end_b>#<body_start>          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
<body_end><annotation_start_b>  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
<annotation_end_b>#<body_start>          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
<body_end><annotation_start_b>  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
<annotation_end_b>#<body_start>          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
<annotation_end_b>#<body_start> if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
<body_end><annotation_start_b>  if value is an instance of bool.
<annotation_end_b>#<body_start> if isinstance ( value , bool ) :
<body_end><annotation_start_b>  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
<annotation_end_b>#<body_start>          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
<body_end><annotation_start_b>  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
<annotation_end_b>#<body_start>          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
<body_end><annotation_start_b>  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
<annotation_end_b>#<body_start>          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
<body_end><annotation_start_b>  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
<annotation_end_b>#<body_start>          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
<body_end><annotation_start_b>  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
<annotation_end_b>#<body_start>          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
<body_end><annotation_start_b>  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
<annotation_end_b>#<body_start> if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
<body_end><annotation_start_b>  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
<annotation_end_b>#<body_start>          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
<body_end><annotation_start_b>  substitute length and mime_type for self.length and self.mime_type.
  call the function iri_to_uri with an argument url, substitute the result for self.url.
  derive the class RssFeed from the SyndicationFeed base class.
  mime_type is a string 'application/rss+xml; charset=utf-8'.
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.date,
  call the method datetime_safe.new_date with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
<annotation_end_b>#<body_start> self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
<body_end><annotation_start_b>  raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
  define the method writeString with 2 arguments self and encoding.
  s is an instance of StringIO class.
  call the method self.write with 2 arguments: s and encoding.
  call the method s.getvalue, return the result.
  define the method latest_post_date with an argument self.
  latest_date is None.
  date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
  for every item in self.items,
  for every date_key in date_keys,
  get the value under the date_key key of the item dictionary, substitute it for item_date.
  if item_date is true,
  if latest_date is None or item_date is greater than latest_date,
  substitute item_date for latest_date.
  if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
  derive the class Enclosure from the object base class.
  define the method __init__ with 4 arguments: self, url, length and mime_type.
  substitute length and mime_type for self.length and self.mime_type.
  call the function iri_to_uri with an argument url, substitute the result for self.url.
  derive the class RssFeed from the SyndicationFeed base class.
  mime_type is a string 'application/rss+xml; charset=utf-8'.
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.date,
  call the method datetime_safe.new_date with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.time,
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
<annotation_end_b>#<body_start> raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
   def writeString ( self , encoding ) :
 s = StringIO ( )
 self . write ( s , encoding )
 return s . getvalue ( )
   def latest_post_date ( self ) :
 latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
      return latest_date or datetime . datetime . now ( )
     class Enclosure ( object ) :
 def __init__ ( self , url , length , mime_type ) :
 self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . time ) :
          format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
<body_end><annotation_start_b>  do nothing.
  define the method write with 3 arguments self, outfile and encoding.
  raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
  define the method writeString with 2 arguments self and encoding.
  s is an instance of StringIO class.
  call the method self.write with 2 arguments: s and encoding.
  call the method s.getvalue, return the result.
  define the method latest_post_date with an argument self.
  latest_date is None.
  date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
  for every item in self.items,
  for every date_key in date_keys,
  get the value under the date_key key of the item dictionary, substitute it for item_date.
  if item_date is true,
  if latest_date is None or item_date is greater than latest_date,
  substitute item_date for latest_date.
  if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
  derive the class Enclosure from the object base class.
  define the method __init__ with 4 arguments: self, url, length and mime_type.
  substitute length and mime_type for self.length and self.mime_type.
  call the function iri_to_uri with an argument url, substitute the result for self.url.
  derive the class RssFeed from the SyndicationFeed base class.
  mime_type is a string 'application/rss+xml; charset=utf-8'.
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.date,
  call the method datetime_safe.new_date with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.time,
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'TIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
<annotation_end_b>#<body_start> pass
   def write ( self , outfile , encoding ) :
 raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
   def writeString ( self , encoding ) :
 s = StringIO ( )
 self . write ( s , encoding )
 return s . getvalue ( )
   def latest_post_date ( self ) :
 latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
      return latest_date or datetime . datetime . now ( )
     class Enclosure ( object ) :
 def __init__ ( self , url , length , mime_type ) :
 self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . time ) :
          format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
<body_end><annotation_start_b>  if settings.USE_L10N is true and value is an instance of six.string_types,
  parts is an empty list.
  call the function get_format with an argument string 'DECIMAL_SEPARATOR', substitute the result for decimal_separator.
  if decimal_separator is contained in value,
  split value into two parts by decimal_separator, assign the result to value and decimals.
  append decimals to parts.
  if settings.USE_THOUSAND_SEPARATOR is true,
  call the function get_format with an argument string 'THOUSAND_SEPARATOR', substitute the result for thousand_sep.
  call the function unicodedata.normalize with 2 arguments: string 'NFKD' and thousand_sep, put the result and thousand_sep into a set,
  for every replacement in the resulting set,   replace every occurrence of replacement in value for an empty string, substitute the result for value.
  append value to parts.
  reverse order of parts, join them into a string, separated with '.', substitute the result for value.
<annotation_end_b>#<body_start> if settings . USE_L10N and isinstance ( value , six . string_types ) :
          parts = [ ]
 decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )
 if decimal_separator in value :
              value , decimals = value . split ( decimal_separator , 1 )
 parts . append ( decimals )
  if settings . USE_THOUSAND_SEPARATOR :
              thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )
 for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :
                  value = value . replace ( replacement , '' )
   parts . append ( value )
 value = '.' . join ( reversed ( parts ) )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  define the function _curried with 2 arguments: unpacked list moreargs and unpacked dictionary morekwargs.
  call the function _curried_func with 2 arguments: list moreargs appended to args and unpacked,
<annotation_end_b>#<body_start>      def _curried ( * moreargs , ** morekwargs ) :
          return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
<body_end><annotation_start_b>  mem_args is a list containing of first num_args elements of args list.
  if mem_args is contained in cache,
<annotation_end_b>#<body_start>          mem_args = args [ : num_args ]
 if mem_args in cache :
<body_end><annotation_start_b>  call the function warnings.warn with 3 arguments:
  string "memoize wrapper is deprecated and will be removed in Django 1.9. Use django.utils.lru_cache instead.",   RemovedInDjango19Warning and stacklevel set to integer 2.   decorator function wraps with an argument func.
  define the function wrapper with an argument unpacked list args.
  mem_args is a list containing of first num_args elements of args list.
  if mem_args is contained in cache,
  get the value under the mem_args key of the cache dictionary, return it.
  call the function func with an argument unpacked list args, substitute the result for result.
  substitute result for value under the mem_args key of the cache dictionary.
<annotation_end_b>#<body_start> warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
  @ wraps ( func )
 def wrapper ( * args ) :
          mem_args = args [ : num_args ]
 if mem_args in cache :
              return cache [ mem_args ]
  result = func ( * args )
 cache [ mem_args ] = result
<body_end><annotation_start_b>  do nothing.
  define the method item_attributes with 2 arguments self and item.
  return an empty dictionary.
  define the method add_item_elements with 2 arguments, handler self and item.
  do nothing.
  define the method write with 3 arguments self, outfile and encoding.
  raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
  define the method writeString with 2 arguments self and encoding.
  s is an instance of StringIO class.
  call the method self.write with 2 arguments: s and encoding.
  call the method s.getvalue, return the result.
  define the method latest_post_date with an argument self.
  latest_date is None.
  date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
  for every item in self.items,
  for every date_key in date_keys,
  get the value under the date_key key of the item dictionary, substitute it for item_date.
  if item_date is true,
  if latest_date is None or item_date is greater than latest_date,
  substitute item_date for latest_date.
  if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
  derive the class Enclosure from the object base class.
  define the method __init__ with 4 arguments: self, url, length and mime_type.
  substitute length and mime_type for self.length and self.mime_type.
  call the function iri_to_uri with an argument url, substitute the result for self.url.
  derive the class RssFeed from the SyndicationFeed base class.
  mime_type is a string 'application/rss+xml; charset=utf-8'.
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.date,
  call the method datetime_safe.new_date with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.time,
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'TIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  return value.
  define the function sanitize_separators with an argument value.
  if settings.USE_L10N is true and value is an instance of six.string_types,
  parts is an empty list.
  call the function get_format with an argument string 'DECIMAL_SEPARATOR', substitute the result for decimal_separator.
  if decimal_separator is contained in value,
  split value into two parts by decimal_separator, assign the result to value and decimals.
  append decimals to parts.
  if settings.USE_THOUSAND_SEPARATOR is true,
  call the function get_format with an argument string 'THOUSAND_SEPARATOR', substitute the result for thousand_sep.
  call the function unicodedata.normalize with 2 arguments: string 'NFKD' and thousand_sep, put the result and thousand_sep into a set,
  for every replacement in the resulting set,   replace every occurrence of replacement in value for an empty string, substitute the result for value.
  append value to parts.
  reverse order of parts, join them into a string, separated with '.', substitute the result for value.
  return value.
  import module copy.
  import module opera.
  from functools import wraps into default name space.
  import module sys.
  import module warnings.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.six.moves import copyreg into default name space.
  define the function curry with 3 arguments: _curried_func, unpacked list args and unpacked dictionary kwargs.
  define the function _curried with 2 arguments: unpacked list moreargs and unpacked dictionary morekwargs.
  call the function _curried_func with 2 arguments: list moreargs appended to args and unpacked,
  unpacked dictionary created with elements of morekwargs dictionary through the kwargs mapping, return the result.   return _curried.
  define the function memoize with 3 arguments: func, cache and num_args.
  call the function warnings.warn with 3 arguments:
  string "memoize wrapper is deprecated and will be removed in Django 1.9. Use django.utils.lru_cache instead.",   RemovedInDjango19Warning and stacklevel set to integer 2.   decorator function wraps with an argument func.
  define the function wrapper with an argument unpacked list args.
  mem_args is a list containing of first num_args elements of args list.
  if mem_args is contained in cache,
  get the value under the mem_args key of the cache dictionary, return it.
  call the function func with an argument unpacked list args, substitute the result for result.
  substitute result for value under the mem_args key of the cache dictionary.
  return result.
<annotation_end_b>#<body_start> pass
   def item_attributes ( self , item ) :
 return { }
   def add_item_elements ( self , handler , item ) :
 pass
   def write ( self , outfile , encoding ) :
 raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
   def writeString ( self , encoding ) :
 s = StringIO ( )
 self . write ( s , encoding )
 return s . getvalue ( )
   def latest_post_date ( self ) :
 latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
      return latest_date or datetime . datetime . now ( )
     class Enclosure ( object ) :
 def __init__ ( self , url , length , mime_type ) :
 self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . time ) :
          format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  return value
    def sanitize_separators ( value ) :
 if settings . USE_L10N and isinstance ( value , six . string_types ) :
          parts = [ ]
 decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )
 if decimal_separator in value :
              value , decimals = value . split ( decimal_separator , 1 )
 parts . append ( decimals )
  if settings . USE_THOUSAND_SEPARATOR :
              thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )
 for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :
                  value = value . replace ( replacement , '' )
   parts . append ( value )
 value = '.' . join ( reversed ( parts ) )
  return value
import copy
 import operator
 from functools import wraps
 import sys
 import warnings
  from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . six . moves import copyreg
      def curry ( _curried_func , * args , ** kwargs ) :
      def _curried ( * moreargs , ** morekwargs ) :
          return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
  return _curried
    def memoize ( func , cache , num_args ) :
 warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
  @ wraps ( func )
 def wrapper ( * args ) :
          mem_args = args [ : num_args ]
 if mem_args in cache :
              return cache [ mem_args ]
  result = func ( * args )
 cache [ mem_args ] = result
 return result
<body_end><annotation_start_b>  if instance is None,
<annotation_end_b>#<body_start>          if instance is None :
<body_end><annotation_start_b>  substitute func for self.func.
  if name is true, substitute it for self.name, otherwise substitute func.__name__ for self.name.
  define the method __get__ with 3 arguments: self, instance and name type to None.
  if instance is None,
  return self.
  call the function self.func with an argument instance, substitute the result for res and value under the self.name key of the instance.__dict__ dictionary.
<annotation_end_b>#<body_start>          self . func = func
 self . name = name or func . __name__
   def __get__ ( self , instance , type = None ) :
          if instance is None :
              return self
  res = instance . __dict__ [ self . name ] = self . func ( instance )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  cls.__dispatch is an empty dictionary.
  for every resultclass in resultclasses,
  value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
  call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
  for every k and v in result of the call to the method type_.__dict__.items,
  call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
  if cls has an attribute k,
  skip this loop iteration,
  set k attribute of cls object to meth.
  if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
  if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
<annotation_end_b>#<body_start>              cls . __dispatch = { }
 for resultclass in resultclasses :
                  cls . __dispatch [ resultclass ] = { }
 for type_ in reversed ( resultclass . mro ( ) ) :
                      for ( k , v ) in type_ . __dict__ . items ( ) :
                             meth = cls . __promise__ ( resultclass , k , v )
 if hasattr ( cls , k ) :
                              continue
  setattr ( cls , k , meth )
    cls . _delegate_bytes = bytes in resultclasses
 cls . _delegate_text = six . text_type in resultclasses
<body_end><annotation_start_b>  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
  get the type of res, call the method mro on the result, for every t in the result,
  if t is contained in self.__dispatch,
<annotation_end_b>#<body_start>                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
<body_end><annotation_start_b>  define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
  get the type of res, call the method mro on the result, for every t in the result,
  if t is contained in self.__dispatch,
  get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
<annotation_end_b>#<body_start>                def __wrapper__ ( self , * args , ** kw ) :
                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
                          return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
<body_end><annotation_start_b>  substitute args for self.__args.
  substitute kw for self.__kw.
  if self.__dispatch is None.
  call the method self.__prepare_class__.
  define the method __reduce__ with an argument self.
  return a tuple wit 2 elements: _lazy_proxy_unpickle and tuple with 3 elements: func, self.__args, self.__kw and resultclasses.
  classmethod decorator,
  define the method __prepare_class__ with an argument self.
  cls.__dispatch is an empty dictionary.
  for every resultclass in resultclasses,
  value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
  call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
  for every k and v in result of the call to the method type_.__dict__.items,
  call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
  if cls has an attribute k,
  skip this loop iteration,
  set k attribute of cls object to meth.
  if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
  if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
  if cls._delegate_bytes and cls._delegate_text are both false, raise an error, with an argument string "Cannot call lazy() with both bytes and text return types.".
  if cls._delegate_text is true,
  if six.PY3 is true,
  substitute cls.__text_cast for cls.__str__.
  if not,
  substitute cls.__text_cast for cls.__text_cast.
  otherwise if cls._delegate_bytes is true,
  if six.PY3 is true,
  substitute cls.__bytes_cast for cls.__bytes__.
  if not,
  substitute cls.__bytes_cast for cls.__str__.
  class method decorator,
  define the method __promise__ with 4 arguments: cls, klass, funcname and method.
  define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
  get the type of res, call the method mro on the result, for every t in the result,
  if t is contained in self.__dispatch,
  get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
  unpacked list args and unpacked dictionary kw, return the result.   raise an TypeError exception with an argument sting "Lazy object returned unexpected type.".
  if klass is not contained in cls.__dispatch,
  value under the klass key of the cls.__dispatch dictionary is an empty dictionary.
  substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch dictionary.
<annotation_end_b>#<body_start>              self . __args = args
 self . __kw = kw
 if self . __dispatch is None :
                  self . __prepare_class__ ( )
    def __reduce__ ( self ) :
              return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
   @ classmethod
 def __prepare_class__ ( cls ) :
              cls . __dispatch = { }
 for resultclass in resultclasses :
                  cls . __dispatch [ resultclass ] = { }
 for type_ in reversed ( resultclass . mro ( ) ) :
                      for ( k , v ) in type_ . __dict__ . items ( ) :
                             meth = cls . __promise__ ( resultclass , k , v )
 if hasattr ( cls , k ) :
                              continue
  setattr ( cls , k , meth )
    cls . _delegate_bytes = bytes in resultclasses
 cls . _delegate_text = six . text_type in resultclasses
 assert not ( cls . _delegate_bytes and cls . _delegate_text ) , "Cannot call lazy() with both bytes and text return types."
 if cls . _delegate_text :
                  if six . PY3 :
                      cls . __str__ = cls . __text_cast
  else :
                      cls . __unicode__ = cls . __text_cast
   elif cls . _delegate_bytes :
                  if six . PY3 :
                      cls . __bytes__ = cls . __bytes_cast
  else :
                      cls . __str__ = cls . __bytes_cast
     @ classmethod
 def __promise__ ( cls , klass , funcname , method ) :
                def __wrapper__ ( self , * args , ** kw ) :
                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
                          return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
   raise TypeError ( "Lazy object returned unexpected type." )
   if klass not in cls . __dispatch :
                  cls . __dispatch [ klass ] = { }
  cls . __dispatch [ klass ] [ funcname ] = method
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self._delegate_bytes is true,
<annotation_end_b>#<body_start>              if self . _delegate_bytes :
<body_end><annotation_start_b>  decorator total_ordering,
  derive the class __proxy__ from the Promise base class.
  __dispatch is None.
  define the method __init__ with 3 arguments: self, args and kw.
  substitute args for self.__args.
  substitute kw for self.__kw.
  if self.__dispatch is None.
  call the method self.__prepare_class__.
  define the method __reduce__ with an argument self.
  return a tuple wit 2 elements: _lazy_proxy_unpickle and tuple with 3 elements: func, self.__args, self.__kw and resultclasses.
  classmethod decorator,
  define the method __prepare_class__ with an argument self.
  cls.__dispatch is an empty dictionary.
  for every resultclass in resultclasses,
  value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
  call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
  for every k and v in result of the call to the method type_.__dict__.items,
  call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
  if cls has an attribute k,
  skip this loop iteration,
  set k attribute of cls object to meth.
  if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
  if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
  if cls._delegate_bytes and cls._delegate_text are both false, raise an error, with an argument string "Cannot call lazy() with both bytes and text return types.".
  if cls._delegate_text is true,
  if six.PY3 is true,
  substitute cls.__text_cast for cls.__str__.
  if not,
  substitute cls.__text_cast for cls.__text_cast.
  otherwise if cls._delegate_bytes is true,
  if six.PY3 is true,
  substitute cls.__bytes_cast for cls.__bytes__.
  if not,
  substitute cls.__bytes_cast for cls.__str__.
  class method decorator,
  define the method __promise__ with 4 arguments: cls, klass, funcname and method.
  define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
  get the type of res, call the method mro on the result, for every t in the result,
  if t is contained in self.__dispatch,
  get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
  unpacked list args and unpacked dictionary kw, return the result.   raise an TypeError exception with an argument sting "Lazy object returned unexpected type.".
  if klass is not contained in cls.__dispatch,
  value under the klass key of the cls.__dispatch dictionary is an empty dictionary.
  substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch dictionary.
  return __wrapper__.
  define the method __text_cast with an argument self.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
  define the method __bytes_cast with an argument self.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw,
  use the result as an argument for the call to the function bytes, return the result.   define the method __cast with an argument self.
  if self._delegate_bytes is true,
  call the method self.__bytes_cast, return the result.
  otherwise if self._delegate_text is true,
<annotation_end_b>#<body_start>  @ total_ordering
 class __proxy__ ( Promise ) :
 __dispatch = None
  def __init__ ( self , args , kw ) :
              self . __args = args
 self . __kw = kw
 if self . __dispatch is None :
                  self . __prepare_class__ ( )
    def __reduce__ ( self ) :
              return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
   @ classmethod
 def __prepare_class__ ( cls ) :
              cls . __dispatch = { }
 for resultclass in resultclasses :
                  cls . __dispatch [ resultclass ] = { }
 for type_ in reversed ( resultclass . mro ( ) ) :
                      for ( k , v ) in type_ . __dict__ . items ( ) :
                             meth = cls . __promise__ ( resultclass , k , v )
 if hasattr ( cls , k ) :
                              continue
  setattr ( cls , k , meth )
    cls . _delegate_bytes = bytes in resultclasses
 cls . _delegate_text = six . text_type in resultclasses
 assert not ( cls . _delegate_bytes and cls . _delegate_text ) , "Cannot call lazy() with both bytes and text return types."
 if cls . _delegate_text :
                  if six . PY3 :
                      cls . __str__ = cls . __text_cast
  else :
                      cls . __unicode__ = cls . __text_cast
   elif cls . _delegate_bytes :
                  if six . PY3 :
                      cls . __bytes__ = cls . __bytes_cast
  else :
                      cls . __str__ = cls . __bytes_cast
     @ classmethod
 def __promise__ ( cls , klass , funcname , method ) :
                def __wrapper__ ( self , * args , ** kw ) :
                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
                          return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
   raise TypeError ( "Lazy object returned unexpected type." )
   if klass not in cls . __dispatch :
                  cls . __dispatch [ klass ] = { }
  cls . __dispatch [ klass ] [ funcname ] = method
 return __wrapper__
   def __text_cast ( self ) :
              return func ( * self . __args , ** self . __kw )
   def __bytes_cast ( self ) :
              return bytes ( func ( * self . __args , ** self . __kw ) )
   def __cast ( self ) :
              if self . _delegate_bytes :
                  return self . __bytes_cast ( )
  elif self . _delegate_text :
<body_end><annotation_start_b>  to_unicode is an lambda function with an argument s, result is the result of the function force_text,
  called with 2 arguments: s and string_only as boolean True.   if categories is true,
  categories is a list containing the results of the function to_unicode, called with an argument c, for every c in categories.
  if ttl is not None,
  call the function force_text with an argument ttl, substitute the result for ttl.
  item is a dictionary with 15 initial entries: result of the function to_unicode called with an argument title for 'title',
  result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument author_email for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an author_link link for 'author_link', pubdate for 'pubdate',   updateddate for 'updateddate', result of the function to_unicode called with an comments author_name for 'comments',   result of the function to_unicode called with an argument unique_id) for 'unique_id)',   unique_id_is_permalink for 'unique_id_is_permalink', enclosure for 'enclosure',    if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function to_unicode called with an argument item_copyright for 'item_copyright', ttl for 'ttl'.   update dictionary item with an argument kwargs.
  append item to self.items.
  define the method num_items with an argument self.
  return length of self.items.
  define the method root_attributes with an argument self.
  return an empty dictionary.
  define the method add_root_elements with 2 arguments self and handler.
  do nothing.
  define the method item_attributes with 2 arguments self and item.
  return an empty dictionary.
  define the method add_item_elements with 2 arguments, handler self and item.
  do nothing.
  define the method write with 3 arguments self, outfile and encoding.
  raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
  define the method writeString with 2 arguments self and encoding.
  s is an instance of StringIO class.
  call the method self.write with 2 arguments: s and encoding.
  call the method s.getvalue, return the result.
  define the method latest_post_date with an argument self.
  latest_date is None.
  date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
  for every item in self.items,
  for every date_key in date_keys,
  get the value under the date_key key of the item dictionary, substitute it for item_date.
  if item_date is true,
  if latest_date is None or item_date is greater than latest_date,
  substitute item_date for latest_date.
  if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
  derive the class Enclosure from the object base class.
  define the method __init__ with 4 arguments: self, url, length and mime_type.
  substitute length and mime_type for self.length and self.mime_type.
  call the function iri_to_uri with an argument url, substitute the result for self.url.
  derive the class RssFeed from the SyndicationFeed base class.
  mime_type is a string 'application/rss+xml; charset=utf-8'.
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.date,
  call the method datetime_safe.new_date with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.time,
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'TIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  return value.
  define the function sanitize_separators with an argument value.
  if settings.USE_L10N is true and value is an instance of six.string_types,
  parts is an empty list.
  call the function get_format with an argument string 'DECIMAL_SEPARATOR', substitute the result for decimal_separator.
  if decimal_separator is contained in value,
  split value into two parts by decimal_separator, assign the result to value and decimals.
  append decimals to parts.
  if settings.USE_THOUSAND_SEPARATOR is true,
  call the function get_format with an argument string 'THOUSAND_SEPARATOR', substitute the result for thousand_sep.
  call the function unicodedata.normalize with 2 arguments: string 'NFKD' and thousand_sep, put the result and thousand_sep into a set,
  for every replacement in the resulting set,   replace every occurrence of replacement in value for an empty string, substitute the result for value.
  append value to parts.
  reverse order of parts, join them into a string, separated with '.', substitute the result for value.
  return value.
  import module copy.
  import module opera.
  from functools import wraps into default name space.
  import module sys.
  import module warnings.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.six.moves import copyreg into default name space.
  define the function curry with 3 arguments: _curried_func, unpacked list args and unpacked dictionary kwargs.
  define the function _curried with 2 arguments: unpacked list moreargs and unpacked dictionary morekwargs.
  call the function _curried_func with 2 arguments: list moreargs appended to args and unpacked,
  unpacked dictionary created with elements of morekwargs dictionary through the kwargs mapping, return the result.   return _curried.
  define the function memoize with 3 arguments: func, cache and num_args.
  call the function warnings.warn with 3 arguments:
  string "memoize wrapper is deprecated and will be removed in Django 1.9. Use django.utils.lru_cache instead.",   RemovedInDjango19Warning and stacklevel set to integer 2.   decorator function wraps with an argument func.
  define the function wrapper with an argument unpacked list args.
  mem_args is a list containing of first num_args elements of args list.
  if mem_args is contained in cache,
  get the value under the mem_args key of the cache dictionary, return it.
  call the function func with an argument unpacked list args, substitute the result for result.
  substitute result for value under the mem_args key of the cache dictionary.
  return result.
  return wrapper.
  derive the class cached_property from the object base class.
  define the method __init__ with 3 arguments: self, func and name set to None.
  substitute func for self.func.
  if name is true, substitute it for self.name, otherwise substitute func.__name__ for self.name.
  define the method __get__ with 3 arguments: self, instance and name type to None.
  if instance is None,
  return self.
  call the function self.func with an argument instance, substitute the result for res and value under the self.name key of the instance.__dict__ dictionary.
  return res.
  derive the class Promise from the object base class.
  do nothing.
 define the function lazy with 2 arguments: func and unpacked list resultclasses.
  decorator total_ordering,
  derive the class __proxy__ from the Promise base class.
  __dispatch is None.
  define the method __init__ with 3 arguments: self, args and kw.
  substitute args for self.__args.
  substitute kw for self.__kw.
  if self.__dispatch is None.
  call the method self.__prepare_class__.
  define the method __reduce__ with an argument self.
  return a tuple wit 2 elements: _lazy_proxy_unpickle and tuple with 3 elements: func, self.__args, self.__kw and resultclasses.
  classmethod decorator,
  define the method __prepare_class__ with an argument self.
  cls.__dispatch is an empty dictionary.
  for every resultclass in resultclasses,
  value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
  call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
  for every k and v in result of the call to the method type_.__dict__.items,
  call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
  if cls has an attribute k,
  skip this loop iteration,
  set k attribute of cls object to meth.
  if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
  if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
  if cls._delegate_bytes and cls._delegate_text are both false, raise an error, with an argument string "Cannot call lazy() with both bytes and text return types.".
  if cls._delegate_text is true,
  if six.PY3 is true,
  substitute cls.__text_cast for cls.__str__.
  if not,
  substitute cls.__text_cast for cls.__text_cast.
  otherwise if cls._delegate_bytes is true,
  if six.PY3 is true,
  substitute cls.__bytes_cast for cls.__bytes__.
  if not,
  substitute cls.__bytes_cast for cls.__str__.
  class method decorator,
  define the method __promise__ with 4 arguments: cls, klass, funcname and method.
  define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
  get the type of res, call the method mro on the result, for every t in the result,
  if t is contained in self.__dispatch,
  get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
  unpacked list args and unpacked dictionary kw, return the result.   raise an TypeError exception with an argument sting "Lazy object returned unexpected type.".
  if klass is not contained in cls.__dispatch,
  value under the klass key of the cls.__dispatch dictionary is an empty dictionary.
  substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch dictionary.
  return __wrapper__.
  define the method __text_cast with an argument self.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
  define the method __bytes_cast with an argument self.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw,
  use the result as an argument for the call to the function bytes, return the result.   define the method __cast with an argument self.
  if self._delegate_bytes is true,
  call the method self.__bytes_cast, return the result.
  otherwise if self._delegate_text is true,
  call the method self.__text_cast, return the result.
  if not,
<annotation_end_b>#<body_start> to_unicode = lambda s : force_text ( s , strings_only = True )
 if categories :
              categories = [ ( c ) for c in categories ]
  if ttl is not None :
               ttl = force_text ( ttl )
  item = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'pubdate' : pubdate ,  'updateddate' : updateddate ,  'comments' : to_unicode ( comments ) ,  'unique_id' : to_unicode ( unique_id ) ,  'unique_id_is_permalink' : unique_id_is_permalink ,  'enclosure' : enclosure ,  'categories' : categories or ( ) ,  'item_copyright' : to_unicode ( item_copyright ) ,  'ttl' : ttl ,  }
 item . update ( kwargs )
 self . items . append ( item )
   def num_items ( self ) :
          return len ( self . items )
   def root_attributes ( self ) :
 return { }
   def add_root_elements ( self , handler ) :
 pass
   def item_attributes ( self , item ) :
 return { }
   def add_item_elements ( self , handler , item ) :
 pass
   def write ( self , outfile , encoding ) :
 raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
   def writeString ( self , encoding ) :
 s = StringIO ( )
 self . write ( s , encoding )
 return s . getvalue ( )
   def latest_post_date ( self ) :
 latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
      return latest_date or datetime . datetime . now ( )
     class Enclosure ( object ) :
 def __init__ ( self , url , length , mime_type ) :
 self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . time ) :
          format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  return value
    def sanitize_separators ( value ) :
 if settings . USE_L10N and isinstance ( value , six . string_types ) :
          parts = [ ]
 decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )
 if decimal_separator in value :
              value , decimals = value . split ( decimal_separator , 1 )
 parts . append ( decimals )
  if settings . USE_THOUSAND_SEPARATOR :
              thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )
 for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :
                  value = value . replace ( replacement , '' )
   parts . append ( value )
 value = '.' . join ( reversed ( parts ) )
  return value
import copy
 import operator
 from functools import wraps
 import sys
 import warnings
  from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . six . moves import copyreg
      def curry ( _curried_func , * args , ** kwargs ) :
      def _curried ( * moreargs , ** morekwargs ) :
          return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
  return _curried
    def memoize ( func , cache , num_args ) :
 warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
  @ wraps ( func )
 def wrapper ( * args ) :
          mem_args = args [ : num_args ]
 if mem_args in cache :
              return cache [ mem_args ]
  result = func ( * args )
 cache [ mem_args ] = result
 return result
  return wrapper
    class cached_property ( object ) :
 def __init__ ( self , func , name = None ) :
          self . func = func
 self . name = name or func . __name__
   def __get__ ( self , instance , type = None ) :
          if instance is None :
              return self
  res = instance . __dict__ [ self . name ] = self . func ( instance )
 return res
     class Promise ( object ) :
 pass
    def lazy ( func , * resultclasses ) :
  @ total_ordering
 class __proxy__ ( Promise ) :
 __dispatch = None
  def __init__ ( self , args , kw ) :
              self . __args = args
 self . __kw = kw
 if self . __dispatch is None :
                  self . __prepare_class__ ( )
    def __reduce__ ( self ) :
              return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
   @ classmethod
 def __prepare_class__ ( cls ) :
              cls . __dispatch = { }
 for resultclass in resultclasses :
                  cls . __dispatch [ resultclass ] = { }
 for type_ in reversed ( resultclass . mro ( ) ) :
                      for ( k , v ) in type_ . __dict__ . items ( ) :
                             meth = cls . __promise__ ( resultclass , k , v )
 if hasattr ( cls , k ) :
                              continue
  setattr ( cls , k , meth )
    cls . _delegate_bytes = bytes in resultclasses
 cls . _delegate_text = six . text_type in resultclasses
 assert not ( cls . _delegate_bytes and cls . _delegate_text ) , "Cannot call lazy() with both bytes and text return types."
 if cls . _delegate_text :
                  if six . PY3 :
                      cls . __str__ = cls . __text_cast
  else :
                      cls . __unicode__ = cls . __text_cast
   elif cls . _delegate_bytes :
                  if six . PY3 :
                      cls . __bytes__ = cls . __bytes_cast
  else :
                      cls . __str__ = cls . __bytes_cast
     @ classmethod
 def __promise__ ( cls , klass , funcname , method ) :
                def __wrapper__ ( self , * args , ** kw ) :
                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
                          return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
   raise TypeError ( "Lazy object returned unexpected type." )
   if klass not in cls . __dispatch :
                  cls . __dispatch [ klass ] = { }
  cls . __dispatch [ klass ] [ funcname ] = method
 return __wrapper__
   def __text_cast ( self ) :
              return func ( * self . __args , ** self . __kw )
   def __bytes_cast ( self ) :
              return bytes ( func ( * self . __args , ** self . __kw ) )
   def __cast ( self ) :
              if self . _delegate_bytes :
                  return self . __bytes_cast ( )
  elif self . _delegate_text :
                  return self . __text_cast ( )
  else :
<body_end><annotation_start_b>  if other is an instance of Promise class,
  call the method other.__cast, substitute the result for other.
<annotation_end_b>#<body_start>              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
<body_end><annotation_start_b>  if other is an instance of Promise class,
  call the method other.__cast, substitute the result for other.
<annotation_end_b>#<body_start>              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
<body_end><annotation_start_b>  if other is an instance of Promise,
  call the method other.__cast, substitute the result for other.
<annotation_end_b>#<body_start>              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if self._delegate_bytes and six.PY2 are both true,
<annotation_end_b>#<body_start>              if self . _delegate_bytes and six . PY2 :
<body_end><annotation_start_b>  author_name set to None, author_link set to None, subtitle set to None, categories set to None, feed_url set to None,   feed_copyright set to None, feed_guid set to None, ttl set to None and unpacked dictionary kwargs.   to_unicode is an lambda function with an argument s, result is the result of the function force_text,
  called with 2 arguments: s and string_only as boolean True.   if categories is true,
  categories is a list containing the results of the function force_text, called with an argument c, for every c in categories.
  if ttl is not None,
  call the function force_text with an argument ttl, substitute the result for ttl.
  self.feed is an dictionary with 13 initial entries, result of the function to_unicode called with an argument title for 'title',
  result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument language for 'language',   result of the function to_unicode called with an author_email description for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an argument author_link for 'author_link',   result of the function to_unicode called with an argument subtitle for 'subtitle',   if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function iri_to_uri called with an argument feed_url for 'feed_url',   result of the function to_unicode called with an argument feed_copyright for 'feed_copyright',   if true, feed_guid is value for 'id' key, if not, lik is value for 'id' key and ttl for 'ttl'.   update self.feed dictionary with kwargs.
  self.items is an empty list.
  define the method add_item with 17 arguments: self, title, link, description, author_email set to None, author_name set to None,
  to_unicode is an lambda function with an argument s, result is the result of the function force_text,
  called with 2 arguments: s and string_only as boolean True.   if categories is true,
  categories is a list containing the results of the function to_unicode, called with an argument c, for every c in categories.
  if ttl is not None,
  call the function force_text with an argument ttl, substitute the result for ttl.
  item is a dictionary with 15 initial entries: result of the function to_unicode called with an argument title for 'title',
  result of the function iri_to_uri called with an argument link for 'link',   result of the function to_unicode called with an argument description for 'description',   result of the function to_unicode called with an argument author_email for 'author_email',   result of the function to_unicode called with an argument author_name for 'author_name',   result of the function iri_to_uri called with an author_link link for 'author_link', pubdate for 'pubdate',   updateddate for 'updateddate', result of the function to_unicode called with an comments author_name for 'comments',   result of the function to_unicode called with an argument unique_id) for 'unique_id)',   unique_id_is_permalink for 'unique_id_is_permalink', enclosure for 'enclosure',    if true, categories is value for 'categories' key, if not, empty tuple is value for 'categories' key,   result of the function to_unicode called with an argument item_copyright for 'item_copyright', ttl for 'ttl'.   update dictionary item with an argument kwargs.
  append item to self.items.
  define the method num_items with an argument self.
  return length of self.items.
  define the method root_attributes with an argument self.
  return an empty dictionary.
  define the method add_root_elements with 2 arguments self and handler.
  do nothing.
  define the method item_attributes with 2 arguments self and item.
  return an empty dictionary.
  define the method add_item_elements with 2 arguments, handler self and item.
  do nothing.
  define the method write with 3 arguments self, outfile and encoding.
  raise an NotImplementedError with an argument string 'subclasses of SyndicationFeed must provide a write() method'.
  define the method writeString with 2 arguments self and encoding.
  s is an instance of StringIO class.
  call the method self.write with 2 arguments: s and encoding.
  call the method s.getvalue, return the result.
  define the method latest_post_date with an argument self.
  latest_date is None.
  date_keys is a tuple with 2 arguments: strings 'updateddate' and 'pubdate'.
  for every item in self.items,
  for every date_key in date_keys,
  get the value under the date_key key of the item dictionary, substitute it for item_date.
  if item_date is true,
  if latest_date is None or item_date is greater than latest_date,
  substitute item_date for latest_date.
  if latest_date is true, return it, if not, call the method datetime.datetime.now and return the result.
  derive the class Enclosure from the object base class.
  define the method __init__ with 4 arguments: self, url, length and mime_type.
  substitute length and mime_type for self.length and self.mime_type.
  call the function iri_to_uri with an argument url, substitute the result for self.url.
  derive the class RssFeed from the SyndicationFeed base class.
  mime_type is a string 'application/rss+xml; charset=utf-8'.
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string "rss" and result of the method self.rss_attributes.
  call the method handler.startElement with 2 arguments: string "channel" and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method self.endChannelElement with an argument handler.
  call the method handler.endElement with an argument string 'rss'.
  define the method rss_attributes with an argument self.
  return a dictionary with 2 elements: self._version for "version" and "http://www.w3.org/2005/Atom" for "xmlns:atom".
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string "item" and result of the method self.item_attributes with an argument item.
  call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'item'.
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the self.feed dictionary.
  if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'atom:link', None and dictionary with 2 entries: 'self' for 'rel',
  value under the 'feed_url' key of the self.feed dictionary for 'href'.   if value under the 'language' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'language' and value under the 'language' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string "category" and cat.
  if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'copyright' and value under the 'feed_copyright' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'lastBuildDate' and result of the function rfc2822_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'ttl' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the self.feed dictionary.
  define the method endChannelElement with 2 arguments: self and handler.
  call the method handler.endElement with an argument string 'channel'.
  derive the class RssUserland091Feed from the RssFeed base class.
  _version is a string "0.91".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of item dictionary.
  derive the class Rss201rev2Feed from the RssFeed base class.
  _version is a string "2.0".
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'link' and value under the 'link' key of the item dictionary.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'description' and value under the 'description' key of the item dictionary.
  if values under "author_name" and "author_email" keys of the item dictionary are both true,
  call the method handler.addQuickElement with an argument string "author", "%s (%s)",
  formated with values under the 'author_email' and 'author_name' keys of item dictionary.   otherwise if value under the "author_email" key of the item dictionary is true,
  call the method handler.addQuickElement with 2 arguments: string 'author' and value under the 'author_email' key of the item dictionary.
  otherwise if value under the "author_name" key of the item dictionary is true,
  call the method handler.addQuickElement with 3 arguments: string 'dc:creator',
  value under the 'author_name' key of the item dictionary and dictionary with an entry: "http://purl.org/dc/elements/1.1/" for "xmlns:dc".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'pubDate' and result of the function rfc2822_date,
  called with value under the 'pubdate' key of the item dictionary.   if value under the 'comments' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'comments' and value under the 'comments' key of the item dictionary.
  if value under the 'unique_id' key of the item dictionary is not None,
  guid_attrs is an empty dictionary.
  if value object the 'unique_id_is_permalink' key of the item dictionary is an instance of bool type,
  covert to string value under the 'unique_id_is_permalink' key of the item dictionary, convert it to lowercase,
  substitute the result for value under the 'isPermaLink' key of the guid_attrs dictionary.   call the method handler.addQuickElement with 3 arguments: string 'guid', value under the 'unique_id' key of the item dictionary,
  and guid_attrs.   if value under the 'ttl' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'ttl' and value under the 'ttl' key of the item dictionary.
  if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'title', an empty string and a dictionary with 3 entries:
  field url of the value under the 'enclosure' key of the item dictionary for 'url',   field length of the value under the 'enclosure' key of the item dictionary for 'length',   and field mime_type of the value under the 'enclosure' key of the item dictionary for 'type'.   for every cat in value under the 'categories' key of the item dictionary,
  call the method handler.addQuickElement with 2 arguments: string 'category' and cat.
  derive the class Atom1Feed from the SyndicationFeed base class.
  mime_type is a string 'application/atom+xml; charset=utf-8'.
  ns is a string "http://www.w3.org/2005/Atom".
  define the method write with 3 arguments: self, outfile and encoding.
  handler is an instance of SimplerXMLGenerator class, created with 2 arguments: outfile and encoding.
  call the method handler.startDocument.
  call the method handler.startElement with 2 arguments: string 'feed' and result of the method self.root_attributes.
  call the method self.add_root_elements with an argument handler.
  call the method self.write_items with an argument handler.
  call the method handler.endElement with an argument string 'feed'.
  define the method root_attributes with an argument self.
  if value under the 'language' key of the self.feed dictionary is not None,
  return a dictionary with 2 entries: value under the 'language' key of the self.feed dictionary for "xml:lang",
  and self.ns for "xmlns".   if not,
  return a dictionary with an entry: self.ns for "xmlns".
  define the method add_root_elements with 2 arguments: self and handler.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'alternate' for 'rel' and value under the 'link' key of self.feed dictionary for 'href'.   if value under the 'feed_url' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  'self' for 'rel' and value under the 'feed_url' key of self.feed dictionary for 'href'.   call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the self.feed dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument result of the method self.latest_post_date.   if value under the 'author_name' key of the self.feed dictionary is not None,
  call the method handler.startElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the self.feed dictionary.
  if value under the 'author_email' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the self.feed dictionary.
  if value under the 'author_link' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the self.feed dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'subtitle' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'subtitle' and value under the 'subtitle' key of the self.feed dictionary.
  for every cat in value under the 'categories' key of the self.feed dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'category', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'feed_copyright' key of the self.feed dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'feed_copyright' key of the self.feed dictionary.
  define the method write_items with 2 arguments: self and handler.
  for every item in self.items,
  call the method handler.startElement with 2 arguments: string 'entry' and result of the function self.item_attributes,
  called with an argument item.   call the method self.add_item_elements with 2 arguments: handler and item.
  call the method handler.endElement with an argument string 'entry'.
  define the method add_item_elements with 3 arguments: self, handler and item.
  call the method handler.addQuickElement with 2 arguments: string 'title' and value under the 'title' key of the item dictionary.
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 2 entries:
  value under the 'link' key of item dictionary for 'href' and "alternate" for "rel".   if value under the 'pubdate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'published' and result of the function rfc3339_date,
  called with an argument value under the 'pubdate' key of the item dictionary.   if value under the 'updateddate' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'updated' and result of the function rfc3339_date,
  called with an argument value under the 'updateddate' key of the item dictionary.   if value under the 'author_name' key of the item dictionary is not None,
  call the method handler.endElement with 2 arguments: string 'author' and an empty dictionary.
  call the method handler.addQuickElement with 2 arguments: string 'name' and value under the 'author_name' key of the item dictionary.
  if value under the 'author_email' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'email' and value under the 'author_email' key of the item dictionary.
  if value under the 'author_link' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'uri' and value under the 'author_link' key of the item dictionary.
  call the method handler.endElement with an argument string 'author'.
  if value under the 'unique_id' key of the item dictionary is not None,
  substitute value under 'unique_id' key of item dictionary for unique_id.
  if not,
  call the function get_tag_uri with 2 arguments: values under 'link' and 'pubdate' keys of item dictionary, substitute the result for unique_id.
  call the method handler.addQuickElement with 2 arguments: string 'id' and unique_id.
  if value under the 'description' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'summary', value under the 'description' key of item dictionary,
  and dictionary with an entry: 'html' for 'type'.   if value under the 'enclosure' key of the item dictionary is not None,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with 4 entries:
  "enclosure" for 'rel', field url of value under the "enclosure" key of item dictionary for 'href',   field length of value under the "enclosure" key of item dictionary for 'length',   and field mime_type of value under the "enclosure" key of item dictionary for 'type'.   for every cat in value under 'categories' key of item dictionary,
  call the method handler.addQuickElement with 3 arguments: string 'link', an empty string and a dictionary with an entry:
  cat for 'term'.   if value under the 'item_copyright' key of the item dictionary is not None,
  call the method handler.addQuickElement with 2 arguments: string 'rights' and value under the 'item_copyright' key of the item dictionary.
  substitute Rss201rev2Feed for DefaultFeed.
  from __future__ import absolute_ into default name space.
  import module decimal.
  import module datetime.
  from importlib import import_module into default name space.
  import module unicodedata.
  from django.conf import settings into default name space.
  from django.utils import dateformat, numberformat and datetime_safe into default name space.
  from django.utils.encoding import force_str into default name space.
  from django.utils.functional import lazy into default name space.
  from django.utils.safestring import mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.translation import get_language, to_locale and check_for_language into default name space.
  _format_cache is an empty dictionary.
 _format_modules_cache is an empty dictionary.
  ISO_INPUT_FORMATS is a dictionary with 3 entries: tuple with an element string '%Y-%m-%d' for 'DATE_INPUT_FORMATS',
  tuple with 3 elements: strings '%H:%M:%S', '%H:%M:%S.%f' and '%H:%M' for 'TIME_INPUT_FORMATS',   tuple with 4 elements: strings '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M' and '%Y-%m-%d' for 'DATETIME_INPUT_FORMATS'.   define the function reset_format_cache.
  use global variables _format_cache and _format_modules_cache.
  _format_cache is an empty dictionary.
  _format_modules_cache is an empty dictionary.
  define the function iter_format_modules with 2 arguments: lang and format_module_path set to None.
  call the function check_for_language with an argument lang, if it evaluates to false,
  return nothing.
  if format_module_path is None.
  substitute settings.FORMAT_MODULE_PATH for settings.FORMAT_MODULE_PATH.
  format_locations is an empty list.
  if format_module_path is true,
  if format_module_path is an instance of six.string_types,
  format_module_path is a list containing an element format_module_path.
  for every path in format_module_path,
  concatenate path and string '.%s', append the result to format_module_path.
  append string 'django.conf.locale.%s' to format_locations.
  call the function to_locale with an argument lang, substitute the result for locale.
  locales is a list with an element locale.
  if '_' is contained in locale,
  split locale by '_', append the first element of the result to locales.
  for every location in format_locations,
  for every loc in locales,
  try,
  call the function import_module with an argument string '%s.formats' formated with location, which is formated with loc,
  yield the result.   if ImportError exception is caught,
  do nothing.
  define the function get_format_modules with 2 arguments: lang set to None and reverse set to boolean False.
  if lang is None,
  call the function get_language, substitute the result for lang.
  call the method _format_modules_cache.setdefault with 2 arguments: lang and list created out of the results of the function,
  iter_format_modules called with 2 arguments: lang and settings.FORMAT_MODULE_PATH, substitute the result for modules.   if reverse is true,
  reverse the order of modules elements, put them into a list, return it.
  return modules.s
  define the function get_format with 3 arguments: format_type, lang set to None and use_l10n set to None.
  call the function force_str with an argument format_type, substitute the result for format_type.
  if use_l10n is true, or if use_l10n is None and settings.USE_L10N is true,
  if lang is None,
  call the function get_language, substitute the result for lang.
  cache_key is a tuple with 2 argumetns: format_type and lang.
  try,
  substitute value under the cache_key key of the _format_cache dictionary for cached.
  if cached is not None,
  return cached.
  if not,
  get format_type attribute of the settings object, return it.
  if KeyError exception is caught,
  call the function get_format_modules with an argument lang, for every module in the result,
  try,
  get format_type attribute of module object, substitute the result for val.
  get the value under the if iso_input not in val key of the ISO_INPUT_FORMATS dictionary, if it doesnt exists return an empty tuple,
  for every iso_input in the result,   if iso_input is not contained in val,
  if val is an instance of tuple,
  convert val to an list, substitute it for val.
  append iso_input to val.
  substitute val for the value under the cache_key key of the _format_cache dictionary.
  return val.
  if AttributeError exception is caught,
  do nothing.
  value under the cache_key key of the _format_cache dictionary is None.
  get format_type attribute of the settings object, return it.
  call the function lazy with 4 arguments: get_format, six.text_type, list and tuple, substitute the result for get_format_lazy.
  define the function date_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'DATE_FORMAT' and use_l10n as use_l10n, return the result.   define the function time_format with 3 arguments: value, format set to None and use_l10n set to None.
  call the function dateformat.time_format with 2 arguments: value and result of the function get_format called with 2 arguments:
  format, if its true, otherwise string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.   define the function number_format with 4 arguments: value, decimal_pos set to None, use_l10n set to None,
  if use_l10n is true, or use_l10n is None and settings.USE_L10N is true,
  call the function get_language, substitute the result for lang.
  if not,
  lang is None.
  call the method numberformat.format with 6 arguments: value, result of the function get_format called with 3 arguments:
  string 'DECIMAL_SEPARATOR', lang and use_l10n set to use_l10n, decimal_pos, result of the function get_format called with 3 arguments:   string 'NUMBER_GROUPING', lang and use_l10n as use_l10n, result of the function get_format called with an argument:   string 'THOUSAND_SEPARATOR', lang and use_l10n as use_l10n and force_grouping as force_grouping, return the result.   define the function localize with 2 arguments value and use_l10n set to None.
  if value is an instance of bool.
  call the function six.text_type with an argument value, use the result as an argument for the call to the function mark_safe,
  return the result.   otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with 2 arguments: value and use_l10 as use_l10n, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the function date_format with 2 arguments: value, string 'DATETIME_FORMAT' and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.date,
  call the function date_format with 2 arguments: value and use_l10n as use_l10n, return the result.
  otherwise if value is an instance of datetime.time,
  call the function time_format with 3 arguments: value, string 'TIME_FORMAT' and use_l10n as use_l10n, return the result.
  if not,
  return value.
  define the function localize_input with 2 arguments value and default set to None.
  otherwise if value is an instance of decimal.Decimal, float or six.integer_types,
  call the function number_format with an argument value, return the result.
  otherwise if value is an instance of datetime.datetime,
  call the method datetime_safe.new_datetime with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATETIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.date,
  call the method datetime_safe.new_date with an argument value, substitute the result for value.
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'DATE_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  otherwise if value is an instance of datetime.time,
  call the function force_str with an argument: default if it is true, or if not, first element of the result of the function,
  get_format called with an argument string 'TIME_INPUT_FORMATS', substitute the result for format.   call the method value.strftime with an argument format, return the result.
  return value.
  define the function sanitize_separators with an argument value.
  if settings.USE_L10N is true and value is an instance of six.string_types,
  parts is an empty list.
  call the function get_format with an argument string 'DECIMAL_SEPARATOR', substitute the result for decimal_separator.
  if decimal_separator is contained in value,
  split value into two parts by decimal_separator, assign the result to value and decimals.
  append decimals to parts.
  if settings.USE_THOUSAND_SEPARATOR is true,
  call the function get_format with an argument string 'THOUSAND_SEPARATOR', substitute the result for thousand_sep.
  call the function unicodedata.normalize with 2 arguments: string 'NFKD' and thousand_sep, put the result and thousand_sep into a set,
  for every replacement in the resulting set,   replace every occurrence of replacement in value for an empty string, substitute the result for value.
  append value to parts.
  reverse order of parts, join them into a string, separated with '.', substitute the result for value.
  return value.
  import module copy.
  import module opera.
  from functools import wraps into default name space.
  import module sys.
  import module warnings.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.six.moves import copyreg into default name space.
  define the function curry with 3 arguments: _curried_func, unpacked list args and unpacked dictionary kwargs.
  define the function _curried with 2 arguments: unpacked list moreargs and unpacked dictionary morekwargs.
  call the function _curried_func with 2 arguments: list moreargs appended to args and unpacked,
  unpacked dictionary created with elements of morekwargs dictionary through the kwargs mapping, return the result.   return _curried.
  define the function memoize with 3 arguments: func, cache and num_args.
  call the function warnings.warn with 3 arguments:
  string "memoize wrapper is deprecated and will be removed in Django 1.9. Use django.utils.lru_cache instead.",   RemovedInDjango19Warning and stacklevel set to integer 2.   decorator function wraps with an argument func.
  define the function wrapper with an argument unpacked list args.
  mem_args is a list containing of first num_args elements of args list.
  if mem_args is contained in cache,
  get the value under the mem_args key of the cache dictionary, return it.
  call the function func with an argument unpacked list args, substitute the result for result.
  substitute result for value under the mem_args key of the cache dictionary.
  return result.
  return wrapper.
  derive the class cached_property from the object base class.
  define the method __init__ with 3 arguments: self, func and name set to None.
  substitute func for self.func.
  if name is true, substitute it for self.name, otherwise substitute func.__name__ for self.name.
  define the method __get__ with 3 arguments: self, instance and name type to None.
  if instance is None,
  return self.
  call the function self.func with an argument instance, substitute the result for res and value under the self.name key of the instance.__dict__ dictionary.
  return res.
  derive the class Promise from the object base class.
  do nothing.
 define the function lazy with 2 arguments: func and unpacked list resultclasses.
  decorator total_ordering,
  derive the class __proxy__ from the Promise base class.
  __dispatch is None.
  define the method __init__ with 3 arguments: self, args and kw.
  substitute args for self.__args.
  substitute kw for self.__kw.
  if self.__dispatch is None.
  call the method self.__prepare_class__.
  define the method __reduce__ with an argument self.
  return a tuple wit 2 elements: _lazy_proxy_unpickle and tuple with 3 elements: func, self.__args, self.__kw and resultclasses.
  classmethod decorator,
  define the method __prepare_class__ with an argument self.
  cls.__dispatch is an empty dictionary.
  for every resultclass in resultclasses,
  value under the resultclass key of the cls.__dispatch dictionary is an empty dictionary.
  call the method resultclass.mro, reverse the order of elements, for every type_ in the result.
  for every k and v in result of the call to the method type_.__dict__.items,
  call the method cls.__promise__ with 3 arguments: resultclass, k and v, substitute the result for meth.
  if cls has an attribute k,
  skip this loop iteration,
  set k attribute of cls object to meth.
  if bytes is contained in resultclasses, cls._delegate_bytes is boolean True, otherwise it is boolean False.
  if six.text_type is contained in resultclasses, cls._delegate_text is boolean True, otherwise it is boolean False.
  if cls._delegate_bytes and cls._delegate_text are both false, raise an error, with an argument string "Cannot call lazy() with both bytes and text return types.".
  if cls._delegate_text is true,
  if six.PY3 is true,
  substitute cls.__text_cast for cls.__str__.
  if not,
  substitute cls.__text_cast for cls.__text_cast.
  otherwise if cls._delegate_bytes is true,
  if six.PY3 is true,
  substitute cls.__bytes_cast for cls.__bytes__.
  if not,
  substitute cls.__bytes_cast for cls.__str__.
  class method decorator,
  define the method __promise__ with 4 arguments: cls, klass, funcname and method.
  define the method __wrapper__ with 3 arguments: self, unpacked list args and unpacked dictionary kw.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, substitute the result for res.
  get the type of res, call the method mro on the result, for every t in the result,
  if t is contained in self.__dispatch,
  get the value under the funcname key of the t-th elment of self.__dispatch dictionary, call the result with 3 arguments: res,
  unpacked list args and unpacked dictionary kw, return the result.   raise an TypeError exception with an argument sting "Lazy object returned unexpected type.".
  if klass is not contained in cls.__dispatch,
  value under the klass key of the cls.__dispatch dictionary is an empty dictionary.
  substitute method for value under the funcname key of the dictionary under the klass key of the cls.__dispatch dictionary.
  return __wrapper__.
  define the method __text_cast with an argument self.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
  define the method __bytes_cast with an argument self.
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw,
  use the result as an argument for the call to the function bytes, return the result.   define the method __cast with an argument self.
  if self._delegate_bytes is true,
  call the method self.__bytes_cast, return the result.
  otherwise if self._delegate_text is true,
  call the method self.__text_cast, return the result.
  if not,
  call the function func with 2 arguments: unpacked list self.__args and unpacked dictionary self.__kw, return the result.
  define the method __ne__ with 2 arguments: self and other.
  if other is an instance of Promise class,
  call the method other.__cast, substitute the result for other.
  call the method self.__cast, if the result doesnt equal to other, return boolean True, otherwise return boolean False.
  define the method __ne__ with 2 arguments: self and other.
  if other is an instance of Promise class,
  call the method other.__cast, substitute the result for other.
  call the method self.__cast, if the result equals other, return boolean True, otherwise return boolean False.
  define the method __lt__ with 2 arguments: self and other.
  if other is an instance of Promise,
  call the method other.__cast, substitute the result for other.
  call the method self.__cast, if the result is lesser than other, return boolean True, otherwise return boolean False.
  define the method __hash__ with an argument self.
  call the method self.__cast, return the hash value of the result.
  define the method __mod__ with 2 arguments: self and rhs.
  if self._delegate_bytes and six.PY2 are both true,
  call the function bytes with an argument self, divide the result with rhs and return the reminder of the division.
  otherwise if self._delegate_text is true,
<annotation_end_b>#<body_start>          to_unicode = lambda s : force_text ( s , strings_only = True )
 if categories :
              categories = [ force_text ( c ) for c in categories ]
  if ttl is not None :
               ttl = force_text ( ttl )
  self . feed = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'language' : to_unicode ( language ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'subtitle' : to_unicode ( subtitle ) ,  'categories' : categories or ( ) ,  'feed_url' : iri_to_uri ( feed_url ) ,  'feed_copyright' : to_unicode ( feed_copyright ) ,  'id' : feed_guid or link ,  'ttl' : ttl ,  }
  self . feed . update ( kwargs )
 self . items = [ ]
   def add_item ( self , title , link , description , author_email = None ,  author_name = None , author_link = None , pubdate = None , comments = None ,  unique_id = None , unique_id_is_permalink = None , enclosure = None ,  categories = ( ) , item_copyright = None , ttl = None , updateddate = None , ** kwargs ) :
 to_unicode = lambda s : force_text ( s , strings_only = True )
 if categories :
              categories = [ ( c ) for c in categories ]
  if ttl is not None :
               ttl = force_text ( ttl )
  item = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'pubdate' : pubdate ,  'updateddate' : updateddate ,  'comments' : to_unicode ( comments ) ,  'unique_id' : to_unicode ( unique_id ) ,  'unique_id_is_permalink' : unique_id_is_permalink ,  'enclosure' : enclosure ,  'categories' : categories or ( ) ,  'item_copyright' : to_unicode ( item_copyright ) ,  'ttl' : ttl ,  }
 item . update ( kwargs )
 self . items . append ( item )
   def num_items ( self ) :
          return len ( self . items )
   def root_attributes ( self ) :
 return { }
   def add_root_elements ( self , handler ) :
 pass
   def item_attributes ( self , item ) :
 return { }
   def add_item_elements ( self , handler , item ) :
 pass
   def write ( self , outfile , encoding ) :
 raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
   def writeString ( self , encoding ) :
 s = StringIO ( )
 self . write ( s , encoding )
 return s . getvalue ( )
   def latest_post_date ( self ) :
 latest_date = None
 date_keys = ( 'updateddate' , 'pubdate' )
  for item in self . items :
              for date_key in date_keys :
                  item_date = item . get ( date_key )
 if item_date :
                      if latest_date is None or item_date > latest_date :
                          latest_date = item_date
      return latest_date or datetime . datetime . now ( )
     class Enclosure ( object ) :
 def __init__ ( self , url , length , mime_type ) :
 self . length , self . mime_type = length , mime_type
 self . url = iri_to_uri ( url )
     class RssFeed ( SyndicationFeed ) :
      mime_type = 'application/rss+xml; charset=utf-8'
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( "rss" , self . rss_attributes ( ) )
 handler . startElement ( "channel" , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 self . endChannelElement ( handler )
 handler . endElement ( "rss" )
   def rss_attributes ( self ) :
          return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
   def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( 'item' , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "item" )
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , self . feed [ 'link' ] )
 handler . addQuickElement ( "description" , self . feed [ 'description' ] )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  if self . feed [ 'language' ] is not None :
              handler . addQuickElement ( "language" , self . feed [ 'language' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
  handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
    def endChannelElement ( self , handler ) :
          handler . endElement ( "channel" )
     class RssUserland091Feed ( RssFeed ) :
      _version = "0.91"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
      class Rss201rev2Feed ( RssFeed ) :
       _version = "2.0"
  def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , item [ 'link' ] )
 if item [ 'description' ] is not None :
              handler . addQuickElement ( "description" , item [ 'description' ] )
    if item [ "author_name" ] and item [ "author_email" ] :
              handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
  elif item [ "author_email" ] :
              handler . addQuickElement ( "author" , item [ "author_email" ] )
  elif item [ "author_name" ] :
              handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
   if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
  if item [ 'comments' ] is not None :
              handler . addQuickElement ( "comments" , item [ 'comments' ] )
  if item [ 'unique_id' ] is not None :
              guid_attrs = { }
 if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
                  guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
  handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
  if item [ 'ttl' ] is not None :
              handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
   for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , cat )
      class Atom1Feed ( SyndicationFeed ) :
       mime_type = 'application/atom+xml; charset=utf-8'
 ns = "http://www.w3.org/2005/Atom"
  def write ( self , outfile , encoding ) :
          handler = SimplerXMLGenerator ( outfile , encoding )
 handler . startDocument ( )
 handler . startElement ( 'feed' , self . root_attributes ( ) )
 self . add_root_elements ( handler )
 self . write_items ( handler )
 handler . endElement ( "feed" )
   def root_attributes ( self ) :
          if self . feed [ 'language' ] is not None :
              return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
  else :
              return { "xmlns" : self . ns }
    def add_root_elements ( self , handler ) :
          handler . addQuickElement ( "title" , self . feed [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
 if self . feed [ 'feed_url' ] is not None :
              handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
  handler . addQuickElement ( "id" , self . feed [ 'id' ] )
 handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
 if self . feed [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
 if self . feed [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
  if self . feed [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
  handler . endElement ( "author" )
  if self . feed [ 'subtitle' ] is not None :
              handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
  for cat in self . feed [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
  if self . feed [ 'feed_copyright' ] is not None :
              handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
    def write_items ( self , handler ) :
          for item in self . items :
              handler . startElement ( "entry" , self . item_attributes ( item ) )
 self . add_item_elements ( handler , item )
 handler . endElement ( "entry" )
    def add_item_elements ( self , handler , item ) :
          handler . addQuickElement ( "title" , item [ 'title' ] )
 handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
  if item [ 'pubdate' ] is not None :
              handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
   if item [ 'updateddate' ] is not None :
              handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
    if item [ 'author_name' ] is not None :
              handler . startElement ( "author" , { } )
 handler . addQuickElement ( "name" , item [ 'author_name' ] )
 if item [ 'author_email' ] is not None :
                  handler . addQuickElement ( "email" , item [ 'author_email' ] )
  if item [ 'author_link' ] is not None :
                  handler . addQuickElement ( "uri" , item [ 'author_link' ] )
  handler . endElement ( "author" )
    if item [ 'unique_id' ] is not None :
              unique_id = item [ 'unique_id' ]
  else :
              unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
  handler . addQuickElement ( "id" , unique_id )
   if item [ 'description' ] is not None :
              handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
    if item [ 'enclosure' ] is not None :
              handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
    for cat in item [ 'categories' ] :
              handler . addQuickElement ( "category" , "" , { "term" : cat } )
    if item [ 'item_copyright' ] is not None :
              handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
       DefaultFeed = Rss201rev2Feed
from __future__ import absolute_import
  import decimal
 import datetime
 from importlib import import_module
 import unicodedata
  from django . conf import settings
 from django . utils import dateformat , numberformat , datetime_safe
 from django . utils . encoding import force_str
 from django . utils . functional import lazy
 from django . utils . safestring import mark_safe
 from django . utils import six
 from django . utils . translation import get_language , to_locale , check_for_language
     _format_cache = { }
 _format_modules_cache = { }
  ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
   def reset_format_cache ( ) :
 global _format_cache , _format_modules_cache
 _format_cache = { }
 _format_modules_cache = { }
    def iter_format_modules ( lang , format_module_path = None ) :
 if not check_for_language ( lang ) :
          return
   if format_module_path is None :
          format_module_path = settings . FORMAT_MODULE_PATH
   format_locations = [ ]
 if format_module_path :
          if isinstance ( format_module_path , six . string_types ) :
              format_module_path = [ format_module_path ]
  for path in format_module_path :
              format_locations . append ( path + '.%s' )
   format_locations . append ( 'django.conf.locale.%s' )
 locale = to_locale ( lang )
 locales = [ locale ]
 if '_' in locale :
          locales . append ( locale . split ( '_' ) [ 0 ] )
  for location in format_locations :
          for loc in locales :
              try :
                  yield import_module ( '%s.formats' % ( location % loc ) )
  except ImportError :
                  pass
       def get_format_modules ( lang = None , reverse = False ) :
 if lang is None :
          lang = get_language ( )
  modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
 if reverse :
          return list ( reversed ( modules ) )
  return modules
    def get_format ( format_type , lang = None , use_l10n = None ) :
 format_type = force_str ( format_type )
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          if lang is None :
              lang = get_language ( )
  cache_key = ( format_type , lang )
 try :
              cached = _format_cache [ cache_key ]
 if cached is not None :
                  return cached
  else :
                   return getattr ( settings , format_type )
   except KeyError :
              for module in get_format_modules ( lang ) :
                  try :
                      val = getattr ( module , format_type )
 for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
                          if iso_input not in val :
                              if isinstance ( val , tuple ) :
                                  val = list ( val )
  val . append ( iso_input )
   _format_cache [ cache_key ] = val
 return val
  except AttributeError :
                      pass
   _format_cache [ cache_key ] = None
   return getattr ( settings , format_type )
   get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
   def date_format ( value , format = None , use_l10n = None ) :
 return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
    def time_format ( value , format = None , use_l10n = None ) :
 return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
    def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
 if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
          lang = get_language ( )
  else :
          lang = None
  return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
    def localize ( value , use_l10n = None ) :
 if isinstance ( value , bool ) :
          return mark_safe ( six . text_type ( value ) )
  elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . datetime ) :
          return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
  elif isinstance ( value , datetime . date ) :
          return date_format ( value , use_l10n = use_l10n )
  elif isinstance ( value , datetime . time ) :
          return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
  else :
          return value
     def localize_input ( value , default = None ) :
 if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
          return number_format ( value )
  elif isinstance ( value , datetime . datetime ) :
          value = datetime_safe . new_datetime ( value )
 format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . date ) :
          value = datetime_safe . new_date ( value )
 format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  elif isinstance ( value , datetime . time ) :
          format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
 return value . strftime ( format )
  return value
    def sanitize_separators ( value ) :
 if settings . USE_L10N and isinstance ( value , six . string_types ) :
          parts = [ ]
 decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )
 if decimal_separator in value :
              value , decimals = value . split ( decimal_separator , 1 )
 parts . append ( decimals )
  if settings . USE_THOUSAND_SEPARATOR :
              thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )
 for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :
                  value = value . replace ( replacement , '' )
   parts . append ( value )
 value = '.' . join ( reversed ( parts ) )
  return value
import copy
 import operator
 from functools import wraps
 import sys
 import warnings
  from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . six . moves import copyreg
      def curry ( _curried_func , * args , ** kwargs ) :
      def _curried ( * moreargs , ** morekwargs ) :
          return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
  return _curried
    def memoize ( func , cache , num_args ) :
 warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
  @ wraps ( func )
 def wrapper ( * args ) :
          mem_args = args [ : num_args ]
 if mem_args in cache :
              return cache [ mem_args ]
  result = func ( * args )
 cache [ mem_args ] = result
 return result
  return wrapper
    class cached_property ( object ) :
 def __init__ ( self , func , name = None ) :
          self . func = func
 self . name = name or func . __name__
   def __get__ ( self , instance , type = None ) :
          if instance is None :
              return self
  res = instance . __dict__ [ self . name ] = self . func ( instance )
 return res
     class Promise ( object ) :
 pass
    def lazy ( func , * resultclasses ) :
  @ total_ordering
 class __proxy__ ( Promise ) :
 __dispatch = None
  def __init__ ( self , args , kw ) :
              self . __args = args
 self . __kw = kw
 if self . __dispatch is None :
                  self . __prepare_class__ ( )
    def __reduce__ ( self ) :
              return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
   @ classmethod
 def __prepare_class__ ( cls ) :
              cls . __dispatch = { }
 for resultclass in resultclasses :
                  cls . __dispatch [ resultclass ] = { }
 for type_ in reversed ( resultclass . mro ( ) ) :
                      for ( k , v ) in type_ . __dict__ . items ( ) :
                             meth = cls . __promise__ ( resultclass , k , v )
 if hasattr ( cls , k ) :
                              continue
  setattr ( cls , k , meth )
    cls . _delegate_bytes = bytes in resultclasses
 cls . _delegate_text = six . text_type in resultclasses
 assert not ( cls . _delegate_bytes and cls . _delegate_text ) , "Cannot call lazy() with both bytes and text return types."
 if cls . _delegate_text :
                  if six . PY3 :
                      cls . __str__ = cls . __text_cast
  else :
                      cls . __unicode__ = cls . __text_cast
   elif cls . _delegate_bytes :
                  if six . PY3 :
                      cls . __bytes__ = cls . __bytes_cast
  else :
                      cls . __str__ = cls . __bytes_cast
     @ classmethod
 def __promise__ ( cls , klass , funcname , method ) :
                def __wrapper__ ( self , * args , ** kw ) :
                    res = func ( * self . __args , ** self . __kw )
 for t in type ( res ) . mro ( ) :
                      if t in self . __dispatch :
                          return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
   raise TypeError ( "Lazy object returned unexpected type." )
   if klass not in cls . __dispatch :
                  cls . __dispatch [ klass ] = { }
  cls . __dispatch [ klass ] [ funcname ] = method
 return __wrapper__
   def __text_cast ( self ) :
              return func ( * self . __args , ** self . __kw )
   def __bytes_cast ( self ) :
              return bytes ( func ( * self . __args , ** self . __kw ) )
   def __cast ( self ) :
              if self . _delegate_bytes :
                  return self . __bytes_cast ( )
  elif self . _delegate_text :
                  return self . __text_cast ( )
  else :
                  return func ( * self . __args , ** self . __kw )
    def __ne__ ( self , other ) :
              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
  return self . __cast ( ) != other
   def __eq__ ( self , other ) :
              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
  return self . __cast ( ) == other
   def __lt__ ( self , other ) :
              if isinstance ( other , Promise ) :
                  other = other . __cast ( )
  return self . __cast ( ) < other
   def __hash__ ( self ) :
              return hash ( self . __cast ( ) )
   def __mod__ ( self , rhs ) :
              if self . _delegate_bytes and six . PY2 :
                  return bytes ( self ) % rhs
  elif self . _delegate_text :
<body_end><annotation_start_b>  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
<annotation_end_b>#<body_start>                 memo [ id ( self ) ] = self
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  call the function six.itervalues with an argument kwargs, convert the result to a list and append it to a list containing args,
  for every arg in the result,   if arg is an instance of Promise class,
  break from the loop execution,
  if not,
<annotation_end_b>#<body_start>          for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :
              if isinstance ( arg , Promise ) :
                  break
   else :
<body_end><annotation_start_b>  decorator function wraps with an argument func.
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  call the function six.itervalues with an argument kwargs, convert the result to a list and append it to a list containing args,
  for every arg in the result,   if arg is an instance of Promise class,
  break from the loop execution,
  if not,
  call the function func with 2 arguments: unpacked list args and unpacked dictionary kwargs.
<annotation_end_b>#<body_start> @ wraps ( func )
 def wrapper ( * args , ** kwargs ) :
          for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :
              if isinstance ( arg , Promise ) :
                  break
   else :
              return func ( * args , ** kwargs )
<body_end><annotation_start_b>  if self._wrapped is contained in empty,
  call the method self._setup.
<annotation_end_b>#<body_start>          if self . _wrapped is empty :
              self . _setup ( )
<body_end><annotation_start_b>  define the method inner with 2 arguments: self and unpacked list args.
  if self._wrapped is contained in empty,
  call the method self._setup.
  call the function func with 2 arguments: self._wrapped and unpacked list args.
<annotation_end_b>#<body_start>      def inner ( self , * args ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return func ( self . _wrapped , * args )
<body_end><annotation_start_b>  if self._wrapped is empty,
  call the method self._setup.
<annotation_end_b>#<body_start>          if self . _wrapped is empty :
              self . _setup ( )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if proto is greater than or equal to integer 2,
<annotation_end_b>#<body_start>          if proto >= 2 :
<body_end><annotation_start_b>  raise an NotImplementedError exception with an argument sting 'subclasses of LazyObject must provide a _setup() method'.
  define the method __getstate__ with an argument self.
  if self._wrapped is empty,
  call the method self._setup.
  return self._wrapped.__dict__.
  classmethod decorator,
  define the method __newobj__ with 2 arguments cls and unpacked list args.
  call the method cls.__new__ with 2 arguments: cls and unpacked list args.
  define the method __reduce_ex__ with 2 arguments self and proto.
  if proto is greater than or equal to integer 2,
  return a tuple with 3 elements: self.__newobj__, tuple with an element self.__class__ and result of the method self.__getstate__.
  if not,
<annotation_end_b>#<body_start> raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )
        def __getstate__ ( self ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return self . _wrapped . __dict__
     @ classmethod
 def __newobj__ ( cls , * args ) :
          return cls . __new__ ( cls , * args )
   def __reduce_ex__ ( self , proto ) :
          if proto >= 2 :
                return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
  else :
<body_end><annotation_start_b>  if self._wrapped is empty,
  get type of self, call it and substitute the result for result.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
<annotation_end_b>#<body_start>          if self . _wrapped is empty :
                result = type ( self ) ( )
 memo [ id ( self ) ] = result
<body_end><annotation_start_b>  if name equals string "_wrapped",
  raise an TypeError exception with an argument sting "can't delete _wrapped.".
  if self._wrapped is empty,
  call the method self._setup.
  delete name attribute from self._wrapped object.
  define the method _setup with an argument self.
  raise an NotImplementedError exception with an argument sting 'subclasses of LazyObject must provide a _setup() method'.
  define the method __getstate__ with an argument self.
  if self._wrapped is empty,
  call the method self._setup.
  return self._wrapped.__dict__.
  classmethod decorator,
  define the method __newobj__ with 2 arguments cls and unpacked list args.
  call the method cls.__new__ with 2 arguments: cls and unpacked list args.
  define the method __reduce_ex__ with 2 arguments self and proto.
  if proto is greater than or equal to integer 2,
  return a tuple with 3 elements: self.__newobj__, tuple with an element self.__class__ and result of the method self.__getstate__.
  if not,
  return a tuple with 3 elements: copyreg._reconstructor, tuple with 3 elements: self.__class__, object and None,
  and result of the method self.__getstate__.   define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  get type of self, call it and substitute the result for result.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
<annotation_end_b>#<body_start>          if name == "_wrapped" :
              raise TypeError ( "can't delete _wrapped." )
  if self . _wrapped is empty :
              self . _setup ( )
  delattr ( self . _wrapped , name )
   def _setup ( self ) :
 raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )
        def __getstate__ ( self ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return self . _wrapped . __dict__
     @ classmethod
 def __newobj__ ( cls , * args ) :
          return cls . __new__ ( cls , * args )
   def __reduce_ex__ ( self , proto ) :
          if proto >= 2 :
                return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
  else :
                  return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )
    def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = type ( self ) ( )
 memo [ id ( self ) ] = result
 return result
<body_end><annotation_start_b>  if self._wrapped is empty,
  substitute self._setupfunc for repr_attr.
  if not,
  substitute self._wrapped for repr_attr.
<annotation_end_b>#<body_start>          if self . _wrapped is empty :
              repr_attr = self . _setupfunc
  else :
              repr_attr = self . _wrapped
<body_end><annotation_start_b>  if self._wrapped is empty,
  result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
<annotation_end_b>#<body_start>          if self . _wrapped is empty :
                result = SimpleLazyObject ( self . _setupfunc )
 memo [ id ( self ) ] = result
<body_end><annotation_start_b>  call the method self._setupfunc, substitute the result for self._wrapped.
  define the method __repr__ with an argument self.
  if self._wrapped is empty,
  substitute self._setupfunc for repr_attr.
  if not,
  substitute self._wrapped for repr_attr.
  return a string '<%s: %r>', format it with __name__ field of the self class and repr_attr.
  define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
<annotation_end_b>#<body_start>          self . _wrapped = self . _setupfunc ( )
     def __repr__ ( self ) :
          if self . _wrapped is empty :
              repr_attr = self . _setupfunc
  else :
              repr_attr = self . _wrapped
  return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )
   def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = SimpleLazyObject ( self . _setupfunc )
 memo [ id ( self ) ] = result
 return result
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if fget is not None,
  decorator function wraps with an argument fget.
  define the function fget with 3 arguments: instance, instance_type set to None and name set to fget.__name__.
  get name attribute from the instance object, call it and return the result.
  if fset is not None,
  decorator function wraps with an argument fset.
  define the function fset with 3 arguments: instance, valse to None and name set to fset.__name__.
  get name attribute from the instance object, call it with an argument value and return the result.
  if fdel is not None,
  decorator function wraps with an argument fdel.
  define the function fdel with 2 arguments: instance and name set to fdel.__name__.
  get name attribute from the instance object, call it and return the result.
<annotation_end_b>#<body_start>          if fget is not None :
              @ wraps ( fget )
 def fget ( instance , instance_type = None , name = fget . __name__ ) :
                  return getattr ( instance , name ) ( )
   if fset is not None :
              @ wraps ( fset )
 def fset ( instance , value , name = fset . __name__ ) :
                  return getattr ( instance , name ) ( value )
   if fdel is not None :
              @ wraps ( fdel )
 def fdel ( instance , name = fdel . __name__ ) :
                  return getattr ( instance , name ) ( )
<body_end><annotation_start_b>  results is a tuple with 2 elements, 2 empty lists.
  for every item in values,
  call the function predicate with an argument item, use it as a key to get results dictionary value, append item to it.
<annotation_end_b>#<body_start> results = ( [ ] , [ ] )
 for item in values :
          results [ predicate ( item ) ] . append ( item )
<body_end><annotation_start_b>  convert is a dictionary with 4 initial entries: list with 3 tuples: tuple with 2 elements: string '__gt__',
  and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other, for '__lt__',   list with 3 tuples: tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other,   or self is equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than or equal to other,   or self is not equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other, for '__le__',   list with 3 tuples: tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other, for '__gt__',   and list with 3 tuples: tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is not greater than or is not equal to other,   or self is equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than or not equal to other,   or self is not equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than or equal to other, for '__ge__',   convert cls to a dictionary, convert the result into a set and convert convert into a set, roots is a set of differences of the two previous sets.
  if roots is false,
  raise an ValueError exception with an argument string 'must define at least one ordering operation: < > <= >='.
  get maximal element from roots and substitute it for root.
  get the value under the root key of the convert dictionary, for every opname and opfunc in the result,
  if opname is not contained in roots,
  substitute opname for opfunc.__name__.
  get opname attribute from int object, substitute its field __doc__ for opfunc.__doc__.
  set opname attribute of cls object to opfunc.
<annotation_end_b>#<body_start> convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
 roots = set ( dir ( cls ) ) & set ( convert )
 if not roots :
              raise ValueError ( 'must define at least one ordering operation: < > <= >=' )
  root = max ( roots )
 for opname , opfunc in convert [ root ] :
              if opname not in roots :
                  opfunc . __name__ = opname
 opfunc . __doc__ = getattr ( int , opname ) . __doc__
 setattr ( cls , opname , opfunc )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if text has an '__html__' attribute,
<annotation_end_b>#<body_start> if hasattr ( text , '__html__' ) :
<body_end><annotation_start_b>  substitute func for value under the '_setupfunc' key of the self.__dict__ dictionary.
  call the function _super with 2 arguments: class SimpleLazyObject and self, call the method __init__ on the result.
  define the method _setup with an argument self.
  call the method self._setupfunc, substitute the result for self._wrapped.
  define the method __repr__ with an argument self.
  if self._wrapped is empty,
  substitute self._setupfunc for repr_attr.
  if not,
  substitute self._wrapped for repr_attr.
  return a string '<%s: %r>', format it with __name__ field of the self class and repr_attr.
  define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
  call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
  derive the class lazy_property from the property base class.
  define the method __new__ with 5 arguments: cls, fget set to None, fset set to None, fdel set to None and doc set to None.
  if fget is not None,
  decorator function wraps with an argument fget.
  define the function fget with 3 arguments: instance, instance_type set to None and name set to fget.__name__.
  get name attribute from the instance object, call it and return the result.
  if fset is not None,
  decorator function wraps with an argument fset.
  define the function fset with 3 arguments: instance, valse to None and name set to fset.__name__.
  get name attribute from the instance object, call it with an argument value and return the result.
  if fdel is not None,
  decorator function wraps with an argument fdel.
  define the function fdel with 2 arguments: instance and name set to fdel.__name__.
  get name attribute from the instance object, call it and return the result.
  return an property object with getter function fget, setter function fset, destructor fdel and documentation string doc.
  define the function partition with 2 arguments: predicate and values.
  results is a tuple with 2 elements, 2 empty lists.
  for every item in values,
  call the function predicate with an argument item, use it as a key to get results dictionary value, append item to it.
  return results.
  if sys.version_info is greater than or equal to a tuple with 3 elements: integers 2, 7 and 2, respectively,
  from functools import total_ordering.
  if not,
  define the function total_ordering with an argument cls.
  convert is a dictionary with 4 initial entries: list with 3 tuples: tuple with 2 elements: string '__gt__',
  and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other, for '__lt__',   list with 3 tuples: tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other,   or self is equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than or equal to other,   or self is not equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other, for '__le__',   list with 3 tuples: tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other, for '__gt__',   and list with 3 tuples: tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is not greater than or is not equal to other,   or self is equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than or not equal to other,   or self is not equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than or equal to other, for '__ge__',   convert cls to a dictionary, convert the result into a set and convert convert into a set, roots is a set of differences of the two previous sets.
  if roots is false,
  raise an ValueError exception with an argument string 'must define at least one ordering operation: < > <= >='.
  get maximal element from roots and substitute it for root.
  get the value under the root key of the convert dictionary, for every opname and opfunc in the result,
  if opname is not contained in roots,
  substitute opname for opfunc.__name__.
  get opname attribute from int object, substitute its field __doc__ for opfunc.__doc__.
  set opname attribute of cls object to opfunc.
  return cls.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module sys.
  from django.utils.encoding import force_text and force_str into default name space.
  from django.utils.functional import allow_lazy into default name space.
  from django.utils.safestring import SafeData and mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote, unquote, urlsplit and urlunsplit into default name space.
  from django.utils.text import normalize_newlines into default name space.
  from .html_parser import HTMLParser and HTMLParseError into default name space.
  TRAILING_PUNCTUATION is a list with 7 elements: '.', ',', ':', ';', '.)', '"' and '\''.
  WRAPPING_PUNCTUATION is a list with 6 elements: tuple with 2 elements: '(' and ')', tuple with 2 elements: '<' and '>',
  tuple with 2 elements: '[' and ']', tuple with 2 elements: '&lt' and '&gt', tuple with 2 elements: '"' and '"',   and tuple with 2 elements: '\'' and '\''.   DOTS is a list with 6 elements: strings '&middot;', '*', '\u2022', '&#149;', '&bull;' and '&#8226;'.
  call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for unencoded_ampersands_re.
  call the function re.compile with raw string '(\s+)', substitute the result for word_split_re.
  call the function re.compile with 2 arguments: raw string '^https?://\[?\w' and re.IGNORECASE, substitute the result for simple_url_re.
  call the function re.compile with 2 arguments: raw string '^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$',
  and re.IGNORECASE, substitute the result for simple_url_re.   call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for simple_email_re.
  call the function re.compile with raw string '(<a [^>]*?)target=[^\s>]+', substitute the result for link_target_attribute_re.
  call the function re.compile with 2 arguments:
  raw string '(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' and re.IGNORECASE,   substitute the result for html_gunk_re.   call the function re.compile with 2 arguments: raw string '((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)',
  formated with string created by joining elements of result of the function re.escape with an argument x, with separator '|',   for every x in DOTS, and re.DOTALL, substitute the result for hard_coded_bullets_re.   call the function re.compile with raw string '(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z', substitute the result for trailing_empty_content_re.
  define the function escape with an argument text.
  call the function force_text with an argument text, replace every occurrence of '&' in the result with '&amp;',
  every occurrence of '<' with '&lt;', every occurrence of '>' with '&gt;', every occurrence of '"' with '&quot;',   and every occurrence of "'" with '&#39;', call the function mark_safe with the previous result as an argument, return the result.   call the function allow_lazy with 2 arguments: escape, six.text_type, substitute the result for escape.
  _js_escapes is a dictionary with 11 initial entries: '\\u005C' for integer representation of string '\\',
  '\\u0027' for integer representation of string '\', '\\u0022' for integer representation of string '"',   '\\u003E' for integer representation of string '>', '\\u003C' for integer representation of string '<',   '\\u0026' for integer representation of string '%', '\\u003D' for integer representation of string '=',   '\\u002D' for integer representation of string '-', '\\u003B' for integer representation of string ';',   '\\u2028' for integer representation of string '\u2028' and '\\u2029' for integer representation of string '\u2029'.   for eery z in range of integers from 0 to 31, update _js_escapes dictionary with '\\u%04X' formated with z,
  for integer representation of z converted into a string.   define the function escapejs with an argument value.
  call the function force_text with an argument value, call the method translate on the result, with an argument _js_escapes,
  use the result as an argument for the call to the mark_safe function, return the result.   call the function allow_lazy with 2 arguments: escapejs, six.text_type, substitute the result for escapejs.
  define the function conditional_escape with an argument text.
  if text has an '__html__' attribute,
  call the method text.__html__, return the result.
  if not,
<annotation_end_b>#<body_start> self . __dict__ [ '_setupfunc' ] = func
 _super ( SimpleLazyObject , self ) . __init__ ( )
   def _setup ( self ) :
          self . _wrapped = self . _setupfunc ( )
     def __repr__ ( self ) :
          if self . _wrapped is empty :
              repr_attr = self . _setupfunc
  else :
              repr_attr = self . _wrapped
  return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )
   def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = SimpleLazyObject ( self . _setupfunc )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
     class lazy_property ( property ) :
 def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :
          if fget is not None :
              @ wraps ( fget )
 def fget ( instance , instance_type = None , name = fget . __name__ ) :
                  return getattr ( instance , name ) ( )
   if fset is not None :
              @ wraps ( fset )
 def fset ( instance , value , name = fset . __name__ ) :
                  return getattr ( instance , name ) ( value )
   if fdel is not None :
              @ wraps ( fdel )
 def fdel ( instance , name = fdel . __name__ ) :
                  return getattr ( instance , name ) ( )
   return property ( fget , fset , fdel , doc )
     def partition ( predicate , values ) :
 results = ( [ ] , [ ] )
 for item in values :
          results [ predicate ( item ) ] . append ( item )
  return results
   if sys . version_info >= ( 2 , 7 , 2 ) :
      from functools import total_ordering
  else :
         def total_ordering ( cls ) :
 convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
 roots = set ( dir ( cls ) ) & set ( convert )
 if not roots :
              raise ValueError ( 'must define at least one ordering operation: < > <= >=' )
  root = max ( roots )
 for opname , opfunc in convert [ root ] :
              if opname not in roots :
                  opfunc . __name__ = opname
 opfunc . __doc__ = getattr ( int , opname ) . __doc__
 setattr ( cls , opname , opfunc )
   return cls
  from __future__ import unicode_literals
  import re
 import sys
  from django . utils . encoding import force_text , force_str
 from django . utils . functional import allow_lazy
 from django . utils . safestring import SafeData , mark_safe
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
 from django . utils . text import normalize_newlines
  from . html_parser import HTMLParser , HTMLParseError
    TRAILING_PUNCTUATION = [ '.' , ',' , ':' , ';' , '.)' , '"' , '\'' ]
 WRAPPING_PUNCTUATION = [ ( '(' , ')' ) , ( '<' , '>' ) , ( '[' , ']' ) , ( '&lt;' , '&gt;' ) , ( '"' , '"' ) , ( '\'' , '\'' ) ]
   DOTS = [ '&middot;' , '*' , '\u2022' , '&#149;' , '&bull;' , '&#8226;' ]
  unencoded_ampersands_re = re . compile ( r'&(?!(\w+|#\d+);)' )
 word_split_re = re . compile ( r'(\s+)' )
 simple_url_re = re . compile ( r'^https?://\[?\w' , re . IGNORECASE )
 simple_url_2_re = re . compile ( r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$' , re . IGNORECASE )
 simple_email_re = re . compile ( r'^\S+@\S+\.\S+$' )
 link_target_attribute_re = re . compile ( r'(<a [^>]*?)target=[^\s>]+' )
 html_gunk_re = re . compile ( r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' , re . IGNORECASE )
 hard_coded_bullets_re = re . compile ( r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
 trailing_empty_content_re = re . compile ( r'(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z' )
   def escape ( text ) :
 return mark_safe ( force_text ( text ) . replace ( '&' , '&amp;' ) . replace ( '<' , '&lt;' ) . replace ( '>' , '&gt;' ) . replace ( '"' , '&quot;' ) . replace ( "'" , '&#39;' ) )
  escape = allow_lazy ( escape , six . text_type )
  _js_escapes = {  ord ( '\\' ) : '\\u005C' ,  ord ( '\'' ) : '\\u0027' ,  ord ( '"' ) : '\\u0022' ,  ord ( '>' ) : '\\u003E' ,  ord ( '<' ) : '\\u003C' ,  ord ( '&' ) : '\\u0026' ,  ord ( '=' ) : '\\u003D' ,  ord ( '-' ) : '\\u002D' ,  ord ( ';' ) : '\\u003B' ,  ord ( '\u2028' ) : '\\u2028' ,  ord ( '\u2029' ) : '\\u2029'  }
   _js_escapes . update ( ( ord ( '%c' % z ) , '\\u%04X' % z ) for z in range ( 32 ) )
   def escapejs ( value ) :
 return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )
  escapejs = allow_lazy ( escapejs , six . text_type )
   def conditional_escape ( text ) :
 if hasattr ( text , '__html__' ) :
          return text . __html__ ( )
  else :
<body_end><annotation_start_b>  map elements from args through the function conditional_escape, substitute the result for args_safe.
  kwargs_safe is a dictionary created for every k and v in result of the function six.iteritems called with an argument kwargs,
<annotation_end_b>#<body_start> args_safe = map ( conditional_escape , args )
 kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  call the function normalize_newlines with an argument value, substitute the result for value.
  call the method re.split with 2 arguments: string '\n{2,}' and value, substitute the result for paras.
  if autoescape is true,
  call the function escape with an argument p, replace every occurrence of '\n' in the result for '<br />',
  format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   if not,
  replace every occurrence of '\n' in p for '<br />',
<annotation_end_b>#<body_start> value = normalize_newlines ( value )
 paras = re . split ( '\n{2,}' , value )
 if autoescape :
          paras = [ '<p>%s</p>' % escape ( p ) . replace ( '\n' , '<br />' ) for p in paras ]
  else :
          paras = [ '<p>%s</p>' % p . replace ( '\n' , '<br />' ) for p in paras ]
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
<annotation_end_b>#<body_start> s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
<body_end><annotation_start_b>  format string '&#%s;' with name, append it to self.fed.
  define the method get_data with an argument self.
  join elements of self.fed into a string, return the result.
  define the function _strip_once with an argument value.
  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
  return value.
  try,
  close file descriptor s.
  if HTMLParseError or UnboundLocalError exceptions are caught,
<annotation_end_b>#<body_start>          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
<body_end><annotation_start_b>  format string '&%s;' with name, append it to self.fed.
  define the method handle_charref with 2 arguments self and name.
  format string '&#%s;' with name, append it to self.fed.
  define the method get_data with an argument self.
  join elements of self.fed into a string, return the result.
  define the function _strip_once with an argument value.
  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
  return value.
  try,
  close file descriptor s.
  if HTMLParseError or UnboundLocalError exceptions are caught,
  sum the result of the method s.get_data and s.rawdata, return the result.
  if not,
<annotation_end_b>#<body_start>          self . fed . append ( '&%s;' % name )
   def handle_charref ( self , name ) :
          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
            return s . get_data ( ) + s . rawdata
  else :
<body_end><annotation_start_b>  while '<' is contained in value and '>' is contained in value,
  call the function _strip_once with an argument value, substitute the result for new_value.
  if new_value equals value,
  break from the loop execution.
  substitute new_value for value.
<annotation_end_b>#<body_start>   while '<' in value and '>' in value :
          new_value = _strip_once ( value )
 if new_value == value :
               break
  value = new_value
<body_end><annotation_start_b>  tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
  join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
  call the function re.compile with 2 arguments: raw string '<%s(/?>|(\s+[^>]*>))' formated with tags_re and re.U,
  substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
  call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
<annotation_end_b>#<body_start> tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
 tags_re = '(%s)' % '|' . join ( tags )
 starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
 endtag_re = re . compile ( '</%s>' % tags_re )
 html = starttag_re . sub ( '' , html )
 html = endtag_re . sub ( '' , html )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  try,
  call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
  try,
  call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
  substitute the result for netloc.   if UnicodeError exception is caught,
  do nothing.
  if not,
  call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
  if ValueError exception is caught,
  do nothing.
  call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
  call the function quote with 2 arguments: url and safe as bytes string '!*\'();:@&=+$,/?#[]~', substitute the result for url.
<annotation_end_b>#<body_start>  try :
          scheme , netloc , path , query , fragment = urlsplit ( url )
 try :
              netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
              pass
  else :
              url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
   except ValueError :
           pass
   url = unquote ( force_str ( url ) )
  url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
<body_end><annotation_start_b>  if limit is None or length of x is lesser than or equal to limit,
<annotation_end_b>#<body_start>          if limit is None or len ( x ) <= limit :
<body_end><annotation_start_b>  define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
  if limit is None or length of x is lesser than or equal to limit,
  return x.
<annotation_end_b>#<body_start> def trim_url ( x , limit = trim_url_limit ) :
          if limit is None or len ( x ) <= limit :
              return x
<body_end><annotation_start_b>  append d to self.fed.
  define the method handle_entityref with 2 arguments self and name.
  format string '&%s;' with name, append it to self.fed.
  define the method handle_charref with 2 arguments self and name.
  format string '&#%s;' with name, append it to self.fed.
  define the method get_data with an argument self.
  join elements of self.fed into a string, return the result.
  define the function _strip_once with an argument value.
  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
  return value.
  try,
  close file descriptor s.
  if HTMLParseError or UnboundLocalError exceptions are caught,
  sum the result of the method s.get_data and s.rawdata, return the result.
  if not,
  call the method s.get_data, return the result.
  define the function strip_tags with an argument value.
  while '<' is contained in value and '>' is contained in value,
  call the function _strip_once with an argument value, substitute the result for new_value.
  if new_value equals value,
  break from the loop execution.
  substitute new_value for value.
  return value.
  call the function allow_lazy with an argument strip_tags, substitute the result for strip_tags.
  define the function remove_tags with 2 arguments: html and tags.
  tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
  join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
  call the function re.compile with 2 arguments: raw string '<%s(/?>|(\s+[^>]*>))' formated with tags_re and re.U,
  substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
  call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  return html.
  call the function allow_lazy with 2 arguments: remove_tags, six.text_type, substitute the result for remove_tags.
  define the function strip_spaces_between_tags with an argument value.
  call the method re.sub with 3 arguments: raw string '>\s+<', string '><' and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_spaces_between_tags, six.text_type, substitute the result for strip_spaces_between_tags.
  define the function strip_entities with an argument value.
  call the method re.sub with 3 arguments: raw string '&(?:\w+|#\d+);', empty string and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_entities, six.text_type, substitute the result for strip_entities.
  define the function smart_urlquote with an argument url.
  try,
  call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
  try,
  call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
  substitute the result for netloc.   if UnicodeError exception is caught,
  do nothing.
  if not,
  call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
  if ValueError exception is caught,
  do nothing.
  call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
  call the function quote with 2 arguments: url and safe as bytes string '!*\'();:@&=+$,/?#[]~', substitute the result for url.
  call the function force_text with an argument url, return the result.
  define the function urlize with 4 arguments: text, trim_url_limit set to None, nofollow set to boolean False,
  define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
  if limit is None or length of x is lesser than or equal to limit,
  return x.
  return a string '%s...' formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit.
  if text is an instance of SafeData, safe_input is boolean True, otherwise is boolean False.
  call the function force_text with an argument text, split by it word_split_re, substitute it for words.
  for every i and word in enumerated iterable words,
  if '.' is contained in words or '@' is contained in word or ':' is contained in word,
  substitute empty string, word an empty string for lead, middle and trail, respectively.
  for every punctuation in TRAILING_PUNCTUATION,
  if middle ends with punctuation,
  substitute elements of middle from the beginning to the negative length of punctuation, for middle.
  sum punctuation and trail, substitute the result for trail.
  for every opening and closing in WRAPPING_PUNCTUATION,
  if middle starts with opening,
  substitute elements of middle from length of opening index to the end, for middle.
  sum lead and opening, substitute the result for lead.
  if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one,
  substitute elements of middle from the beginning to the negative length of closing, for middle.
  sum trail and closing, substitute the result for lead.
  url is None.
  if nofollow is true nofollow_attr is a string ' rel="nofollow"', otherwise nofollow_attr is an empty string.
  call the method simple_url_re.match with an argument middle, if it evaluates to true,
  call the function smart_urlquote with an argument middle, substitute the result for url.
  otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true,
  call the function smart_urlquote with an argument string 'http://%s' formated with an argument middle, substitute the result for url.
  otherwise if ':' is not contained in middle and result of the function simple_email_re.match called with an argument middle,
  evaluates to true,   split middle into two parts from the right by '@' character, assign the resulting parts to local and domain.
  try,
  call the method domain.encode with an argument string 'idna', call the method decode on the result with an argument string 'ascii',
  substitute the result for domain.   if UnicodeError exception is caught,
  skip this loop iteration.
  url is a string 'mailto:%s@%s' formated with local and domain.
  nofollow_attr is an empty string.
  if url is true,
  call the function trim_url with an argument middle, substitute the result for trimmed.
  if autoescape is true and safe_input is false,
  call the function escape with an argument lead, substitute the result for lead, call the function escape with an argument trail,
  substitute the result for trail.   call the function escape with an argument url, substitute the result for url, call the function escape with an argument trimmed,
  substitute the result for trimmed.   middle is a string '<a href="%s"%s>%s</a>' formated with url, nofollow_attr and trimmed.
  format string '<a href="%s"%s>%s</a>' with lead, middle and trail, use it as an argument for the call to the function mark_safe,
  substitute the result for i-th element of words.   if not,
  if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  otherwise if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
<annotation_end_b>#<body_start>          self . fed . append ( d )
   def handle_entityref ( self , name ) :
          self . fed . append ( '&%s;' % name )
   def handle_charref ( self , name ) :
          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
            return s . get_data ( ) + s . rawdata
  else :
          return s . get_data ( )
     def strip_tags ( value ) :
   while '<' in value and '>' in value :
          new_value = _strip_once ( value )
 if new_value == value :
               break
  value = new_value
  return value
  strip_tags = allow_lazy ( strip_tags )
   def remove_tags ( html , tags ) :
 tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
 tags_re = '(%s)' % '|' . join ( tags )
 starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
 endtag_re = re . compile ( '</%s>' % tags_re )
 html = starttag_re . sub ( '' , html )
 html = endtag_re . sub ( '' , html )
 return html
  remove_tags = allow_lazy ( remove_tags , six . text_type )
   def strip_spaces_between_tags ( value ) :
 return re . sub ( r'>\s+<' , '><' , force_text ( value ) )
  strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
   def strip_entities ( value ) :
 return re . sub ( r'&(?:\w+|#\d+);' , '' , force_text ( value ) )
  strip_entities = allow_lazy ( strip_entities , six . text_type )
   def smart_urlquote ( url ) :
  try :
          scheme , netloc , path , query , fragment = urlsplit ( url )
 try :
              netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
              pass
  else :
              url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
   except ValueError :
           pass
   url = unquote ( force_str ( url ) )
  url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
  return force_text ( url )
    def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
 def trim_url ( x , limit = trim_url_limit ) :
          if limit is None or len ( x ) <= limit :
              return x
  return '%s...' % x [ : max ( 0 , limit - 3 ) ]
  safe_input = isinstance ( text , SafeData )
 words = word_split_re . split ( force_text ( text ) )
 for i , word in enumerate ( words ) :
          if '.' in word or '@' in word or ':' in word :
               lead , middle , trail = '' , word , ''
 for punctuation in TRAILING_PUNCTUATION :
                  if middle . endswith ( punctuation ) :
                      middle = middle [ : - len ( punctuation ) ]
 trail = punctuation + trail
   for opening , closing in WRAPPING_PUNCTUATION :
                  if middle . startswith ( opening ) :
                      middle = middle [ len ( opening ) : ]
 lead = lead + opening
   if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
                      middle = middle [ : - len ( closing ) ]
 trail = closing + trail
     url = None
 nofollow_attr = ' rel="nofollow"' if nofollow else ''
 if simple_url_re . match ( middle ) :
                  url = smart_urlquote ( middle )
  elif simple_url_2_re . match ( middle ) :
                  url = smart_urlquote ( 'http://%s' % middle )
  elif ':' not in middle and simple_email_re . match ( middle ) :
                  local , domain = middle . rsplit ( '@' , 1 )
 try :
                      domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
                      continue
  url = 'mailto:%s@%s' % ( local , domain )
 nofollow_attr = ''
    if url :
                  trimmed = trim_url ( middle )
 if autoescape and not safe_input :
                      lead , trail = escape ( lead ) , escape ( trail )
 url , trimmed = escape ( url ) , escape ( trimmed )
  middle = '<a href="%s"%s>%s</a>' % ( url , nofollow_attr , trimmed )
 words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )
  else :
                  if safe_input :
                      words [ i ] = mark_safe ( word )
  elif autoescape :
                      words [ i ] = escape ( word )
    elif safe_input :
              words [ i ] = mark_safe ( word )
  elif autoescape :
              words [ i ] = escape ( word )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
<annotation_end_b>#<body_start>              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
<body_end><annotation_start_b>  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
<annotation_end_b>#<body_start>              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
<body_end><annotation_start_b>  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
<annotation_end_b>#<body_start>              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
<body_end><annotation_start_b>  try,
  set field interesting for this class instance to interesting_cdata from module _html_parser.
  if AttributeError exception is caught,
  replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
  use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
  define method clear_cdata_mode, with self class instance as an argument.
  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
  return endpos.
  define the method parse_endtag with self class instance and i as the arguments.
  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
  return integer -1.
  find the ending position of the regular expression match of the object match, substitute the result for j.
  match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
  if there is no match,
  if self.cdata_tag is not None,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
<annotation_end_b>#<body_start>              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
<body_end><annotation_start_b>  call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
  set field cdata_tag for this class instance to None.
  define method set_cdata_mode, with self class instance and tag as the arguments.
  try,
  set field interesting for this class instance to interesting_cdata from module _html_parser.
  if AttributeError exception is caught,
  replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
  use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
  define method clear_cdata_mode, with self class instance as an argument.
  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
  return endpos.
  define the method parse_endtag with self class instance and i as the arguments.
  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
  return integer -1.
  find the ending position of the regular expression match of the object match, substitute the result for j.
  match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
  if there is no match,
  if self.cdata_tag is not None,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  slice the rawdata from i-th to the j-th element, replace with it '%r' in the string "bad end tag: %r", use it to call the method self.error.
  find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
  if self.cdata_tag is not None,
  convert tag to lowercase if it is not equal to self.cdata_tag,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
<annotation_end_b>#<body_start>              _html_parser . HTMLParser . __init__ ( self )
 self . cdata_tag = None
   def set_cdata_mode ( self , tag ) :
              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
 return j
  self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
   tag = match . group ( 1 ) . strip ( )
 if self . cdata_tag is not None :
                  if tag . lower ( ) != self . cdata_tag :
                      self . handle_data ( rawdata [ i : j ] )
<body_end><annotation_start_b>  and dictionary of arbitrary length **kwargs as arguments.   call the initialization method for the base class, _html_parser.HTMLParser.__init__ with self,
  convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments.   if not,
  substitute HTMLParser from the module _html_parser for HTMLParser.
  if not,
  compile a regular expression pattern string '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' into a regular expression object and assign it to tagfind.
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define initialization method __init__ with self instance of the class as an argument.
  call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
  set field cdata_tag for this class instance to None.
  define method set_cdata_mode, with self class instance and tag as the arguments.
  try,
  set field interesting for this class instance to interesting_cdata from module _html_parser.
  if AttributeError exception is caught,
  replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
  use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
  define method clear_cdata_mode, with self class instance as an argument.
  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
  return endpos.
  define the method parse_endtag with self class instance and i as the arguments.
  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
  return integer -1.
  find the ending position of the regular expression match of the object match, substitute the result for j.
  match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
  if there is no match,
  if self.cdata_tag is not None,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  slice the rawdata from i-th to the j-th element, replace with it '%r' in the string "bad end tag: %r", use it to call the method self.error.
  find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
  if self.cdata_tag is not None,
  convert tag to lowercase if it is not equal to self.cdata_tag,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  convert tag to lowercase, use it as the argument for the call to the method self.handle_endtag.
  call the method self.clear_cdata_mode.
<annotation_end_b>#<body_start>                  _html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
    else :
          HTMLParser = _html_parser . HTMLParser
   else :
      tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' )
  class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self ) :
              _html_parser . HTMLParser . __init__ ( self )
 self . cdata_tag = None
   def set_cdata_mode ( self , tag ) :
              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
 return j
  self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
   tag = match . group ( 1 ) . strip ( )
 if self . cdata_tag is not None :
                  if tag . lower ( ) != self . cdata_tag :
                      self . handle_data ( rawdata [ i : j ] )
 return j
    self . handle_endtag ( tag . lower ( ) )
 self . clear_cdata_mode ( )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if query is an instance of MultiValueDict class,
  call the method query.lists, substitute the result for query.
  otherwise if query has an attribute 'items',
  call the method query.items, substitute the result for query.
<annotation_end_b>#<body_start> if isinstance ( query , MultiValueDict ) :
          query = query . lists ( )
  elif hasattr ( query , 'items' ) :
          query = query . items ( )
<body_end><annotation_start_b>  call the function formatdate with an argument epoch_seconds, substitute the result for rfcdate.
<annotation_end_b>#<body_start> rfcdate = formatdate ( epoch_seconds )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  for every regex in tuple with 3 elements: RFC1123_DATE, RFC850_DATE and ASCTIME_DATE,
  call the method regex.match with an argument date, substitute the result for m.
  if m is not None,
  break from the loop execution.
  if not,
  raise an ValueError exception with an argument string "%r is not in a valid HTTP date format" formated with date.
  try,
  call the method m.group with an argument string 'year', convert the result into a string, substitute it for year.
  if year is lesser than integer 100,
  if year is lesser than integer 70,
  increment year by integer 2000.
  if not,
  increment year by integer 1900.
  call the method m.group with an argument string 'mon', convert the result to lowercase, use it as an argument for the call to the,
  method MONTHS.index, increment the result by integer 1, substitute it for month.   call the method m.group with an argument string 'fay', convert the result into a string, substitute it for day.
  call the method m.group with an argument string 'hour', convert the result into a string, substitute it for hour.
  call the method m.group with an argument string 'min', convert the result into a string, substitute it for min.
  call the method m.group with an argument string 'sec', convert the result into a string, substitute it for sec.
  call the method MONTHS.index with 6 arguments: year, month, day, hour, min and sec, substitute the result for result.
<annotation_end_b>#<body_start>    for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
          m = regex . match ( date )
 if m is not None :
              break
   else :
          raise ValueError ( "%r is not in a valid HTTP date format" % date )
  try :
          year = int ( m . group ( 'year' ) )
 if year < 100 :
              if year < 70 :
                  year += 2000
  else :
                  year += 1900
   month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1
 day = int ( m . group ( 'day' ) )
 hour = int ( m . group ( 'hour' ) )
 min = int ( m . group ( 'min' ) )
 sec = int ( m . group ( 'sec' ) )
 result = datetime . datetime ( year , month , day , hour , min , sec )
<body_end><annotation_start_b>  try,
<annotation_end_b>#<body_start> try :
<body_end><annotation_start_b>  if length of s is greater than integer 13,
  raise an ValueError exception with an argument string "Base36 input too large".
  convert s to integer of base 36, substitute it for value.
  if six.PY2 is true and value is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 input too large".
<annotation_end_b>#<body_start>    if len ( s ) > 13 :
          raise ValueError ( "Base36 input too large" )
  value = int ( s , 36 )
   if six . PY2 and value > sys . maxint :
          raise ValueError ( "Base36 input too large" )
<body_end><annotation_start_b>  digits is a string "0123456789abcdefghijklmnopqrstuvwxyz".
  factor is integer 0.
  if i is smaller than integer 0,
  raise an ValueError exception with an argument string "Negative base36 conversion input.".
  if six.PY2 is true,
  if i is not an instance of six.integer_types class,
  raise an TypeError exception with an argument string "Non-integer base36 conversion input.".
  if i is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 conversion input too large.".
  endless loop,
  increment factor by one.
  bring integer 36 to the power of factor, if i is smaller than the result,
  decrement factor by one.
  break from the loop execution.
  base36 is an empty list.
  while factor is greater or equal to integer 0,
  bring integer 36 to the power of factor, substitute the result for j.
  floor the division of i by j, use it an an index to get the element of the digits list, append the result for base36.
  i is the reminder of the division of i by j.
  decrement factor by one.
<annotation_end_b>#<body_start> digits = "0123456789abcdefghijklmnopqrstuvwxyz"
 factor = 0
 if i < 0 :
          raise ValueError ( "Negative base36 conversion input." )
  if six . PY2 :
          if not isinstance ( i , six . integer_types ) :
              raise TypeError ( "Non-integer base36 conversion input." )
  if i > sys . maxint :
              raise ValueError ( "Base36 conversion input too large." )
    while True :
          factor += 1
 if i < 36 ** factor :
              factor -= 1
 break
   base36 = [ ]
  while factor >= 0 :
          j = 36 ** factor
 base36 . append ( digits [ i // j ] )
 i = i % j
 factor -= 1
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  call the method s.encode with an argument string 'utf-8', substitute the result for s.
  try,
<annotation_end_b>#<body_start> s = s . encode ( 'utf-8' )
 try :
<body_end><annotation_start_b>  call the method ETAG_MATCH.findall with an argument etag_str, substitute the result for etags.
  if etags is false,
<annotation_end_b>#<body_start> etags = ETAG_MATCH . findall ( etag_str )
 if not etags :
<body_end><annotation_start_b>  if fist and second element of sys.version_info equals to integer 3 and 2, respectively,
  call the method HTMLParser.__init__ with 2 arguments: self and strict set to boolean False.
  if not,
  call the method HTMLParser.__init__ with an argument self.
  call the method self.reset.
  self.fed is an empty list.
  define the method handle_data with 2 arguments self and d.
  append d to self.fed.
  define the method handle_entityref with 2 arguments self and name.
  format string '&%s;' with name, append it to self.fed.
  define the method handle_charref with 2 arguments self and name.
  format string '&#%s;' with name, append it to self.fed.
  define the method get_data with an argument self.
  join elements of self.fed into a string, return the result.
  define the function _strip_once with an argument value.
  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
  return value.
  try,
  close file descriptor s.
  if HTMLParseError or UnboundLocalError exceptions are caught,
  sum the result of the method s.get_data and s.rawdata, return the result.
  if not,
  call the method s.get_data, return the result.
  define the function strip_tags with an argument value.
  while '<' is contained in value and '>' is contained in value,
  call the function _strip_once with an argument value, substitute the result for new_value.
  if new_value equals value,
  break from the loop execution.
  substitute new_value for value.
  return value.
  call the function allow_lazy with an argument strip_tags, substitute the result for strip_tags.
  define the function remove_tags with 2 arguments: html and tags.
  tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
  join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
  call the function re.compile with 2 arguments: raw string '<%s(/?>|(\s+[^>]*>))' formated with tags_re and re.U,
  substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
  call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  return html.
  call the function allow_lazy with 2 arguments: remove_tags, six.text_type, substitute the result for remove_tags.
  define the function strip_spaces_between_tags with an argument value.
  call the method re.sub with 3 arguments: raw string '>\s+<', string '><' and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_spaces_between_tags, six.text_type, substitute the result for strip_spaces_between_tags.
  define the function strip_entities with an argument value.
  call the method re.sub with 3 arguments: raw string '&(?:\w+|#\d+);', empty string and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_entities, six.text_type, substitute the result for strip_entities.
  define the function smart_urlquote with an argument url.
  try,
  call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
  try,
  call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
  substitute the result for netloc.   if UnicodeError exception is caught,
  do nothing.
  if not,
  call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
  if ValueError exception is caught,
  do nothing.
  call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
  call the function quote with 2 arguments: url and safe as bytes string '!*\'();:@&=+$,/?#[]~', substitute the result for url.
  call the function force_text with an argument url, return the result.
  define the function urlize with 4 arguments: text, trim_url_limit set to None, nofollow set to boolean False,
  define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
  if limit is None or length of x is lesser than or equal to limit,
  return x.
  return a string '%s...' formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit.
  if text is an instance of SafeData, safe_input is boolean True, otherwise is boolean False.
  call the function force_text with an argument text, split by it word_split_re, substitute it for words.
  for every i and word in enumerated iterable words,
  if '.' is contained in words or '@' is contained in word or ':' is contained in word,
  substitute empty string, word an empty string for lead, middle and trail, respectively.
  for every punctuation in TRAILING_PUNCTUATION,
  if middle ends with punctuation,
  substitute elements of middle from the beginning to the negative length of punctuation, for middle.
  sum punctuation and trail, substitute the result for trail.
  for every opening and closing in WRAPPING_PUNCTUATION,
  if middle starts with opening,
  substitute elements of middle from length of opening index to the end, for middle.
  sum lead and opening, substitute the result for lead.
  if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one,
  substitute elements of middle from the beginning to the negative length of closing, for middle.
  sum trail and closing, substitute the result for lead.
  url is None.
  if nofollow is true nofollow_attr is a string ' rel="nofollow"', otherwise nofollow_attr is an empty string.
  call the method simple_url_re.match with an argument middle, if it evaluates to true,
  call the function smart_urlquote with an argument middle, substitute the result for url.
  otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true,
  call the function smart_urlquote with an argument string 'http://%s' formated with an argument middle, substitute the result for url.
  otherwise if ':' is not contained in middle and result of the function simple_email_re.match called with an argument middle,
  evaluates to true,   split middle into two parts from the right by '@' character, assign the resulting parts to local and domain.
  try,
  call the method domain.encode with an argument string 'idna', call the method decode on the result with an argument string 'ascii',
  substitute the result for domain.   if UnicodeError exception is caught,
  skip this loop iteration.
  url is a string 'mailto:%s@%s' formated with local and domain.
  nofollow_attr is an empty string.
  if url is true,
  call the function trim_url with an argument middle, substitute the result for trimmed.
  if autoescape is true and safe_input is false,
  call the function escape with an argument lead, substitute the result for lead, call the function escape with an argument trail,
  substitute the result for trail.   call the function escape with an argument url, substitute the result for url, call the function escape with an argument trimmed,
  substitute the result for trimmed.   middle is a string '<a href="%s"%s>%s</a>' formated with url, nofollow_attr and trimmed.
  format string '<a href="%s"%s>%s</a>' with lead, middle and trail, use it as an argument for the call to the function mark_safe,
  substitute the result for i-th element of words.   if not,
  if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  otherwise if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  join elements of words into a string, return it.
  call the function allow_lazy with 2 arguments: urlize, six.text_type, substitute the result for urlize.
  define the function avoid_wrapping with an argument value.
  replace every occurrence of ' ' in value for '\xa0', return the result.
  from django.utils.six.moves import html_parser as _html_parse into default name space.
  import module re.
  import module sys.
  substitute version_info from module sys for surrent_version.
  set use_workaround to boolean True if current_version tuple elements are smaller than the tuple (2,7,3), respectively,
  or if current_version is greater than (3,0), but smaller than (3,2,3), otherwise set use_workaround to boolean False.   substitute HTMLParseError from the module _html_parser for HTMLParseError.
  if use_workaround is boolean False,
  if tuple current_version elements are greater or equal to (3, 4), respectively,
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define the initialization method __init__, with self instance of this class, convert_charrefs set to boolean False,
  and dictionary of arbitrary length **kwargs as arguments.   call the initialization method for the base class, _html_parser.HTMLParser.__init__ with self,
  convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments.   if not,
  substitute HTMLParser from the module _html_parser for HTMLParser.
  if not,
  compile a regular expression pattern string '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' into a regular expression object and assign it to tagfind.
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define initialization method __init__ with self instance of the class as an argument.
  call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
  set field cdata_tag for this class instance to None.
  define method set_cdata_mode, with self class instance and tag as the arguments.
  try,
  set field interesting for this class instance to interesting_cdata from module _html_parser.
  if AttributeError exception is caught,
  replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
  use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
  define method clear_cdata_mode, with self class instance as an argument.
  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
  return endpos.
  define the method parse_endtag with self class instance and i as the arguments.
  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
  return integer -1.
  find the ending position of the regular expression match of the object match, substitute the result for j.
  match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
  if there is no match,
  if self.cdata_tag is not None,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  slice the rawdata from i-th to the j-th element, replace with it '%r' in the string "bad end tag: %r", use it to call the method self.error.
  find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
  if self.cdata_tag is not None,
  convert tag to lowercase if it is not equal to self.cdata_tag,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  convert tag to lowercase, use it as the argument for the call to the method self.handle_endtag.
  call the method self.clear_cdata_mode.
  return j.
  from __future__ import unicode_literals into default name space.
  import module base64.
  import module calendar.
  import module datetime.
  import module re.
  import module sys.
  from binascii import Error as BinasciiError into default name space.
  from email.utils import formatdate into default name space.
  from django.utils.datastructures import MultiValueDict into default name space.
  from django.utils.encoding import force_str and force_text into default name space.
  from django.utils.functional import allow_lazy into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote, quote_plus, unquote, unquote_plus, urlparse, urlencode as original_urlencode.
  call the function re.compile with an argument raw string '(?:W/)?"((?:\\.|[^"])*)"', substitute the result for ETAG_MATCH.
  MONTHS is a list with 12 elements: strings 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', and 'dec'.
  __D is a raw string '(?P<day>\d{2})'.
  __D2 is a raw string '(?P<day>[ \d]\d)'.
  __M is a raw string '(?P<mon>\w{3})'.
  __Y is a raw string '(?P<year>\d{4})'.
  __Y2 is a raw string '(?P<year>\d{2})'.
  __T is a raw string '(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'.
  call the function re.compile with an argument raw string '^\w{3}, %s %s %s %s GMT$' formated with __D, __M, __Y and __T,
  substitute the result for RFC1123_DATE.   call the function re.compile with an argument raw string '^\w{6,9}, %s-%s-%s %s GMT$' formated with __D, __M, __Y2 and __T,
  substitute the result for RFC850_DATE.   call the function re.compile with an argument raw string '^\w{3} %s %s %s %s$' formated with __M, __D2, __T and __Y,
  substitute the result for ASCTIME_DATE.   define the function urlquote with 2 arguments: url and safe set to '/'.
  call the function quote with 2 arguments: result of the function force_str called with an argument url,
  and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote and six.text_type, substitute the result for urlquote.
  define the function urlquote_plus with 2 arguments: url and safe set to an empty string.
  call the function quote_plus with 2 arguments: result of the function force_str called with an argument url,
  and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote_plus and six.text_type, substitute the result for urlquote_plus.
  define the function urlunquote with an argument quoted_url.
  call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote,
  use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote and six.text_type, substitute the result for urlunquote.
  define the function urlunquote with an argument quoted_url.
  call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote_plus,
  use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote_plus and six.text_type, substitute the result for urlunquote_plus.
  define the function urlencode with 2 arguments query and doseq set to integer 0.
  if query is an instance of MultiValueDict class,
  call the method query.lists, substitute the result for query.
  otherwise if query has an attribute 'items',
  call the method query.items, substitute the result for query.
  call the function original_urlencode with 2 arguments: list with 2 elements: result of the function force_str with an argument k,
  and list with results of the function force_str with an argument i, for every i in v, only if v is a list or a tuple,   otherwise second element is result of the function force_str with an argument v, for every k and v in query,   and doseq, return the result.   define the function cookie_date with an argument epoch_seconds set to None.
  call the function formatdate with an argument epoch_seconds, substitute the result for rfcdate.
  return a string '%s-%s-%s GMT', formated with: first 7 elements of rfcdate, elements of rfcdate from 8-th to the 11-th index,
  and elements of rfcdate from 12-th to the 25-th index.   define the function http_date with an argument epoch_seconds set to None.
  call the function formatdate with 2 arguments: epoch_seconds and usegmt set to boolean True, return the result.
  define the function parse_http_date with an argument date.
  for every regex in tuple with 3 elements: RFC1123_DATE, RFC850_DATE and ASCTIME_DATE,
  call the method regex.match with an argument date, substitute the result for m.
  if m is not None,
  break from the loop execution.
  if not,
  raise an ValueError exception with an argument string "%r is not in a valid HTTP date format" formated with date.
  try,
  call the method m.group with an argument string 'year', convert the result into a string, substitute it for year.
  if year is lesser than integer 100,
  if year is lesser than integer 70,
  increment year by integer 2000.
  if not,
  increment year by integer 1900.
  call the method m.group with an argument string 'mon', convert the result to lowercase, use it as an argument for the call to the,
  method MONTHS.index, increment the result by integer 1, substitute it for month.   call the method m.group with an argument string 'fay', convert the result into a string, substitute it for day.
  call the method m.group with an argument string 'hour', convert the result into a string, substitute it for hour.
  call the method m.group with an argument string 'min', convert the result into a string, substitute it for min.
  call the method m.group with an argument string 'sec', convert the result into a string, substitute it for sec.
  call the method MONTHS.index with 6 arguments: year, month, day, hour, min and sec, substitute the result for result.
  call the method result.utctimetuple, use the result as an argument for the call to the method calendar.timegm, return the result.
  if Exception exception is caught.
  call the function six.reraise with 3 arguments: ValueError, instance of a class ValueError, created with an argument string,
  "%r is not a valid date" formated with date and third element of the result of the function sys.exc_info.   define the function parse_http_date_safe an argument date.
  try,
  call the function parse_http_date with an argument date, return the result.
  if Exception exception is caught.
  do nothing.
  define the functionbase36_to_int with an argument s.
  if length of s is greater than integer 13,
  raise an ValueError exception with an argument string "Base36 input too large".
  convert s to integer of base 36, substitute it for value.
  if six.PY2 is true and value is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 input too large".
  return value.
  define the function int_to_base36 with an argument i.
  digits is a string "0123456789abcdefghijklmnopqrstuvwxyz".
  factor is integer 0.
  if i is smaller than integer 0,
  raise an ValueError exception with an argument string "Negative base36 conversion input.".
  if six.PY2 is true,
  if i is not an instance of six.integer_types class,
  raise an TypeError exception with an argument string "Non-integer base36 conversion input.".
  if i is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 conversion input too large.".
  endless loop,
  increment factor by one.
  bring integer 36 to the power of factor, if i is smaller than the result,
  decrement factor by one.
  break from the loop execution.
  base36 is an empty list.
  while factor is greater or equal to integer 0,
  bring integer 36 to the power of factor, substitute the result for j.
  floor the division of i by j, use it an an index to get the element of the digits list, append the result for base36.
  i is the reminder of the division of i by j.
  decrement factor by one.
  join elements of base36 into a string, return it.
  define the function urlsafe_base64_encode with an argument s.
  call the method base64.urlsafe_b64encode with an argument s, strip the result of the bytes string '\n=' from the right, return it.
  define the function urlsafe_base64_decode with an argument s.
  call the method s.encode with an argument string 'utf-8', substitute the result for s.
  try,
  left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4,
  pad the rest of the field with bytes string '=', use the result as an argument for the call to the method base64.urlsafe_b64decode,   return the result.   if LookupError or BinasciiError, renamed to e, exceptions are caught.
  raise an ValueError exception with an argument e.
  define the function parse_etags with an argument etag_str.
  call the method ETAG_MATCH.findall with an argument etag_str, substitute the result for etags.
  if etags is false,
  return a list with an element etag_str.
  for every e in etags call the method e.encode with an argument string 'ascii', call the method decode on the result with an argument,
<annotation_end_b>#<body_start>            if sys . version_info [ : 2 ] == ( 3 , 2 ) :
              HTMLParser . __init__ ( self , strict = False )
  else :
              HTMLParser . __init__ ( self )
  self . reset ( )
 self . fed = [ ]
   def handle_data ( self , d ) :
          self . fed . append ( d )
   def handle_entityref ( self , name ) :
          self . fed . append ( '&%s;' % name )
   def handle_charref ( self , name ) :
          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
            return s . get_data ( ) + s . rawdata
  else :
          return s . get_data ( )
     def strip_tags ( value ) :
   while '<' in value and '>' in value :
          new_value = _strip_once ( value )
 if new_value == value :
               break
  value = new_value
  return value
  strip_tags = allow_lazy ( strip_tags )
   def remove_tags ( html , tags ) :
 tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
 tags_re = '(%s)' % '|' . join ( tags )
 starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
 endtag_re = re . compile ( '</%s>' % tags_re )
 html = starttag_re . sub ( '' , html )
 html = endtag_re . sub ( '' , html )
 return html
  remove_tags = allow_lazy ( remove_tags , six . text_type )
   def strip_spaces_between_tags ( value ) :
 return re . sub ( r'>\s+<' , '><' , force_text ( value ) )
  strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
   def strip_entities ( value ) :
 return re . sub ( r'&(?:\w+|#\d+);' , '' , force_text ( value ) )
  strip_entities = allow_lazy ( strip_entities , six . text_type )
   def smart_urlquote ( url ) :
  try :
          scheme , netloc , path , query , fragment = urlsplit ( url )
 try :
              netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
              pass
  else :
              url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
   except ValueError :
           pass
   url = unquote ( force_str ( url ) )
  url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
  return force_text ( url )
    def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
 def trim_url ( x , limit = trim_url_limit ) :
          if limit is None or len ( x ) <= limit :
              return x
  return '%s...' % x [ : max ( 0 , limit - 3 ) ]
  safe_input = isinstance ( text , SafeData )
 words = word_split_re . split ( force_text ( text ) )
 for i , word in enumerate ( words ) :
          if '.' in word or '@' in word or ':' in word :
               lead , middle , trail = '' , word , ''
 for punctuation in TRAILING_PUNCTUATION :
                  if middle . endswith ( punctuation ) :
                      middle = middle [ : - len ( punctuation ) ]
 trail = punctuation + trail
   for opening , closing in WRAPPING_PUNCTUATION :
                  if middle . startswith ( opening ) :
                      middle = middle [ len ( opening ) : ]
 lead = lead + opening
   if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
                      middle = middle [ : - len ( closing ) ]
 trail = closing + trail
     url = None
 nofollow_attr = ' rel="nofollow"' if nofollow else ''
 if simple_url_re . match ( middle ) :
                  url = smart_urlquote ( middle )
  elif simple_url_2_re . match ( middle ) :
                  url = smart_urlquote ( 'http://%s' % middle )
  elif ':' not in middle and simple_email_re . match ( middle ) :
                  local , domain = middle . rsplit ( '@' , 1 )
 try :
                      domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
                      continue
  url = 'mailto:%s@%s' % ( local , domain )
 nofollow_attr = ''
    if url :
                  trimmed = trim_url ( middle )
 if autoescape and not safe_input :
                      lead , trail = escape ( lead ) , escape ( trail )
 url , trimmed = escape ( url ) , escape ( trimmed )
  middle = '<a href="%s"%s>%s</a>' % ( url , nofollow_attr , trimmed )
 words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )
  else :
                  if safe_input :
                      words [ i ] = mark_safe ( word )
  elif autoescape :
                      words [ i ] = escape ( word )
    elif safe_input :
              words [ i ] = mark_safe ( word )
  elif autoescape :
              words [ i ] = escape ( word )
   return '' . join ( words )
  urlize = allow_lazy ( urlize , six . text_type )
   def avoid_wrapping ( value ) :
 return value . replace ( " " , "\xa0" )
from django . utils . six . moves import html_parser as _html_parser
 import re
 import sys
  current_version = sys . version_info
  use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )
  HTMLParseError = _html_parser . HTMLParseError
  if not use_workaround :
      if current_version >= ( 3 , 4 ) :
          class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self , convert_charrefs = False , ** kwargs ) :
                  _html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
    else :
          HTMLParser = _html_parser . HTMLParser
   else :
      tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' )
  class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self ) :
              _html_parser . HTMLParser . __init__ ( self )
 self . cdata_tag = None
   def set_cdata_mode ( self , tag ) :
              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
 return j
  self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
   tag = match . group ( 1 ) . strip ( )
 if self . cdata_tag is not None :
                  if tag . lower ( ) != self . cdata_tag :
                      self . handle_data ( rawdata [ i : j ] )
 return j
    self . handle_endtag ( tag . lower ( ) )
 self . clear_cdata_mode ( )
 return j
from __future__ import unicode_literals
  import base64
 import calendar
 import datetime
 import re
 import sys
  from binascii import Error as BinasciiError
 from email . utils import formatdate
  from django . utils . datastructures import MultiValueDict
 from django . utils . encoding import force_str , force_text
 from django . utils . functional import allow_lazy
 from django . utils import six
 from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )
  ETAG_MATCH = re . compile ( r'(?:W/)?"((?:\\.|[^"])*)"' )
  MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )
 __D = r'(?P<day>\d{2})'
 __D2 = r'(?P<day>[ \d]\d)'
 __M = r'(?P<mon>\w{3})'
 __Y = r'(?P<year>\d{4})'
 __Y2 = r'(?P<year>\d{2})'
 __T = r'(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'
 RFC1123_DATE = re . compile ( r'^\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )
 RFC850_DATE = re . compile ( r'^\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )
 ASCTIME_DATE = re . compile ( r'^\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )
   def urlquote ( url , safe = '/' ) :
 return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
  urlquote = allow_lazy ( urlquote , six . text_type )
   def urlquote_plus ( url , safe = '' ) :
 return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
  urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
   def urlunquote ( quoted_url ) :
 return force_text ( unquote ( force_str ( quoted_url ) ) )
  urlunquote = allow_lazy ( urlunquote , six . text_type )
   def urlunquote_plus ( quoted_url ) :
 return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
  urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
   def urlencode ( query , doseq = 0 ) :
 if isinstance ( query , MultiValueDict ) :
          query = query . lists ( )
  elif hasattr ( query , 'items' ) :
          query = query . items ( )
  return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )
    def cookie_date ( epoch_seconds = None ) :
 rfcdate = formatdate ( epoch_seconds )
 return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
    def http_date ( epoch_seconds = None ) :
 return formatdate ( epoch_seconds , usegmt = True )
    def parse_http_date ( date ) :
    for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
          m = regex . match ( date )
 if m is not None :
              break
   else :
          raise ValueError ( "%r is not in a valid HTTP date format" % date )
  try :
          year = int ( m . group ( 'year' ) )
 if year < 100 :
              if year < 70 :
                  year += 2000
  else :
                  year += 1900
   month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1
 day = int ( m . group ( 'day' ) )
 hour = int ( m . group ( 'hour' ) )
 min = int ( m . group ( 'min' ) )
 sec = int ( m . group ( 'sec' ) )
 result = datetime . datetime ( year , month , day , hour , min , sec )
 return calendar . timegm ( result . utctimetuple ( ) )
  except Exception :
          six . reraise ( ValueError , ValueError ( "%r is not a valid date" % date ) , sys . exc_info ( ) [ 2 ] )
     def parse_http_date_safe ( date ) :
 try :
          return parse_http_date ( date )
  except Exception :
          pass
       def base36_to_int ( s ) :
    if len ( s ) > 13 :
          raise ValueError ( "Base36 input too large" )
  value = int ( s , 36 )
   if six . PY2 and value > sys . maxint :
          raise ValueError ( "Base36 input too large" )
  return value
    def int_to_base36 ( i ) :
 digits = "0123456789abcdefghijklmnopqrstuvwxyz"
 factor = 0
 if i < 0 :
          raise ValueError ( "Negative base36 conversion input." )
  if six . PY2 :
          if not isinstance ( i , six . integer_types ) :
              raise TypeError ( "Non-integer base36 conversion input." )
  if i > sys . maxint :
              raise ValueError ( "Base36 conversion input too large." )
    while True :
          factor += 1
 if i < 36 ** factor :
              factor -= 1
 break
   base36 = [ ]
  while factor >= 0 :
          j = 36 ** factor
 base36 . append ( digits [ i // j ] )
 i = i % j
 factor -= 1
  return '' . join ( base36 )
    def urlsafe_base64_encode ( s ) :
 return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\n=' )
    def urlsafe_base64_decode ( s ) :
 s = s . encode ( 'utf-8' )
 try :
          return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )
  except ( LookupError , BinasciiError ) as e :
          raise ValueError ( e )
     def parse_etags ( etag_str ) :
 etags = ETAG_MATCH . findall ( etag_str )
 if not etags :
           return [ etag_str ]
  etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2.
  try,
<annotation_end_b>#<body_start> p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
 try :
<body_end><annotation_start_b>  if name equals string "_wrapped",
  substitute value under the "_wrapped" key of the self.__dict__ dictionary.
  if not,
  if self._wrapped is empty,
  call the method self._setup.
  set name attribute of self._wrapped object to value.
  define the method __delattr__ with 2 arguments self and name.
  if name equals string "_wrapped",
  raise an TypeError exception with an argument sting "can't delete _wrapped.".
  if self._wrapped is empty,
  call the method self._setup.
  delete name attribute from self._wrapped object.
  define the method _setup with an argument self.
  raise an NotImplementedError exception with an argument sting 'subclasses of LazyObject must provide a _setup() method'.
  define the method __getstate__ with an argument self.
  if self._wrapped is empty,
  call the method self._setup.
  return self._wrapped.__dict__.
  classmethod decorator,
  define the method __newobj__ with 2 arguments cls and unpacked list args.
  call the method cls.__new__ with 2 arguments: cls and unpacked list args.
  define the method __reduce_ex__ with 2 arguments self and proto.
  if proto is greater than or equal to integer 2,
  return a tuple with 3 elements: self.__newobj__, tuple with an element self.__class__ and result of the method self.__getstate__.
  if not,
  return a tuple with 3 elements: copyreg._reconstructor, tuple with 3 elements: self.__class__, object and None,
  and result of the method self.__getstate__.   define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  get type of self, call it and substitute the result for result.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
  call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
  if six.PY3 is true,
  call the function new_method_proxy with an argument bytes, substitute the result for __bytes__.
  call the function new_method_proxy with an argument str, substitute the result for __str__.
  call the function new_method_proxy with an argument bool, substitute the result for __bool__.
  if not,
  call the function new_method_proxy with an argument str, substitute the result for __str__.
  call the function new_method_proxy with an argument unicode, substitute the result for __unicode__.
  call the function new_method_proxy with an argument bool, substitute the result for __nonzero__.
  call the function new_method_proxy with an argument dir, substitute the result for __dir__.
  cal the method operator.attrgetter with an argument string "__class__", use the result as an argument for the call to the function,
  new_method_proxy, __class__ is an property object created with previous result as an argument.   call the function new_method_proxy with an argument operator.eq, substitute the result for __eq__.
  call the function new_method_proxy with an argument operator.ne, substitute the result for __ne__.
  call the function new_method_proxy with an argument hash, substitute the result for __hash__.
  call the function new_method_proxy with an argument operator.getitem, substitute the result for __getitem__.
  call the function new_method_proxy with an argument operator.setitem, substitute the result for __setitem__.
  call the function new_method_proxy with an argument operator.delitem, substitute the result for __delitem__.
  call the function new_method_proxy with an argument len, substitute the result for __len__.
  call the function new_method_proxy with an argument operator.contains, substitute the result for __contains__.
  substitute super for _super.
  derive the class SimpleLazyObject from the LazyObject base class.
  define the method __init__ with 2 arguments self and func.
  substitute func for value under the '_setupfunc' key of the self.__dict__ dictionary.
  call the function _super with 2 arguments: class SimpleLazyObject and self, call the method __init__ on the result.
  define the method _setup with an argument self.
  call the method self._setupfunc, substitute the result for self._wrapped.
  define the method __repr__ with an argument self.
  if self._wrapped is empty,
  substitute self._setupfunc for repr_attr.
  if not,
  substitute self._wrapped for repr_attr.
  return a string '<%s: %r>', format it with __name__ field of the self class and repr_attr.
  define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
  call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
  derive the class lazy_property from the property base class.
  define the method __new__ with 5 arguments: cls, fget set to None, fset set to None, fdel set to None and doc set to None.
  if fget is not None,
  decorator function wraps with an argument fget.
  define the function fget with 3 arguments: instance, instance_type set to None and name set to fget.__name__.
  get name attribute from the instance object, call it and return the result.
  if fset is not None,
  decorator function wraps with an argument fset.
  define the function fset with 3 arguments: instance, valse to None and name set to fset.__name__.
  get name attribute from the instance object, call it with an argument value and return the result.
  if fdel is not None,
  decorator function wraps with an argument fdel.
  define the function fdel with 2 arguments: instance and name set to fdel.__name__.
  get name attribute from the instance object, call it and return the result.
  return an property object with getter function fget, setter function fset, destructor fdel and documentation string doc.
  define the function partition with 2 arguments: predicate and values.
  results is a tuple with 2 elements, 2 empty lists.
  for every item in values,
  call the function predicate with an argument item, use it as a key to get results dictionary value, append item to it.
  return results.
  if sys.version_info is greater than or equal to a tuple with 3 elements: integers 2, 7 and 2, respectively,
  from functools import total_ordering.
  if not,
  define the function total_ordering with an argument cls.
  convert is a dictionary with 4 initial entries: list with 3 tuples: tuple with 2 elements: string '__gt__',
  and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other, for '__lt__',   list with 3 tuples: tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other,   or self is equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than or equal to other,   or self is not equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other, for '__le__',   list with 3 tuples: tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other, for '__gt__',   and list with 3 tuples: tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is not greater than or is not equal to other,   or self is equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than or not equal to other,   or self is not equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than or equal to other, for '__ge__',   convert cls to a dictionary, convert the result into a set and convert convert into a set, roots is a set of differences of the two previous sets.
  if roots is false,
  raise an ValueError exception with an argument string 'must define at least one ordering operation: < > <= >='.
  get maximal element from roots and substitute it for root.
  get the value under the root key of the convert dictionary, for every opname and opfunc in the result,
  if opname is not contained in roots,
  substitute opname for opfunc.__name__.
  get opname attribute from int object, substitute its field __doc__ for opfunc.__doc__.
  set opname attribute of cls object to opfunc.
  return cls.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module sys.
  from django.utils.encoding import force_text and force_str into default name space.
  from django.utils.functional import allow_lazy into default name space.
  from django.utils.safestring import SafeData and mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote, unquote, urlsplit and urlunsplit into default name space.
  from django.utils.text import normalize_newlines into default name space.
  from .html_parser import HTMLParser and HTMLParseError into default name space.
  TRAILING_PUNCTUATION is a list with 7 elements: '.', ',', ':', ';', '.)', '"' and '\''.
  WRAPPING_PUNCTUATION is a list with 6 elements: tuple with 2 elements: '(' and ')', tuple with 2 elements: '<' and '>',
  tuple with 2 elements: '[' and ']', tuple with 2 elements: '&lt' and '&gt', tuple with 2 elements: '"' and '"',   and tuple with 2 elements: '\'' and '\''.   DOTS is a list with 6 elements: strings '&middot;', '*', '\u2022', '&#149;', '&bull;' and '&#8226;'.
  call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for unencoded_ampersands_re.
  call the function re.compile with raw string '(\s+)', substitute the result for word_split_re.
  call the function re.compile with 2 arguments: raw string '^https?://\[?\w' and re.IGNORECASE, substitute the result for simple_url_re.
  call the function re.compile with 2 arguments: raw string '^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$',
  and re.IGNORECASE, substitute the result for simple_url_re.   call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for simple_email_re.
  call the function re.compile with raw string '(<a [^>]*?)target=[^\s>]+', substitute the result for link_target_attribute_re.
  call the function re.compile with 2 arguments:
  raw string '(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' and re.IGNORECASE,   substitute the result for html_gunk_re.   call the function re.compile with 2 arguments: raw string '((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)',
  formated with string created by joining elements of result of the function re.escape with an argument x, with separator '|',   for every x in DOTS, and re.DOTALL, substitute the result for hard_coded_bullets_re.   call the function re.compile with raw string '(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z', substitute the result for trailing_empty_content_re.
  define the function escape with an argument text.
  call the function force_text with an argument text, replace every occurrence of '&' in the result with '&amp;',
  every occurrence of '<' with '&lt;', every occurrence of '>' with '&gt;', every occurrence of '"' with '&quot;',   and every occurrence of "'" with '&#39;', call the function mark_safe with the previous result as an argument, return the result.   call the function allow_lazy with 2 arguments: escape, six.text_type, substitute the result for escape.
  _js_escapes is a dictionary with 11 initial entries: '\\u005C' for integer representation of string '\\',
  '\\u0027' for integer representation of string '\', '\\u0022' for integer representation of string '"',   '\\u003E' for integer representation of string '>', '\\u003C' for integer representation of string '<',   '\\u0026' for integer representation of string '%', '\\u003D' for integer representation of string '=',   '\\u002D' for integer representation of string '-', '\\u003B' for integer representation of string ';',   '\\u2028' for integer representation of string '\u2028' and '\\u2029' for integer representation of string '\u2029'.   for eery z in range of integers from 0 to 31, update _js_escapes dictionary with '\\u%04X' formated with z,
  for integer representation of z converted into a string.   define the function escapejs with an argument value.
  call the function force_text with an argument value, call the method translate on the result, with an argument _js_escapes,
  use the result as an argument for the call to the mark_safe function, return the result.   call the function allow_lazy with 2 arguments: escapejs, six.text_type, substitute the result for escapejs.
  define the function conditional_escape with an argument text.
  if text has an '__html__' attribute,
  call the method text.__html__, return the result.
  if not,
  call the function escape with an argument text, return the result.
  define the function format_html with 3 arguments: format_string, unpacked list args and unpacked dictionary kwargs.
  map elements from args through the function conditional_escape, substitute the result for args_safe.
  kwargs_safe is a dictionary created for every k and v in result of the function six.iteritems called with an argument kwargs,
  with value result of the conditional_escape function called with an argument v for key k.   call the method format_string.format with 2 arguments: unpacked list args_safe and unpacked dictionary kwargs_safe,
  use the result as an argument for the call to the function mark_safe, return the result.   define the function format_html_join with 3 arguments: sep, format_string and args_generator.
  join results of format_html called with 2 arguments: format_string and tuple with an element args, into a string,
  separated with result of the function conditional_escape with an argument sep, for every args in args_generator,   use the result as an argument for the call to the function mark_safe, return the result.   define the function linebreaks with 2 arguments: value and autoescape set to boolean False.
  call the function normalize_newlines with an argument value, substitute the result for value.
  call the method re.split with 2 arguments: string '\n{2,}' and value, substitute the result for paras.
  if autoescape is true,
  call the function escape with an argument p, replace every occurrence of '\n' in the result for '<br />',
  format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   if not,
  replace every occurrence of '\n' in p for '<br />',
  format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   join elements of paras into a string separated with '\n\n', return the result.
  call the function allow_lazy with 2 arguments: linebreaks, six.text_type, substitute the result for linebreaks.
  derive the class MLStripper from the HTMLParser base class.
  define the method __init__ with an argument self.
  if fist and second element of sys.version_info equals to integer 3 and 2, respectively,
  call the method HTMLParser.__init__ with 2 arguments: self and strict set to boolean False.
  if not,
  call the method HTMLParser.__init__ with an argument self.
  call the method self.reset.
  self.fed is an empty list.
  define the method handle_data with 2 arguments self and d.
  append d to self.fed.
  define the method handle_entityref with 2 arguments self and name.
  format string '&%s;' with name, append it to self.fed.
  define the method handle_charref with 2 arguments self and name.
  format string '&#%s;' with name, append it to self.fed.
  define the method get_data with an argument self.
  join elements of self.fed into a string, return the result.
  define the function _strip_once with an argument value.
  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
  return value.
  try,
  close file descriptor s.
  if HTMLParseError or UnboundLocalError exceptions are caught,
  sum the result of the method s.get_data and s.rawdata, return the result.
  if not,
  call the method s.get_data, return the result.
  define the function strip_tags with an argument value.
  while '<' is contained in value and '>' is contained in value,
  call the function _strip_once with an argument value, substitute the result for new_value.
  if new_value equals value,
  break from the loop execution.
  substitute new_value for value.
  return value.
  call the function allow_lazy with an argument strip_tags, substitute the result for strip_tags.
  define the function remove_tags with 2 arguments: html and tags.
  tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
  join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
  call the function re.compile with 2 arguments: raw string '<%s(/?>|(\s+[^>]*>))' formated with tags_re and re.U,
  substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
  call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  return html.
  call the function allow_lazy with 2 arguments: remove_tags, six.text_type, substitute the result for remove_tags.
  define the function strip_spaces_between_tags with an argument value.
  call the method re.sub with 3 arguments: raw string '>\s+<', string '><' and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_spaces_between_tags, six.text_type, substitute the result for strip_spaces_between_tags.
  define the function strip_entities with an argument value.
  call the method re.sub with 3 arguments: raw string '&(?:\w+|#\d+);', empty string and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_entities, six.text_type, substitute the result for strip_entities.
  define the function smart_urlquote with an argument url.
  try,
  call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
  try,
  call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
  substitute the result for netloc.   if UnicodeError exception is caught,
  do nothing.
  if not,
  call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
  if ValueError exception is caught,
  do nothing.
  call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
  call the function quote with 2 arguments: url and safe as bytes string '!*\'();:@&=+$,/?#[]~', substitute the result for url.
  call the function force_text with an argument url, return the result.
  define the function urlize with 4 arguments: text, trim_url_limit set to None, nofollow set to boolean False,
  define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
  if limit is None or length of x is lesser than or equal to limit,
  return x.
  return a string '%s...' formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit.
  if text is an instance of SafeData, safe_input is boolean True, otherwise is boolean False.
  call the function force_text with an argument text, split by it word_split_re, substitute it for words.
  for every i and word in enumerated iterable words,
  if '.' is contained in words or '@' is contained in word or ':' is contained in word,
  substitute empty string, word an empty string for lead, middle and trail, respectively.
  for every punctuation in TRAILING_PUNCTUATION,
  if middle ends with punctuation,
  substitute elements of middle from the beginning to the negative length of punctuation, for middle.
  sum punctuation and trail, substitute the result for trail.
  for every opening and closing in WRAPPING_PUNCTUATION,
  if middle starts with opening,
  substitute elements of middle from length of opening index to the end, for middle.
  sum lead and opening, substitute the result for lead.
  if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one,
  substitute elements of middle from the beginning to the negative length of closing, for middle.
  sum trail and closing, substitute the result for lead.
  url is None.
  if nofollow is true nofollow_attr is a string ' rel="nofollow"', otherwise nofollow_attr is an empty string.
  call the method simple_url_re.match with an argument middle, if it evaluates to true,
  call the function smart_urlquote with an argument middle, substitute the result for url.
  otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true,
  call the function smart_urlquote with an argument string 'http://%s' formated with an argument middle, substitute the result for url.
  otherwise if ':' is not contained in middle and result of the function simple_email_re.match called with an argument middle,
  evaluates to true,   split middle into two parts from the right by '@' character, assign the resulting parts to local and domain.
  try,
  call the method domain.encode with an argument string 'idna', call the method decode on the result with an argument string 'ascii',
  substitute the result for domain.   if UnicodeError exception is caught,
  skip this loop iteration.
  url is a string 'mailto:%s@%s' formated with local and domain.
  nofollow_attr is an empty string.
  if url is true,
  call the function trim_url with an argument middle, substitute the result for trimmed.
  if autoescape is true and safe_input is false,
  call the function escape with an argument lead, substitute the result for lead, call the function escape with an argument trail,
  substitute the result for trail.   call the function escape with an argument url, substitute the result for url, call the function escape with an argument trimmed,
  substitute the result for trimmed.   middle is a string '<a href="%s"%s>%s</a>' formated with url, nofollow_attr and trimmed.
  format string '<a href="%s"%s>%s</a>' with lead, middle and trail, use it as an argument for the call to the function mark_safe,
  substitute the result for i-th element of words.   if not,
  if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  otherwise if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  join elements of words into a string, return it.
  call the function allow_lazy with 2 arguments: urlize, six.text_type, substitute the result for urlize.
  define the function avoid_wrapping with an argument value.
  replace every occurrence of ' ' in value for '\xa0', return the result.
  from django.utils.six.moves import html_parser as _html_parse into default name space.
  import module re.
  import module sys.
  substitute version_info from module sys for surrent_version.
  set use_workaround to boolean True if current_version tuple elements are smaller than the tuple (2,7,3), respectively,
  or if current_version is greater than (3,0), but smaller than (3,2,3), otherwise set use_workaround to boolean False.   substitute HTMLParseError from the module _html_parser for HTMLParseError.
  if use_workaround is boolean False,
  if tuple current_version elements are greater or equal to (3, 4), respectively,
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define the initialization method __init__, with self instance of this class, convert_charrefs set to boolean False,
  and dictionary of arbitrary length **kwargs as arguments.   call the initialization method for the base class, _html_parser.HTMLParser.__init__ with self,
  convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments.   if not,
  substitute HTMLParser from the module _html_parser for HTMLParser.
  if not,
  compile a regular expression pattern string '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' into a regular expression object and assign it to tagfind.
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define initialization method __init__ with self instance of the class as an argument.
  call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
  set field cdata_tag for this class instance to None.
  define method set_cdata_mode, with self class instance and tag as the arguments.
  try,
  set field interesting for this class instance to interesting_cdata from module _html_parser.
  if AttributeError exception is caught,
  replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
  use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
  define method clear_cdata_mode, with self class instance as an argument.
  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
  return endpos.
  define the method parse_endtag with self class instance and i as the arguments.
  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
  return integer -1.
  find the ending position of the regular expression match of the object match, substitute the result for j.
  match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
  if there is no match,
  if self.cdata_tag is not None,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  slice the rawdata from i-th to the j-th element, replace with it '%r' in the string "bad end tag: %r", use it to call the method self.error.
  find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
  if self.cdata_tag is not None,
  convert tag to lowercase if it is not equal to self.cdata_tag,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  convert tag to lowercase, use it as the argument for the call to the method self.handle_endtag.
  call the method self.clear_cdata_mode.
  return j.
  from __future__ import unicode_literals into default name space.
  import module base64.
  import module calendar.
  import module datetime.
  import module re.
  import module sys.
  from binascii import Error as BinasciiError into default name space.
  from email.utils import formatdate into default name space.
  from django.utils.datastructures import MultiValueDict into default name space.
  from django.utils.encoding import force_str and force_text into default name space.
  from django.utils.functional import allow_lazy into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote, quote_plus, unquote, unquote_plus, urlparse, urlencode as original_urlencode.
  call the function re.compile with an argument raw string '(?:W/)?"((?:\\.|[^"])*)"', substitute the result for ETAG_MATCH.
  MONTHS is a list with 12 elements: strings 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', and 'dec'.
  __D is a raw string '(?P<day>\d{2})'.
  __D2 is a raw string '(?P<day>[ \d]\d)'.
  __M is a raw string '(?P<mon>\w{3})'.
  __Y is a raw string '(?P<year>\d{4})'.
  __Y2 is a raw string '(?P<year>\d{2})'.
  __T is a raw string '(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'.
  call the function re.compile with an argument raw string '^\w{3}, %s %s %s %s GMT$' formated with __D, __M, __Y and __T,
  substitute the result for RFC1123_DATE.   call the function re.compile with an argument raw string '^\w{6,9}, %s-%s-%s %s GMT$' formated with __D, __M, __Y2 and __T,
  substitute the result for RFC850_DATE.   call the function re.compile with an argument raw string '^\w{3} %s %s %s %s$' formated with __M, __D2, __T and __Y,
  substitute the result for ASCTIME_DATE.   define the function urlquote with 2 arguments: url and safe set to '/'.
  call the function quote with 2 arguments: result of the function force_str called with an argument url,
  and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote and six.text_type, substitute the result for urlquote.
  define the function urlquote_plus with 2 arguments: url and safe set to an empty string.
  call the function quote_plus with 2 arguments: result of the function force_str called with an argument url,
  and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote_plus and six.text_type, substitute the result for urlquote_plus.
  define the function urlunquote with an argument quoted_url.
  call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote,
  use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote and six.text_type, substitute the result for urlunquote.
  define the function urlunquote with an argument quoted_url.
  call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote_plus,
  use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote_plus and six.text_type, substitute the result for urlunquote_plus.
  define the function urlencode with 2 arguments query and doseq set to integer 0.
  if query is an instance of MultiValueDict class,
  call the method query.lists, substitute the result for query.
  otherwise if query has an attribute 'items',
  call the method query.items, substitute the result for query.
  call the function original_urlencode with 2 arguments: list with 2 elements: result of the function force_str with an argument k,
  and list with results of the function force_str with an argument i, for every i in v, only if v is a list or a tuple,   otherwise second element is result of the function force_str with an argument v, for every k and v in query,   and doseq, return the result.   define the function cookie_date with an argument epoch_seconds set to None.
  call the function formatdate with an argument epoch_seconds, substitute the result for rfcdate.
  return a string '%s-%s-%s GMT', formated with: first 7 elements of rfcdate, elements of rfcdate from 8-th to the 11-th index,
  and elements of rfcdate from 12-th to the 25-th index.   define the function http_date with an argument epoch_seconds set to None.
  call the function formatdate with 2 arguments: epoch_seconds and usegmt set to boolean True, return the result.
  define the function parse_http_date with an argument date.
  for every regex in tuple with 3 elements: RFC1123_DATE, RFC850_DATE and ASCTIME_DATE,
  call the method regex.match with an argument date, substitute the result for m.
  if m is not None,
  break from the loop execution.
  if not,
  raise an ValueError exception with an argument string "%r is not in a valid HTTP date format" formated with date.
  try,
  call the method m.group with an argument string 'year', convert the result into a string, substitute it for year.
  if year is lesser than integer 100,
  if year is lesser than integer 70,
  increment year by integer 2000.
  if not,
  increment year by integer 1900.
  call the method m.group with an argument string 'mon', convert the result to lowercase, use it as an argument for the call to the,
  method MONTHS.index, increment the result by integer 1, substitute it for month.   call the method m.group with an argument string 'fay', convert the result into a string, substitute it for day.
  call the method m.group with an argument string 'hour', convert the result into a string, substitute it for hour.
  call the method m.group with an argument string 'min', convert the result into a string, substitute it for min.
  call the method m.group with an argument string 'sec', convert the result into a string, substitute it for sec.
  call the method MONTHS.index with 6 arguments: year, month, day, hour, min and sec, substitute the result for result.
  call the method result.utctimetuple, use the result as an argument for the call to the method calendar.timegm, return the result.
  if Exception exception is caught.
  call the function six.reraise with 3 arguments: ValueError, instance of a class ValueError, created with an argument string,
  "%r is not a valid date" formated with date and third element of the result of the function sys.exc_info.   define the function parse_http_date_safe an argument date.
  try,
  call the function parse_http_date with an argument date, return the result.
  if Exception exception is caught.
  do nothing.
  define the functionbase36_to_int with an argument s.
  if length of s is greater than integer 13,
  raise an ValueError exception with an argument string "Base36 input too large".
  convert s to integer of base 36, substitute it for value.
  if six.PY2 is true and value is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 input too large".
  return value.
  define the function int_to_base36 with an argument i.
  digits is a string "0123456789abcdefghijklmnopqrstuvwxyz".
  factor is integer 0.
  if i is smaller than integer 0,
  raise an ValueError exception with an argument string "Negative base36 conversion input.".
  if six.PY2 is true,
  if i is not an instance of six.integer_types class,
  raise an TypeError exception with an argument string "Non-integer base36 conversion input.".
  if i is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 conversion input too large.".
  endless loop,
  increment factor by one.
  bring integer 36 to the power of factor, if i is smaller than the result,
  decrement factor by one.
  break from the loop execution.
  base36 is an empty list.
  while factor is greater or equal to integer 0,
  bring integer 36 to the power of factor, substitute the result for j.
  floor the division of i by j, use it an an index to get the element of the digits list, append the result for base36.
  i is the reminder of the division of i by j.
  decrement factor by one.
  join elements of base36 into a string, return it.
  define the function urlsafe_base64_encode with an argument s.
  call the method base64.urlsafe_b64encode with an argument s, strip the result of the bytes string '\n=' from the right, return it.
  define the function urlsafe_base64_decode with an argument s.
  call the method s.encode with an argument string 'utf-8', substitute the result for s.
  try,
  left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4,
  pad the rest of the field with bytes string '=', use the result as an argument for the call to the method base64.urlsafe_b64decode,   return the result.   if LookupError or BinasciiError, renamed to e, exceptions are caught.
  raise an ValueError exception with an argument e.
  define the function parse_etags with an argument etag_str.
  call the method ETAG_MATCH.findall with an argument etag_str, substitute the result for etags.
  if etags is false,
  return a list with an element etag_str.
  for every e in etags call the method e.encode with an argument string 'ascii', call the method decode on the result with an argument,
  string 'unicode_escape', substitute the list of results for etags.   return etags.
  define the function quote_etag with an argument etag.
  return a string '"%s"' formated with etag, in which every occurrence of '\\' is replaced with '\\\\' and every occurrence of '"',
  is replaced with '\\"'.   define the function same_origin with 2 arguments url1 and url2.
  substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2.
  try,
  if p2.scheme, p2.hostname and p2.port equals p1.scheme, p1.hostname and p1.port, respectively, return boolean True, otherwise return boolean False.
  if ValueError exception is caught.
<annotation_end_b>#<body_start>          if name == "_wrapped" :
               self . __dict__ [ "_wrapped" ] = value
  else :
              if self . _wrapped is empty :
                  self . _setup ( )
  setattr ( self . _wrapped , name , value )
    def __delattr__ ( self , name ) :
          if name == "_wrapped" :
              raise TypeError ( "can't delete _wrapped." )
  if self . _wrapped is empty :
              self . _setup ( )
  delattr ( self . _wrapped , name )
   def _setup ( self ) :
 raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )
        def __getstate__ ( self ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return self . _wrapped . __dict__
     @ classmethod
 def __newobj__ ( cls , * args ) :
          return cls . __new__ ( cls , * args )
   def __reduce_ex__ ( self , proto ) :
          if proto >= 2 :
                return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
  else :
                  return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )
    def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = type ( self ) ( )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
   if six . PY3 :
          __bytes__ = new_method_proxy ( bytes )
 __str__ = new_method_proxy ( str )
 __bool__ = new_method_proxy ( bool )
  else :
          __str__ = new_method_proxy ( str )
 __unicode__ = new_method_proxy ( unicode )
 __nonzero__ = new_method_proxy ( bool )
    __dir__ = new_method_proxy ( dir )
    __class__ = property ( new_method_proxy ( operator . attrgetter ( "__class__" ) ) )
 __eq__ = new_method_proxy ( operator . eq )
 __ne__ = new_method_proxy ( operator . ne )
 __hash__ = new_method_proxy ( hash )
   __getitem__ = new_method_proxy ( operator . getitem )
 __setitem__ = new_method_proxy ( operator . setitem )
 __delitem__ = new_method_proxy ( operator . delitem )
  __len__ = new_method_proxy ( len )
 __contains__ = new_method_proxy ( operator . contains )
     _super = super
   class SimpleLazyObject ( LazyObject ) :
 def __init__ ( self , func ) :
 self . __dict__ [ '_setupfunc' ] = func
 _super ( SimpleLazyObject , self ) . __init__ ( )
   def _setup ( self ) :
          self . _wrapped = self . _setupfunc ( )
     def __repr__ ( self ) :
          if self . _wrapped is empty :
              repr_attr = self . _setupfunc
  else :
              repr_attr = self . _wrapped
  return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )
   def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = SimpleLazyObject ( self . _setupfunc )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
     class lazy_property ( property ) :
 def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :
          if fget is not None :
              @ wraps ( fget )
 def fget ( instance , instance_type = None , name = fget . __name__ ) :
                  return getattr ( instance , name ) ( )
   if fset is not None :
              @ wraps ( fset )
 def fset ( instance , value , name = fset . __name__ ) :
                  return getattr ( instance , name ) ( value )
   if fdel is not None :
              @ wraps ( fdel )
 def fdel ( instance , name = fdel . __name__ ) :
                  return getattr ( instance , name ) ( )
   return property ( fget , fset , fdel , doc )
     def partition ( predicate , values ) :
 results = ( [ ] , [ ] )
 for item in values :
          results [ predicate ( item ) ] . append ( item )
  return results
   if sys . version_info >= ( 2 , 7 , 2 ) :
      from functools import total_ordering
  else :
         def total_ordering ( cls ) :
 convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
 roots = set ( dir ( cls ) ) & set ( convert )
 if not roots :
              raise ValueError ( 'must define at least one ordering operation: < > <= >=' )
  root = max ( roots )
 for opname , opfunc in convert [ root ] :
              if opname not in roots :
                  opfunc . __name__ = opname
 opfunc . __doc__ = getattr ( int , opname ) . __doc__
 setattr ( cls , opname , opfunc )
   return cls
  from __future__ import unicode_literals
  import re
 import sys
  from django . utils . encoding import force_text , force_str
 from django . utils . functional import allow_lazy
 from django . utils . safestring import SafeData , mark_safe
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
 from django . utils . text import normalize_newlines
  from . html_parser import HTMLParser , HTMLParseError
    TRAILING_PUNCTUATION = [ '.' , ',' , ':' , ';' , '.)' , '"' , '\'' ]
 WRAPPING_PUNCTUATION = [ ( '(' , ')' ) , ( '<' , '>' ) , ( '[' , ']' ) , ( '&lt;' , '&gt;' ) , ( '"' , '"' ) , ( '\'' , '\'' ) ]
   DOTS = [ '&middot;' , '*' , '\u2022' , '&#149;' , '&bull;' , '&#8226;' ]
  unencoded_ampersands_re = re . compile ( r'&(?!(\w+|#\d+);)' )
 word_split_re = re . compile ( r'(\s+)' )
 simple_url_re = re . compile ( r'^https?://\[?\w' , re . IGNORECASE )
 simple_url_2_re = re . compile ( r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$' , re . IGNORECASE )
 simple_email_re = re . compile ( r'^\S+@\S+\.\S+$' )
 link_target_attribute_re = re . compile ( r'(<a [^>]*?)target=[^\s>]+' )
 html_gunk_re = re . compile ( r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' , re . IGNORECASE )
 hard_coded_bullets_re = re . compile ( r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
 trailing_empty_content_re = re . compile ( r'(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z' )
   def escape ( text ) :
 return mark_safe ( force_text ( text ) . replace ( '&' , '&amp;' ) . replace ( '<' , '&lt;' ) . replace ( '>' , '&gt;' ) . replace ( '"' , '&quot;' ) . replace ( "'" , '&#39;' ) )
  escape = allow_lazy ( escape , six . text_type )
  _js_escapes = {  ord ( '\\' ) : '\\u005C' ,  ord ( '\'' ) : '\\u0027' ,  ord ( '"' ) : '\\u0022' ,  ord ( '>' ) : '\\u003E' ,  ord ( '<' ) : '\\u003C' ,  ord ( '&' ) : '\\u0026' ,  ord ( '=' ) : '\\u003D' ,  ord ( '-' ) : '\\u002D' ,  ord ( ';' ) : '\\u003B' ,  ord ( '\u2028' ) : '\\u2028' ,  ord ( '\u2029' ) : '\\u2029'  }
   _js_escapes . update ( ( ord ( '%c' % z ) , '\\u%04X' % z ) for z in range ( 32 ) )
   def escapejs ( value ) :
 return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )
  escapejs = allow_lazy ( escapejs , six . text_type )
   def conditional_escape ( text ) :
 if hasattr ( text , '__html__' ) :
          return text . __html__ ( )
  else :
          return escape ( text )
     def format_html ( format_string , * args , ** kwargs ) :
 args_safe = map ( conditional_escape , args )
 kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
 return mark_safe ( format_string . format ( * args_safe , ** kwargs_safe ) )
    def format_html_join ( sep , format_string , args_generator ) :
 return mark_safe ( conditional_escape ( sep ) . join (  format_html ( format_string , * tuple ( args ) )  for args in args_generator ) )
    def linebreaks ( value , autoescape = False ) :
 value = normalize_newlines ( value )
 paras = re . split ( '\n{2,}' , value )
 if autoescape :
          paras = [ '<p>%s</p>' % escape ( p ) . replace ( '\n' , '<br />' ) for p in paras ]
  else :
          paras = [ '<p>%s</p>' % p . replace ( '\n' , '<br />' ) for p in paras ]
  return '\n\n' . join ( paras )
  linebreaks = allow_lazy ( linebreaks , six . text_type )
   class MLStripper ( HTMLParser ) :
      def __init__ ( self ) :
            if sys . version_info [ : 2 ] == ( 3 , 2 ) :
              HTMLParser . __init__ ( self , strict = False )
  else :
              HTMLParser . __init__ ( self )
  self . reset ( )
 self . fed = [ ]
   def handle_data ( self , d ) :
          self . fed . append ( d )
   def handle_entityref ( self , name ) :
          self . fed . append ( '&%s;' % name )
   def handle_charref ( self , name ) :
          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
            return s . get_data ( ) + s . rawdata
  else :
          return s . get_data ( )
     def strip_tags ( value ) :
   while '<' in value and '>' in value :
          new_value = _strip_once ( value )
 if new_value == value :
               break
  value = new_value
  return value
  strip_tags = allow_lazy ( strip_tags )
   def remove_tags ( html , tags ) :
 tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
 tags_re = '(%s)' % '|' . join ( tags )
 starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
 endtag_re = re . compile ( '</%s>' % tags_re )
 html = starttag_re . sub ( '' , html )
 html = endtag_re . sub ( '' , html )
 return html
  remove_tags = allow_lazy ( remove_tags , six . text_type )
   def strip_spaces_between_tags ( value ) :
 return re . sub ( r'>\s+<' , '><' , force_text ( value ) )
  strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
   def strip_entities ( value ) :
 return re . sub ( r'&(?:\w+|#\d+);' , '' , force_text ( value ) )
  strip_entities = allow_lazy ( strip_entities , six . text_type )
   def smart_urlquote ( url ) :
  try :
          scheme , netloc , path , query , fragment = urlsplit ( url )
 try :
              netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
              pass
  else :
              url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
   except ValueError :
           pass
   url = unquote ( force_str ( url ) )
  url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
  return force_text ( url )
    def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
 def trim_url ( x , limit = trim_url_limit ) :
          if limit is None or len ( x ) <= limit :
              return x
  return '%s...' % x [ : max ( 0 , limit - 3 ) ]
  safe_input = isinstance ( text , SafeData )
 words = word_split_re . split ( force_text ( text ) )
 for i , word in enumerate ( words ) :
          if '.' in word or '@' in word or ':' in word :
               lead , middle , trail = '' , word , ''
 for punctuation in TRAILING_PUNCTUATION :
                  if middle . endswith ( punctuation ) :
                      middle = middle [ : - len ( punctuation ) ]
 trail = punctuation + trail
   for opening , closing in WRAPPING_PUNCTUATION :
                  if middle . startswith ( opening ) :
                      middle = middle [ len ( opening ) : ]
 lead = lead + opening
   if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
                      middle = middle [ : - len ( closing ) ]
 trail = closing + trail
     url = None
 nofollow_attr = ' rel="nofollow"' if nofollow else ''
 if simple_url_re . match ( middle ) :
                  url = smart_urlquote ( middle )
  elif simple_url_2_re . match ( middle ) :
                  url = smart_urlquote ( 'http://%s' % middle )
  elif ':' not in middle and simple_email_re . match ( middle ) :
                  local , domain = middle . rsplit ( '@' , 1 )
 try :
                      domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
                      continue
  url = 'mailto:%s@%s' % ( local , domain )
 nofollow_attr = ''
    if url :
                  trimmed = trim_url ( middle )
 if autoescape and not safe_input :
                      lead , trail = escape ( lead ) , escape ( trail )
 url , trimmed = escape ( url ) , escape ( trimmed )
  middle = '<a href="%s"%s>%s</a>' % ( url , nofollow_attr , trimmed )
 words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )
  else :
                  if safe_input :
                      words [ i ] = mark_safe ( word )
  elif autoescape :
                      words [ i ] = escape ( word )
    elif safe_input :
              words [ i ] = mark_safe ( word )
  elif autoescape :
              words [ i ] = escape ( word )
   return '' . join ( words )
  urlize = allow_lazy ( urlize , six . text_type )
   def avoid_wrapping ( value ) :
 return value . replace ( " " , "\xa0" )
from django . utils . six . moves import html_parser as _html_parser
 import re
 import sys
  current_version = sys . version_info
  use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )
  HTMLParseError = _html_parser . HTMLParseError
  if not use_workaround :
      if current_version >= ( 3 , 4 ) :
          class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self , convert_charrefs = False , ** kwargs ) :
                  _html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
    else :
          HTMLParser = _html_parser . HTMLParser
   else :
      tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' )
  class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self ) :
              _html_parser . HTMLParser . __init__ ( self )
 self . cdata_tag = None
   def set_cdata_mode ( self , tag ) :
              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
 return j
  self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
   tag = match . group ( 1 ) . strip ( )
 if self . cdata_tag is not None :
                  if tag . lower ( ) != self . cdata_tag :
                      self . handle_data ( rawdata [ i : j ] )
 return j
    self . handle_endtag ( tag . lower ( ) )
 self . clear_cdata_mode ( )
 return j
from __future__ import unicode_literals
  import base64
 import calendar
 import datetime
 import re
 import sys
  from binascii import Error as BinasciiError
 from email . utils import formatdate
  from django . utils . datastructures import MultiValueDict
 from django . utils . encoding import force_str , force_text
 from django . utils . functional import allow_lazy
 from django . utils import six
 from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )
  ETAG_MATCH = re . compile ( r'(?:W/)?"((?:\\.|[^"])*)"' )
  MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )
 __D = r'(?P<day>\d{2})'
 __D2 = r'(?P<day>[ \d]\d)'
 __M = r'(?P<mon>\w{3})'
 __Y = r'(?P<year>\d{4})'
 __Y2 = r'(?P<year>\d{2})'
 __T = r'(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'
 RFC1123_DATE = re . compile ( r'^\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )
 RFC850_DATE = re . compile ( r'^\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )
 ASCTIME_DATE = re . compile ( r'^\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )
   def urlquote ( url , safe = '/' ) :
 return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
  urlquote = allow_lazy ( urlquote , six . text_type )
   def urlquote_plus ( url , safe = '' ) :
 return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
  urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
   def urlunquote ( quoted_url ) :
 return force_text ( unquote ( force_str ( quoted_url ) ) )
  urlunquote = allow_lazy ( urlunquote , six . text_type )
   def urlunquote_plus ( quoted_url ) :
 return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
  urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
   def urlencode ( query , doseq = 0 ) :
 if isinstance ( query , MultiValueDict ) :
          query = query . lists ( )
  elif hasattr ( query , 'items' ) :
          query = query . items ( )
  return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )
    def cookie_date ( epoch_seconds = None ) :
 rfcdate = formatdate ( epoch_seconds )
 return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
    def http_date ( epoch_seconds = None ) :
 return formatdate ( epoch_seconds , usegmt = True )
    def parse_http_date ( date ) :
    for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
          m = regex . match ( date )
 if m is not None :
              break
   else :
          raise ValueError ( "%r is not in a valid HTTP date format" % date )
  try :
          year = int ( m . group ( 'year' ) )
 if year < 100 :
              if year < 70 :
                  year += 2000
  else :
                  year += 1900
   month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1
 day = int ( m . group ( 'day' ) )
 hour = int ( m . group ( 'hour' ) )
 min = int ( m . group ( 'min' ) )
 sec = int ( m . group ( 'sec' ) )
 result = datetime . datetime ( year , month , day , hour , min , sec )
 return calendar . timegm ( result . utctimetuple ( ) )
  except Exception :
          six . reraise ( ValueError , ValueError ( "%r is not a valid date" % date ) , sys . exc_info ( ) [ 2 ] )
     def parse_http_date_safe ( date ) :
 try :
          return parse_http_date ( date )
  except Exception :
          pass
       def base36_to_int ( s ) :
    if len ( s ) > 13 :
          raise ValueError ( "Base36 input too large" )
  value = int ( s , 36 )
   if six . PY2 and value > sys . maxint :
          raise ValueError ( "Base36 input too large" )
  return value
    def int_to_base36 ( i ) :
 digits = "0123456789abcdefghijklmnopqrstuvwxyz"
 factor = 0
 if i < 0 :
          raise ValueError ( "Negative base36 conversion input." )
  if six . PY2 :
          if not isinstance ( i , six . integer_types ) :
              raise TypeError ( "Non-integer base36 conversion input." )
  if i > sys . maxint :
              raise ValueError ( "Base36 conversion input too large." )
    while True :
          factor += 1
 if i < 36 ** factor :
              factor -= 1
 break
   base36 = [ ]
  while factor >= 0 :
          j = 36 ** factor
 base36 . append ( digits [ i // j ] )
 i = i % j
 factor -= 1
  return '' . join ( base36 )
    def urlsafe_base64_encode ( s ) :
 return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\n=' )
    def urlsafe_base64_decode ( s ) :
 s = s . encode ( 'utf-8' )
 try :
          return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )
  except ( LookupError , BinasciiError ) as e :
          raise ValueError ( e )
     def parse_etags ( etag_str ) :
 etags = ETAG_MATCH . findall ( etag_str )
 if not etags :
           return [ etag_str ]
  etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]
 return etags
    def quote_etag ( etag ) :
 return '"%s"' % etag . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' )
    def same_origin ( url1 , url2 ) :
 p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
 try :
          return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )
  except ValueError :
<body_end><annotation_start_b>  if url is false,
<annotation_end_b>#<body_start> if not url :
<body_end><annotation_start_b>  substitute empty for self._wrapped.
  call the function new_method_proxy with an argument getattr, substitute the result for __getattr__.
  define the method __setattr__ with 3 arguments: self, name and value.
  if name equals string "_wrapped",
  substitute value under the "_wrapped" key of the self.__dict__ dictionary.
  if not,
  if self._wrapped is empty,
  call the method self._setup.
  set name attribute of self._wrapped object to value.
  define the method __delattr__ with 2 arguments self and name.
  if name equals string "_wrapped",
  raise an TypeError exception with an argument sting "can't delete _wrapped.".
  if self._wrapped is empty,
  call the method self._setup.
  delete name attribute from self._wrapped object.
  define the method _setup with an argument self.
  raise an NotImplementedError exception with an argument sting 'subclasses of LazyObject must provide a _setup() method'.
  define the method __getstate__ with an argument self.
  if self._wrapped is empty,
  call the method self._setup.
  return self._wrapped.__dict__.
  classmethod decorator,
  define the method __newobj__ with 2 arguments cls and unpacked list args.
  call the method cls.__new__ with 2 arguments: cls and unpacked list args.
  define the method __reduce_ex__ with 2 arguments self and proto.
  if proto is greater than or equal to integer 2,
  return a tuple with 3 elements: self.__newobj__, tuple with an element self.__class__ and result of the method self.__getstate__.
  if not,
  return a tuple with 3 elements: copyreg._reconstructor, tuple with 3 elements: self.__class__, object and None,
  and result of the method self.__getstate__.   define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  get type of self, call it and substitute the result for result.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
  call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
  if six.PY3 is true,
  call the function new_method_proxy with an argument bytes, substitute the result for __bytes__.
  call the function new_method_proxy with an argument str, substitute the result for __str__.
  call the function new_method_proxy with an argument bool, substitute the result for __bool__.
  if not,
  call the function new_method_proxy with an argument str, substitute the result for __str__.
  call the function new_method_proxy with an argument unicode, substitute the result for __unicode__.
  call the function new_method_proxy with an argument bool, substitute the result for __nonzero__.
  call the function new_method_proxy with an argument dir, substitute the result for __dir__.
  cal the method operator.attrgetter with an argument string "__class__", use the result as an argument for the call to the function,
  new_method_proxy, __class__ is an property object created with previous result as an argument.   call the function new_method_proxy with an argument operator.eq, substitute the result for __eq__.
  call the function new_method_proxy with an argument operator.ne, substitute the result for __ne__.
  call the function new_method_proxy with an argument hash, substitute the result for __hash__.
  call the function new_method_proxy with an argument operator.getitem, substitute the result for __getitem__.
  call the function new_method_proxy with an argument operator.setitem, substitute the result for __setitem__.
  call the function new_method_proxy with an argument operator.delitem, substitute the result for __delitem__.
  call the function new_method_proxy with an argument len, substitute the result for __len__.
  call the function new_method_proxy with an argument operator.contains, substitute the result for __contains__.
  substitute super for _super.
  derive the class SimpleLazyObject from the LazyObject base class.
  define the method __init__ with 2 arguments self and func.
  substitute func for value under the '_setupfunc' key of the self.__dict__ dictionary.
  call the function _super with 2 arguments: class SimpleLazyObject and self, call the method __init__ on the result.
  define the method _setup with an argument self.
  call the method self._setupfunc, substitute the result for self._wrapped.
  define the method __repr__ with an argument self.
  if self._wrapped is empty,
  substitute self._setupfunc for repr_attr.
  if not,
  substitute self._wrapped for repr_attr.
  return a string '<%s: %r>', format it with __name__ field of the self class and repr_attr.
  define the method __deepcopy__ with 2 arguments self and memo.
  if self._wrapped is empty,
  result is an instance of SimpleLazyObject class, created with an argument self._setupfunc.
  get the id of the self object, use it as a key to obtain the value from the memo dictionary, substitute self with it.
  return result.
  call the method copy.deepcopy with 2 arguments: self._wrapped and memo, return the result.
  derive the class lazy_property from the property base class.
  define the method __new__ with 5 arguments: cls, fget set to None, fset set to None, fdel set to None and doc set to None.
  if fget is not None,
  decorator function wraps with an argument fget.
  define the function fget with 3 arguments: instance, instance_type set to None and name set to fget.__name__.
  get name attribute from the instance object, call it and return the result.
  if fset is not None,
  decorator function wraps with an argument fset.
  define the function fset with 3 arguments: instance, valse to None and name set to fset.__name__.
  get name attribute from the instance object, call it with an argument value and return the result.
  if fdel is not None,
  decorator function wraps with an argument fdel.
  define the function fdel with 2 arguments: instance and name set to fdel.__name__.
  get name attribute from the instance object, call it and return the result.
  return an property object with getter function fget, setter function fset, destructor fdel and documentation string doc.
  define the function partition with 2 arguments: predicate and values.
  results is a tuple with 2 elements, 2 empty lists.
  for every item in values,
  call the function predicate with an argument item, use it as a key to get results dictionary value, append item to it.
  return results.
  if sys.version_info is greater than or equal to a tuple with 3 elements: integers 2, 7 and 2, respectively,
  from functools import total_ordering.
  if not,
  define the function total_ordering with an argument cls.
  convert is a dictionary with 4 initial entries: list with 3 tuples: tuple with 2 elements: string '__gt__',
  and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than other, for '__lt__',   list with 3 tuples: tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other,   or self is equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is lesser than or equal to other,   or self is not equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is lesser than or equal to other, for '__le__',   list with 3 tuples: tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other or self is equal to other,   tuple with 2 elements: string '__ge__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than other or self is equal to other,   tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than other, for '__gt__',   and list with 3 tuples: tuple with 2 elements: string '__le__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is not greater than or is not equal to other,   or self is equal to other, tuple with 2 elements: string '__gt__',   and lambda function with 2 arguments: self and other, resulting boolean True if self is greater than or not equal to other,   or self is not equal to other, tuple with 2 elements: string '__lt__',   and lambda function with 2 arguments: self and other, resulting boolean False if self is greater than or equal to other, for '__ge__',   convert cls to a dictionary, convert the result into a set and convert convert into a set, roots is a set of differences of the two previous sets.
  if roots is false,
  raise an ValueError exception with an argument string 'must define at least one ordering operation: < > <= >='.
  get maximal element from roots and substitute it for root.
  get the value under the root key of the convert dictionary, for every opname and opfunc in the result,
  if opname is not contained in roots,
  substitute opname for opfunc.__name__.
  get opname attribute from int object, substitute its field __doc__ for opfunc.__doc__.
  set opname attribute of cls object to opfunc.
  return cls.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module sys.
  from django.utils.encoding import force_text and force_str into default name space.
  from django.utils.functional import allow_lazy into default name space.
  from django.utils.safestring import SafeData and mark_safe into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote, unquote, urlsplit and urlunsplit into default name space.
  from django.utils.text import normalize_newlines into default name space.
  from .html_parser import HTMLParser and HTMLParseError into default name space.
  TRAILING_PUNCTUATION is a list with 7 elements: '.', ',', ':', ';', '.)', '"' and '\''.
  WRAPPING_PUNCTUATION is a list with 6 elements: tuple with 2 elements: '(' and ')', tuple with 2 elements: '<' and '>',
  tuple with 2 elements: '[' and ']', tuple with 2 elements: '&lt' and '&gt', tuple with 2 elements: '"' and '"',   and tuple with 2 elements: '\'' and '\''.   DOTS is a list with 6 elements: strings '&middot;', '*', '\u2022', '&#149;', '&bull;' and '&#8226;'.
  call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for unencoded_ampersands_re.
  call the function re.compile with raw string '(\s+)', substitute the result for word_split_re.
  call the function re.compile with 2 arguments: raw string '^https?://\[?\w' and re.IGNORECASE, substitute the result for simple_url_re.
  call the function re.compile with 2 arguments: raw string '^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$',
  and re.IGNORECASE, substitute the result for simple_url_re.   call the function re.compile with raw string '&(?!(\w+|#\d+);)', substitute the result for simple_email_re.
  call the function re.compile with raw string '(<a [^>]*?)target=[^\s>]+', substitute the result for link_target_attribute_re.
  call the function re.compile with 2 arguments:
  raw string '(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' and re.IGNORECASE,   substitute the result for html_gunk_re.   call the function re.compile with 2 arguments: raw string '((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)',
  formated with string created by joining elements of result of the function re.escape with an argument x, with separator '|',   for every x in DOTS, and re.DOTALL, substitute the result for hard_coded_bullets_re.   call the function re.compile with raw string '(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z', substitute the result for trailing_empty_content_re.
  define the function escape with an argument text.
  call the function force_text with an argument text, replace every occurrence of '&' in the result with '&amp;',
  every occurrence of '<' with '&lt;', every occurrence of '>' with '&gt;', every occurrence of '"' with '&quot;',   and every occurrence of "'" with '&#39;', call the function mark_safe with the previous result as an argument, return the result.   call the function allow_lazy with 2 arguments: escape, six.text_type, substitute the result for escape.
  _js_escapes is a dictionary with 11 initial entries: '\\u005C' for integer representation of string '\\',
  '\\u0027' for integer representation of string '\', '\\u0022' for integer representation of string '"',   '\\u003E' for integer representation of string '>', '\\u003C' for integer representation of string '<',   '\\u0026' for integer representation of string '%', '\\u003D' for integer representation of string '=',   '\\u002D' for integer representation of string '-', '\\u003B' for integer representation of string ';',   '\\u2028' for integer representation of string '\u2028' and '\\u2029' for integer representation of string '\u2029'.   for eery z in range of integers from 0 to 31, update _js_escapes dictionary with '\\u%04X' formated with z,
  for integer representation of z converted into a string.   define the function escapejs with an argument value.
  call the function force_text with an argument value, call the method translate on the result, with an argument _js_escapes,
  use the result as an argument for the call to the mark_safe function, return the result.   call the function allow_lazy with 2 arguments: escapejs, six.text_type, substitute the result for escapejs.
  define the function conditional_escape with an argument text.
  if text has an '__html__' attribute,
  call the method text.__html__, return the result.
  if not,
  call the function escape with an argument text, return the result.
  define the function format_html with 3 arguments: format_string, unpacked list args and unpacked dictionary kwargs.
  map elements from args through the function conditional_escape, substitute the result for args_safe.
  kwargs_safe is a dictionary created for every k and v in result of the function six.iteritems called with an argument kwargs,
  with value result of the conditional_escape function called with an argument v for key k.   call the method format_string.format with 2 arguments: unpacked list args_safe and unpacked dictionary kwargs_safe,
  use the result as an argument for the call to the function mark_safe, return the result.   define the function format_html_join with 3 arguments: sep, format_string and args_generator.
  join results of format_html called with 2 arguments: format_string and tuple with an element args, into a string,
  separated with result of the function conditional_escape with an argument sep, for every args in args_generator,   use the result as an argument for the call to the function mark_safe, return the result.   define the function linebreaks with 2 arguments: value and autoescape set to boolean False.
  call the function normalize_newlines with an argument value, substitute the result for value.
  call the method re.split with 2 arguments: string '\n{2,}' and value, substitute the result for paras.
  if autoescape is true,
  call the function escape with an argument p, replace every occurrence of '\n' in the result for '<br />',
  format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   if not,
  replace every occurrence of '\n' in p for '<br />',
  format the string  '<p>%s</p>' with the result, for every p in paras, substitute list of results for paras.   join elements of paras into a string separated with '\n\n', return the result.
  call the function allow_lazy with 2 arguments: linebreaks, six.text_type, substitute the result for linebreaks.
  derive the class MLStripper from the HTMLParser base class.
  define the method __init__ with an argument self.
  if fist and second element of sys.version_info equals to integer 3 and 2, respectively,
  call the method HTMLParser.__init__ with 2 arguments: self and strict set to boolean False.
  if not,
  call the method HTMLParser.__init__ with an argument self.
  call the method self.reset.
  self.fed is an empty list.
  define the method handle_data with 2 arguments self and d.
  append d to self.fed.
  define the method handle_entityref with 2 arguments self and name.
  format string '&%s;' with name, append it to self.fed.
  define the method handle_charref with 2 arguments self and name.
  format string '&#%s;' with name, append it to self.fed.
  define the method get_data with an argument self.
  join elements of self.fed into a string, return the result.
  define the function _strip_once with an argument value.
  s is an instance of MLStripper class.
  try,
  call the method s.feed with an argument value.
  if HTMLParseError exception is caught,
  return value.
  try,
  close file descriptor s.
  if HTMLParseError or UnboundLocalError exceptions are caught,
  sum the result of the method s.get_data and s.rawdata, return the result.
  if not,
  call the method s.get_data, return the result.
  define the function strip_tags with an argument value.
  while '<' is contained in value and '>' is contained in value,
  call the function _strip_once with an argument value, substitute the result for new_value.
  if new_value equals value,
  break from the loop execution.
  substitute new_value for value.
  return value.
  call the function allow_lazy with an argument strip_tags, substitute the result for strip_tags.
  define the function remove_tags with 2 arguments: html and tags.
  tags is a list containing results of the function re.escape with an argument tag, for every tag in tags split into words.
  join elements of tags into a string, separated with '|', format string '(%s)' with it, substitute the result for tags_re.
  call the function re.compile with 2 arguments: raw string '<%s(/?>|(\s+[^>]*>))' formated with tags_re and re.U,
  substitute the result for starttag_re.   call the function re.compile with an argument string '</%s>' formated with tags_re, substitute the result for endtag_re.
  call the function starttag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  call the function endtag_re.sub with 2 arguments: an empty string and html, substitute the result for html.
  return html.
  call the function allow_lazy with 2 arguments: remove_tags, six.text_type, substitute the result for remove_tags.
  define the function strip_spaces_between_tags with an argument value.
  call the method re.sub with 3 arguments: raw string '>\s+<', string '><' and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_spaces_between_tags, six.text_type, substitute the result for strip_spaces_between_tags.
  define the function strip_entities with an argument value.
  call the method re.sub with 3 arguments: raw string '&(?:\w+|#\d+);', empty string and result of the function force_text,
  called with an argument value, return the result.   call the function allow_lazy with 2 arguments: strip_entities, six.text_type, substitute the result for strip_entities.
  define the function smart_urlquote with an argument url.
  try,
  call the function urlsplit with an argument url, assign the result to scheme, netloc, path, query and fragment, respectively.
  try,
  call the method netloc.encode with an argument string 'idna', call the method decode on the result with an argument 'ascii',
  substitute the result for netloc.   if UnicodeError exception is caught,
  do nothing.
  if not,
  call the function urlunsplit with an argument tuple with 4 elements: scheme, netloc, path, query and fragment, substitute the result for url.
  if ValueError exception is caught,
  do nothing.
  call the function force_str with an argument url, use the result as an argument for the call to the function unquote, substitute the result for url.
  call the function quote with 2 arguments: url and safe as bytes string '!*\'();:@&=+$,/?#[]~', substitute the result for url.
  call the function force_text with an argument url, return the result.
  define the function urlize with 4 arguments: text, trim_url_limit set to None, nofollow set to boolean False,
  define the function trim_url with 2 arguments: x and limit set to trim_url_limit.
  if limit is None or length of x is lesser than or equal to limit,
  return x.
  return a string '%s...' formated with elements of x up to the index equal to the maximum value between integer 0 and 3 subtracted from limit.
  if text is an instance of SafeData, safe_input is boolean True, otherwise is boolean False.
  call the function force_text with an argument text, split by it word_split_re, substitute it for words.
  for every i and word in enumerated iterable words,
  if '.' is contained in words or '@' is contained in word or ':' is contained in word,
  substitute empty string, word an empty string for lead, middle and trail, respectively.
  for every punctuation in TRAILING_PUNCTUATION,
  if middle ends with punctuation,
  substitute elements of middle from the beginning to the negative length of punctuation, for middle.
  sum punctuation and trail, substitute the result for trail.
  for every opening and closing in WRAPPING_PUNCTUATION,
  if middle starts with opening,
  substitute elements of middle from length of opening index to the end, for middle.
  sum lead and opening, substitute the result for lead.
  if middle ends with closing and count of occurrence of closing in middle equals count of occurrence of opening in middle incremented by one,
  substitute elements of middle from the beginning to the negative length of closing, for middle.
  sum trail and closing, substitute the result for lead.
  url is None.
  if nofollow is true nofollow_attr is a string ' rel="nofollow"', otherwise nofollow_attr is an empty string.
  call the method simple_url_re.match with an argument middle, if it evaluates to true,
  call the function smart_urlquote with an argument middle, substitute the result for url.
  otherwise if call the method simple_url_2_re.match with an argument middle evaluates to true,
  call the function smart_urlquote with an argument string 'http://%s' formated with an argument middle, substitute the result for url.
  otherwise if ':' is not contained in middle and result of the function simple_email_re.match called with an argument middle,
  evaluates to true,   split middle into two parts from the right by '@' character, assign the resulting parts to local and domain.
  try,
  call the method domain.encode with an argument string 'idna', call the method decode on the result with an argument string 'ascii',
  substitute the result for domain.   if UnicodeError exception is caught,
  skip this loop iteration.
  url is a string 'mailto:%s@%s' formated with local and domain.
  nofollow_attr is an empty string.
  if url is true,
  call the function trim_url with an argument middle, substitute the result for trimmed.
  if autoescape is true and safe_input is false,
  call the function escape with an argument lead, substitute the result for lead, call the function escape with an argument trail,
  substitute the result for trail.   call the function escape with an argument url, substitute the result for url, call the function escape with an argument trimmed,
  substitute the result for trimmed.   middle is a string '<a href="%s"%s>%s</a>' formated with url, nofollow_attr and trimmed.
  format string '<a href="%s"%s>%s</a>' with lead, middle and trail, use it as an argument for the call to the function mark_safe,
  substitute the result for i-th element of words.   if not,
  if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  otherwise if safe_input is true,
  call the function mark_safe with an argument word, substitute the result for i-th element of words.
  otherwise if autoescape is true,
  call the function escape with an argument word, substitute the result for i-th element of words.
  join elements of words into a string, return it.
  call the function allow_lazy with 2 arguments: urlize, six.text_type, substitute the result for urlize.
  define the function avoid_wrapping with an argument value.
  replace every occurrence of ' ' in value for '\xa0', return the result.
  from django.utils.six.moves import html_parser as _html_parse into default name space.
  import module re.
  import module sys.
  substitute version_info from module sys for surrent_version.
  set use_workaround to boolean True if current_version tuple elements are smaller than the tuple (2,7,3), respectively,
  or if current_version is greater than (3,0), but smaller than (3,2,3), otherwise set use_workaround to boolean False.   substitute HTMLParseError from the module _html_parser for HTMLParseError.
  if use_workaround is boolean False,
  if tuple current_version elements are greater or equal to (3, 4), respectively,
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define the initialization method __init__, with self instance of this class, convert_charrefs set to boolean False,
  and dictionary of arbitrary length **kwargs as arguments.   call the initialization method for the base class, _html_parser.HTMLParser.__init__ with self,
  convert_charrefs set to convert_charrefs and dictionary **kwargs as the arguments.   if not,
  substitute HTMLParser from the module _html_parser for HTMLParser.
  if not,
  compile a regular expression pattern string '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' into a regular expression object and assign it to tagfind.
  derive the class HTMLParser from the base class HTMLParser located in the module _html_parser.
  define initialization method __init__ with self instance of the class as an argument.
  call the initialization method _html_parser.HTMLParser.__init__(self) for the base class.
  set field cdata_tag for this class instance to None.
  define method set_cdata_mode, with self class instance and tag as the arguments.
  try,
  set field interesting for this class instance to interesting_cdata from module _html_parser.
  if AttributeError exception is caught,
  replace '%s' in the string '</\s*%s\s*>' with the result of the function call tag.lower(),
  use it and the re.I as the input arguments for function re.compile, put the result in the self.interesting.   evaluate function tag.lower, without the arguments, put the result in the self.cdata_tag.
  define method clear_cdata_mode, with self class instance as an argument.
  substitute _html_parser.interesting_normal for self.interesting.
  set self.cdata_tag to None.
  define method parse_starttag with self class instance and i as the arguments.
  set self.__starttag_text to None.
  call the method self.check_for_whole_start_tag with i as an argument, substitute result for the endpos.
  if endpos is lesser than zero,
  return endpos.
  substitute self.rawdata for rawdata.
  slice the list from the i-th to the endpos-th element, substitute it for self.__starttag_text.
  attrs is a empty list.
  match the rawdata from the position i+1, with tagfind pattern, assign the result to the match.
  if match evaluates to False throw an exception with the string message 'unexpected call to parse_starttag()'.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  find the first subgroup of the matched string from the match object, convert it to lowercase, substitute it for tag and self.lasttag.
  as long k is smaller than endpos,
  match the rawdata from the position k, with attrfind pattern, assign the result to the m.
  if m is not False, None is considered False,
  breaks from the smallest enclosing loop.
  find the first, second and third subgroup of the m regular expression match, assign the result to the attrname, rest and attrvalue, respectively.
  if rest is not False, None is considered False,
  set attrvalue to None.
  otherwise, if first and the last character of attrvalue are '\' charter  or first and last character of attrvalue are '"' character,
  remove first and last character from the attrvalue, substitute it for attrvalue.
  if attrvalue is not an empty string,
  call the method unescape with attrvalue as the argument on the self class instance, substitute the result for attrvalue.
  form the tuple from the attrname converted to lowercase and attrvalue, append it to the end of attrs.
  find the ending position of the regular expression match of the object match, substitute the result for k.
  slice the rawdata string from the k-th to the endpos-th index, remove the whitespaces from the start and the end of the string, substitute it for end.
  if end is not a '>' or '/>' character,
  evaluate the self.getpos() and assign the result to the lineno and offset respectfully.
  if self.__stattag_text contains newline character,
  increment the lineno by the count of the newlines in self.__starttag_text.
  find the last index of newline occurrence in self.__starttag_text, subtract it from total length of self.__starttag_text,
  substitute the result for offset.   if not,
  increment the offset by the length of self.__starttag_text.
  slice the rawdata from k to endpos, then take the first 20 elements of the previous slice,
  with it replace %r in the string "junk characters in start tag: %r",   call the method self.error with the resulting string as an argument.   if string end ends with string '/>',
  call the method self.handle_startendtag with tag and attrs as the arguments.
  if not,
  call the method self.handle_starttag, with tag and attrs as the arguments.
  if tag is contained in self.CDATA_CONTENT_ELEMENTS,
  call the method self.set_cdata_mode with tag as the argument.
  return endpos.
  define the method parse_endtag with self class instance and i as the arguments.
  substitute self.rawdata for rawdata.
  take two characters from the i-th element of rawdata, if they are not equal to the string '</',
  throw an exception with string "unexpected call to parse_endtag" as the message.   search anywhere in the rawdata string starting from the (i+1)-th element for the _html_parser.endendeag, replace the result for match.
  if there is no match,
  return integer -1.
  find the ending position of the regular expression match of the object match, substitute the result for j.
  match the rawdata from the position i, with _html_parser.endtagfind pattern, assign the result to the match.
  if there is no match,
  if self.cdata_tag is not None,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  slice the rawdata from i-th to the j-th element, replace with it '%r' in the string "bad end tag: %r", use it to call the method self.error.
  find the first subgroup of the matched string from the match object, strip the whitespaces from the begging and end, replace it for tag.
  if self.cdata_tag is not None,
  convert tag to lowercase if it is not equal to self.cdata_tag,
  slice the rawdata to obtain substring from i-th to j-th element, use it as the argument for the method call to the self.handle_data.
  return j.
  convert tag to lowercase, use it as the argument for the call to the method self.handle_endtag.
  call the method self.clear_cdata_mode.
  return j.
  from __future__ import unicode_literals into default name space.
  import module base64.
  import module calendar.
  import module datetime.
  import module re.
  import module sys.
  from binascii import Error as BinasciiError into default name space.
  from email.utils import formatdate into default name space.
  from django.utils.datastructures import MultiValueDict into default name space.
  from django.utils.encoding import force_str and force_text into default name space.
  from django.utils.functional import allow_lazy into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves.urllib.parse import quote, quote_plus, unquote, unquote_plus, urlparse, urlencode as original_urlencode.
  call the function re.compile with an argument raw string '(?:W/)?"((?:\\.|[^"])*)"', substitute the result for ETAG_MATCH.
  MONTHS is a list with 12 elements: strings 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', and 'dec'.
  __D is a raw string '(?P<day>\d{2})'.
  __D2 is a raw string '(?P<day>[ \d]\d)'.
  __M is a raw string '(?P<mon>\w{3})'.
  __Y is a raw string '(?P<year>\d{4})'.
  __Y2 is a raw string '(?P<year>\d{2})'.
  __T is a raw string '(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'.
  call the function re.compile with an argument raw string '^\w{3}, %s %s %s %s GMT$' formated with __D, __M, __Y and __T,
  substitute the result for RFC1123_DATE.   call the function re.compile with an argument raw string '^\w{6,9}, %s-%s-%s %s GMT$' formated with __D, __M, __Y2 and __T,
  substitute the result for RFC850_DATE.   call the function re.compile with an argument raw string '^\w{3} %s %s %s %s$' formated with __M, __D2, __T and __Y,
  substitute the result for ASCTIME_DATE.   define the function urlquote with 2 arguments: url and safe set to '/'.
  call the function quote with 2 arguments: result of the function force_str called with an argument url,
  and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote and six.text_type, substitute the result for urlquote.
  define the function urlquote_plus with 2 arguments: url and safe set to an empty string.
  call the function quote_plus with 2 arguments: result of the function force_str called with an argument url,
  and result of the function force_str called with an argument safe,   use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlquote_plus and six.text_type, substitute the result for urlquote_plus.
  define the function urlunquote with an argument quoted_url.
  call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote,
  use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote and six.text_type, substitute the result for urlunquote.
  define the function urlunquote with an argument quoted_url.
  call the function force_str with an argument quoted_url, use the result as an argument for the call to the function unquote_plus,
  use the result as an argument for the call to the function force_text, return the result.   call the function allow_lazy with 2 arguments: urlunquote_plus and six.text_type, substitute the result for urlunquote_plus.
  define the function urlencode with 2 arguments query and doseq set to integer 0.
  if query is an instance of MultiValueDict class,
  call the method query.lists, substitute the result for query.
  otherwise if query has an attribute 'items',
  call the method query.items, substitute the result for query.
  call the function original_urlencode with 2 arguments: list with 2 elements: result of the function force_str with an argument k,
  and list with results of the function force_str with an argument i, for every i in v, only if v is a list or a tuple,   otherwise second element is result of the function force_str with an argument v, for every k and v in query,   and doseq, return the result.   define the function cookie_date with an argument epoch_seconds set to None.
  call the function formatdate with an argument epoch_seconds, substitute the result for rfcdate.
  return a string '%s-%s-%s GMT', formated with: first 7 elements of rfcdate, elements of rfcdate from 8-th to the 11-th index,
  and elements of rfcdate from 12-th to the 25-th index.   define the function http_date with an argument epoch_seconds set to None.
  call the function formatdate with 2 arguments: epoch_seconds and usegmt set to boolean True, return the result.
  define the function parse_http_date with an argument date.
  for every regex in tuple with 3 elements: RFC1123_DATE, RFC850_DATE and ASCTIME_DATE,
  call the method regex.match with an argument date, substitute the result for m.
  if m is not None,
  break from the loop execution.
  if not,
  raise an ValueError exception with an argument string "%r is not in a valid HTTP date format" formated with date.
  try,
  call the method m.group with an argument string 'year', convert the result into a string, substitute it for year.
  if year is lesser than integer 100,
  if year is lesser than integer 70,
  increment year by integer 2000.
  if not,
  increment year by integer 1900.
  call the method m.group with an argument string 'mon', convert the result to lowercase, use it as an argument for the call to the,
  method MONTHS.index, increment the result by integer 1, substitute it for month.   call the method m.group with an argument string 'fay', convert the result into a string, substitute it for day.
  call the method m.group with an argument string 'hour', convert the result into a string, substitute it for hour.
  call the method m.group with an argument string 'min', convert the result into a string, substitute it for min.
  call the method m.group with an argument string 'sec', convert the result into a string, substitute it for sec.
  call the method MONTHS.index with 6 arguments: year, month, day, hour, min and sec, substitute the result for result.
  call the method result.utctimetuple, use the result as an argument for the call to the method calendar.timegm, return the result.
  if Exception exception is caught.
  call the function six.reraise with 3 arguments: ValueError, instance of a class ValueError, created with an argument string,
  "%r is not a valid date" formated with date and third element of the result of the function sys.exc_info.   define the function parse_http_date_safe an argument date.
  try,
  call the function parse_http_date with an argument date, return the result.
  if Exception exception is caught.
  do nothing.
  define the functionbase36_to_int with an argument s.
  if length of s is greater than integer 13,
  raise an ValueError exception with an argument string "Base36 input too large".
  convert s to integer of base 36, substitute it for value.
  if six.PY2 is true and value is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 input too large".
  return value.
  define the function int_to_base36 with an argument i.
  digits is a string "0123456789abcdefghijklmnopqrstuvwxyz".
  factor is integer 0.
  if i is smaller than integer 0,
  raise an ValueError exception with an argument string "Negative base36 conversion input.".
  if six.PY2 is true,
  if i is not an instance of six.integer_types class,
  raise an TypeError exception with an argument string "Non-integer base36 conversion input.".
  if i is greater than sys.maxint,
  raise an ValueError exception with an argument string "Base36 conversion input too large.".
  endless loop,
  increment factor by one.
  bring integer 36 to the power of factor, if i is smaller than the result,
  decrement factor by one.
  break from the loop execution.
  base36 is an empty list.
  while factor is greater or equal to integer 0,
  bring integer 36 to the power of factor, substitute the result for j.
  floor the division of i by j, use it an an index to get the element of the digits list, append the result for base36.
  i is the reminder of the division of i by j.
  decrement factor by one.
  join elements of base36 into a string, return it.
  define the function urlsafe_base64_encode with an argument s.
  call the method base64.urlsafe_b64encode with an argument s, strip the result of the bytes string '\n=' from the right, return it.
  define the function urlsafe_base64_decode with an argument s.
  call the method s.encode with an argument string 'utf-8', substitute the result for s.
  try,
  left justify string s in a field of width equal to the sum of length of s and reminder of the division of length of s by integer 4,
  pad the rest of the field with bytes string '=', use the result as an argument for the call to the method base64.urlsafe_b64decode,   return the result.   if LookupError or BinasciiError, renamed to e, exceptions are caught.
  raise an ValueError exception with an argument e.
  define the function parse_etags with an argument etag_str.
  call the method ETAG_MATCH.findall with an argument etag_str, substitute the result for etags.
  if etags is false,
  return a list with an element etag_str.
  for every e in etags call the method e.encode with an argument string 'ascii', call the method decode on the result with an argument,
  string 'unicode_escape', substitute the list of results for etags.   return etags.
  define the function quote_etag with an argument etag.
  return a string '"%s"' formated with etag, in which every occurrence of '\\' is replaced with '\\\\' and every occurrence of '"',
  is replaced with '\\"'.   define the function same_origin with 2 arguments url1 and url2.
  substitute result of the function urlparse with an argument ur1 for p1 and result of the function urlparse with an argument ur2 for p2.
  try,
  if p2.scheme, p2.hostname and p2.port equals p1.scheme, p1.hostname and p1.port, respectively, return boolean True, otherwise return boolean False.
  if ValueError exception is caught.
  return boolean False.
  define the function is_safe_url with 2 arguments url and host set to None.
  if url is false,
  return boolean False.
  replace every occurrence of '\\' in url with '/'.
  if url starts with '///',
<annotation_end_b>#<body_start>          self . _wrapped = empty
   __getattr__ = new_method_proxy ( getattr )
  def __setattr__ ( self , name , value ) :
          if name == "_wrapped" :
               self . __dict__ [ "_wrapped" ] = value
  else :
              if self . _wrapped is empty :
                  self . _setup ( )
  setattr ( self . _wrapped , name , value )
    def __delattr__ ( self , name ) :
          if name == "_wrapped" :
              raise TypeError ( "can't delete _wrapped." )
  if self . _wrapped is empty :
              self . _setup ( )
  delattr ( self . _wrapped , name )
   def _setup ( self ) :
 raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )
        def __getstate__ ( self ) :
          if self . _wrapped is empty :
              self . _setup ( )
  return self . _wrapped . __dict__
     @ classmethod
 def __newobj__ ( cls , * args ) :
          return cls . __new__ ( cls , * args )
   def __reduce_ex__ ( self , proto ) :
          if proto >= 2 :
                return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
  else :
                  return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )
    def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = type ( self ) ( )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
   if six . PY3 :
          __bytes__ = new_method_proxy ( bytes )
 __str__ = new_method_proxy ( str )
 __bool__ = new_method_proxy ( bool )
  else :
          __str__ = new_method_proxy ( str )
 __unicode__ = new_method_proxy ( unicode )
 __nonzero__ = new_method_proxy ( bool )
    __dir__ = new_method_proxy ( dir )
    __class__ = property ( new_method_proxy ( operator . attrgetter ( "__class__" ) ) )
 __eq__ = new_method_proxy ( operator . eq )
 __ne__ = new_method_proxy ( operator . ne )
 __hash__ = new_method_proxy ( hash )
   __getitem__ = new_method_proxy ( operator . getitem )
 __setitem__ = new_method_proxy ( operator . setitem )
 __delitem__ = new_method_proxy ( operator . delitem )
  __len__ = new_method_proxy ( len )
 __contains__ = new_method_proxy ( operator . contains )
     _super = super
   class SimpleLazyObject ( LazyObject ) :
 def __init__ ( self , func ) :
 self . __dict__ [ '_setupfunc' ] = func
 _super ( SimpleLazyObject , self ) . __init__ ( )
   def _setup ( self ) :
          self . _wrapped = self . _setupfunc ( )
     def __repr__ ( self ) :
          if self . _wrapped is empty :
              repr_attr = self . _setupfunc
  else :
              repr_attr = self . _wrapped
  return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )
   def __deepcopy__ ( self , memo ) :
          if self . _wrapped is empty :
                result = SimpleLazyObject ( self . _setupfunc )
 memo [ id ( self ) ] = result
 return result
  return copy . deepcopy ( self . _wrapped , memo )
     class lazy_property ( property ) :
 def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :
          if fget is not None :
              @ wraps ( fget )
 def fget ( instance , instance_type = None , name = fget . __name__ ) :
                  return getattr ( instance , name ) ( )
   if fset is not None :
              @ wraps ( fset )
 def fset ( instance , value , name = fset . __name__ ) :
                  return getattr ( instance , name ) ( value )
   if fdel is not None :
              @ wraps ( fdel )
 def fdel ( instance , name = fdel . __name__ ) :
                  return getattr ( instance , name ) ( )
   return property ( fget , fset , fdel , doc )
     def partition ( predicate , values ) :
 results = ( [ ] , [ ] )
 for item in values :
          results [ predicate ( item ) ] . append ( item )
  return results
   if sys . version_info >= ( 2 , 7 , 2 ) :
      from functools import total_ordering
  else :
         def total_ordering ( cls ) :
 convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
 roots = set ( dir ( cls ) ) & set ( convert )
 if not roots :
              raise ValueError ( 'must define at least one ordering operation: < > <= >=' )
  root = max ( roots )
 for opname , opfunc in convert [ root ] :
              if opname not in roots :
                  opfunc . __name__ = opname
 opfunc . __doc__ = getattr ( int , opname ) . __doc__
 setattr ( cls , opname , opfunc )
   return cls
  from __future__ import unicode_literals
  import re
 import sys
  from django . utils . encoding import force_text , force_str
 from django . utils . functional import allow_lazy
 from django . utils . safestring import SafeData , mark_safe
 from django . utils import six
 from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
 from django . utils . text import normalize_newlines
  from . html_parser import HTMLParser , HTMLParseError
    TRAILING_PUNCTUATION = [ '.' , ',' , ':' , ';' , '.)' , '"' , '\'' ]
 WRAPPING_PUNCTUATION = [ ( '(' , ')' ) , ( '<' , '>' ) , ( '[' , ']' ) , ( '&lt;' , '&gt;' ) , ( '"' , '"' ) , ( '\'' , '\'' ) ]
   DOTS = [ '&middot;' , '*' , '\u2022' , '&#149;' , '&bull;' , '&#8226;' ]
  unencoded_ampersands_re = re . compile ( r'&(?!(\w+|#\d+);)' )
 word_split_re = re . compile ( r'(\s+)' )
 simple_url_re = re . compile ( r'^https?://\[?\w' , re . IGNORECASE )
 simple_url_2_re = re . compile ( r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$' , re . IGNORECASE )
 simple_email_re = re . compile ( r'^\S+@\S+\.\S+$' )
 link_target_attribute_re = re . compile ( r'(<a [^>]*?)target=[^\s>]+' )
 html_gunk_re = re . compile ( r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' , re . IGNORECASE )
 hard_coded_bullets_re = re . compile ( r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
 trailing_empty_content_re = re . compile ( r'(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z' )
   def escape ( text ) :
 return mark_safe ( force_text ( text ) . replace ( '&' , '&amp;' ) . replace ( '<' , '&lt;' ) . replace ( '>' , '&gt;' ) . replace ( '"' , '&quot;' ) . replace ( "'" , '&#39;' ) )
  escape = allow_lazy ( escape , six . text_type )
  _js_escapes = {  ord ( '\\' ) : '\\u005C' ,  ord ( '\'' ) : '\\u0027' ,  ord ( '"' ) : '\\u0022' ,  ord ( '>' ) : '\\u003E' ,  ord ( '<' ) : '\\u003C' ,  ord ( '&' ) : '\\u0026' ,  ord ( '=' ) : '\\u003D' ,  ord ( '-' ) : '\\u002D' ,  ord ( ';' ) : '\\u003B' ,  ord ( '\u2028' ) : '\\u2028' ,  ord ( '\u2029' ) : '\\u2029'  }
   _js_escapes . update ( ( ord ( '%c' % z ) , '\\u%04X' % z ) for z in range ( 32 ) )
   def escapejs ( value ) :
 return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )
  escapejs = allow_lazy ( escapejs , six . text_type )
   def conditional_escape ( text ) :
 if hasattr ( text , '__html__' ) :
          return text . __html__ ( )
  else :
          return escape ( text )
     def format_html ( format_string , * args , ** kwargs ) :
 args_safe = map ( conditional_escape , args )
 kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
 return mark_safe ( format_string . format ( * args_safe , ** kwargs_safe ) )
    def format_html_join ( sep , format_string , args_generator ) :
 return mark_safe ( conditional_escape ( sep ) . join (  format_html ( format_string , * tuple ( args ) )  for args in args_generator ) )
    def linebreaks ( value , autoescape = False ) :
 value = normalize_newlines ( value )
 paras = re . split ( '\n{2,}' , value )
 if autoescape :
          paras = [ '<p>%s</p>' % escape ( p ) . replace ( '\n' , '<br />' ) for p in paras ]
  else :
          paras = [ '<p>%s</p>' % p . replace ( '\n' , '<br />' ) for p in paras ]
  return '\n\n' . join ( paras )
  linebreaks = allow_lazy ( linebreaks , six . text_type )
   class MLStripper ( HTMLParser ) :
      def __init__ ( self ) :
            if sys . version_info [ : 2 ] == ( 3 , 2 ) :
              HTMLParser . __init__ ( self , strict = False )
  else :
              HTMLParser . __init__ ( self )
  self . reset ( )
 self . fed = [ ]
   def handle_data ( self , d ) :
          self . fed . append ( d )
   def handle_entityref ( self , name ) :
          self . fed . append ( '&%s;' % name )
   def handle_charref ( self , name ) :
          self . fed . append ( '&#%s;' % name )
   def get_data ( self ) :
          return '' . join ( self . fed )
     def _strip_once ( value ) :
 s = MLStripper ( )
 try :
          s . feed ( value )
  except HTMLParseError :
          return value
  try :
          s . close ( )
  except ( HTMLParseError , UnboundLocalError ) :
            return s . get_data ( ) + s . rawdata
  else :
          return s . get_data ( )
     def strip_tags ( value ) :
   while '<' in value and '>' in value :
          new_value = _strip_once ( value )
 if new_value == value :
               break
  value = new_value
  return value
  strip_tags = allow_lazy ( strip_tags )
   def remove_tags ( html , tags ) :
 tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
 tags_re = '(%s)' % '|' . join ( tags )
 starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
 endtag_re = re . compile ( '</%s>' % tags_re )
 html = starttag_re . sub ( '' , html )
 html = endtag_re . sub ( '' , html )
 return html
  remove_tags = allow_lazy ( remove_tags , six . text_type )
   def strip_spaces_between_tags ( value ) :
 return re . sub ( r'>\s+<' , '><' , force_text ( value ) )
  strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
   def strip_entities ( value ) :
 return re . sub ( r'&(?:\w+|#\d+);' , '' , force_text ( value ) )
  strip_entities = allow_lazy ( strip_entities , six . text_type )
   def smart_urlquote ( url ) :
  try :
          scheme , netloc , path , query , fragment = urlsplit ( url )
 try :
              netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
              pass
  else :
              url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
   except ValueError :
           pass
   url = unquote ( force_str ( url ) )
  url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
  return force_text ( url )
    def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
 def trim_url ( x , limit = trim_url_limit ) :
          if limit is None or len ( x ) <= limit :
              return x
  return '%s...' % x [ : max ( 0 , limit - 3 ) ]
  safe_input = isinstance ( text , SafeData )
 words = word_split_re . split ( force_text ( text ) )
 for i , word in enumerate ( words ) :
          if '.' in word or '@' in word or ':' in word :
               lead , middle , trail = '' , word , ''
 for punctuation in TRAILING_PUNCTUATION :
                  if middle . endswith ( punctuation ) :
                      middle = middle [ : - len ( punctuation ) ]
 trail = punctuation + trail
   for opening , closing in WRAPPING_PUNCTUATION :
                  if middle . startswith ( opening ) :
                      middle = middle [ len ( opening ) : ]
 lead = lead + opening
   if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
                      middle = middle [ : - len ( closing ) ]
 trail = closing + trail
     url = None
 nofollow_attr = ' rel="nofollow"' if nofollow else ''
 if simple_url_re . match ( middle ) :
                  url = smart_urlquote ( middle )
  elif simple_url_2_re . match ( middle ) :
                  url = smart_urlquote ( 'http://%s' % middle )
  elif ':' not in middle and simple_email_re . match ( middle ) :
                  local , domain = middle . rsplit ( '@' , 1 )
 try :
                      domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
  except UnicodeError :
                      continue
  url = 'mailto:%s@%s' % ( local , domain )
 nofollow_attr = ''
    if url :
                  trimmed = trim_url ( middle )
 if autoescape and not safe_input :
                      lead , trail = escape ( lead ) , escape ( trail )
 url , trimmed = escape ( url ) , escape ( trimmed )
  middle = '<a href="%s"%s>%s</a>' % ( url , nofollow_attr , trimmed )
 words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )
  else :
                  if safe_input :
                      words [ i ] = mark_safe ( word )
  elif autoescape :
                      words [ i ] = escape ( word )
    elif safe_input :
              words [ i ] = mark_safe ( word )
  elif autoescape :
              words [ i ] = escape ( word )
   return '' . join ( words )
  urlize = allow_lazy ( urlize , six . text_type )
   def avoid_wrapping ( value ) :
 return value . replace ( " " , "\xa0" )
from django . utils . six . moves import html_parser as _html_parser
 import re
 import sys
  current_version = sys . version_info
  use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )
  HTMLParseError = _html_parser . HTMLParseError
  if not use_workaround :
      if current_version >= ( 3 , 4 ) :
          class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self , convert_charrefs = False , ** kwargs ) :
                  _html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
    else :
          HTMLParser = _html_parser . HTMLParser
   else :
      tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' )
  class HTMLParser ( _html_parser . HTMLParser ) :
 def __init__ ( self ) :
              _html_parser . HTMLParser . __init__ ( self )
 self . cdata_tag = None
   def set_cdata_mode ( self , tag ) :
              try :
                  self . interesting = _html_parser . interesting_cdata
  except AttributeError :
                  self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
  self . cdata_tag = tag . lower ( )
   def clear_cdata_mode ( self ) :
              self . interesting = _html_parser . interesting_normal
 self . cdata_tag = None
    def parse_starttag ( self , i ) :
              self . __starttag_text = None
 endpos = self . check_for_whole_start_tag ( i )
 if endpos < 0 :
                  return endpos
  rawdata = self . rawdata
 self . __starttag_text = rawdata [ i : endpos ]
   attrs = [ ]
 match = tagfind . match ( rawdata , i + 1 )
 assert match , 'unexpected call to parse_starttag()'
 k = match . end ( )
 self . lasttag = tag = match . group ( 1 ) . lower ( )
  while k < endpos :
                  m = _html_parser . attrfind . match ( rawdata , k )
 if not m :
                      break
  attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
 if not rest :
                      attrvalue = None
  elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
                      attrvalue = attrvalue [ 1 : - 1 ]
  if attrvalue :
                      attrvalue = self . unescape ( attrvalue )
  attrs . append ( ( attrname . lower ( ) , attrvalue ) )
 k = m . end ( )
   end = rawdata [ k : endpos ] . strip ( )
 if end not in ( ">" , "/>" ) :
                  lineno , offset = self . getpos ( )
 if "\n" in self . __starttag_text :
                      lineno = lineno + self . __starttag_text . count ( "\n" )
 offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
  else :
                      offset = offset + len ( self . __starttag_text )
  self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
  if end . endswith ( '/>' ) :
                   self . handle_startendtag ( tag , attrs )
  else :
                  self . handle_starttag ( tag , attrs )
 if tag in self . CDATA_CONTENT_ELEMENTS :
                      self . set_cdata_mode ( tag )
   return endpos
    def parse_endtag ( self , i ) :
              rawdata = self . rawdata
 assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
 match = _html_parser . endendtag . search ( rawdata , i + 1 )
 if not match :
                  return - 1
  j = match . end ( )
 match = _html_parser . endtagfind . match ( rawdata , i )
 if not match :
                  if self . cdata_tag is not None :
                      self . handle_data ( rawdata [ i : j ] )
 return j
  self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
   tag = match . group ( 1 ) . strip ( )
 if self . cdata_tag is not None :
                  if tag . lower ( ) != self . cdata_tag :
                      self . handle_data ( rawdata [ i : j ] )
 return j
    self . handle_endtag ( tag . lower ( ) )
 self . clear_cdata_mode ( )
 return j
from __future__ import unicode_literals
  import base64
 import calendar
 import datetime
 import re
 import sys
  from binascii import Error as BinasciiError
 from email . utils import formatdate
  from django . utils . datastructures import MultiValueDict
 from django . utils . encoding import force_str , force_text
 from django . utils . functional import allow_lazy
 from django . utils import six
 from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )
  ETAG_MATCH = re . compile ( r'(?:W/)?"((?:\\.|[^"])*)"' )
  MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )
 __D = r'(?P<day>\d{2})'
 __D2 = r'(?P<day>[ \d]\d)'
 __M = r'(?P<mon>\w{3})'
 __Y = r'(?P<year>\d{4})'
 __Y2 = r'(?P<year>\d{2})'
 __T = r'(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'
 RFC1123_DATE = re . compile ( r'^\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )
 RFC850_DATE = re . compile ( r'^\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )
 ASCTIME_DATE = re . compile ( r'^\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )
   def urlquote ( url , safe = '/' ) :
 return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
  urlquote = allow_lazy ( urlquote , six . text_type )
   def urlquote_plus ( url , safe = '' ) :
 return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
  urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
   def urlunquote ( quoted_url ) :
 return force_text ( unquote ( force_str ( quoted_url ) ) )
  urlunquote = allow_lazy ( urlunquote , six . text_type )
   def urlunquote_plus ( quoted_url ) :
 return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
  urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
   def urlencode ( query , doseq = 0 ) :
 if isinstance ( query , MultiValueDict ) :
          query = query . lists ( )
  elif hasattr ( query , 'items' ) :
          query = query . items ( )
  return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )
    def cookie_date ( epoch_seconds = None ) :
 rfcdate = formatdate ( epoch_seconds )
 return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
    def http_date ( epoch_seconds = None ) :
 return formatdate ( epoch_seconds , usegmt = True )
    def parse_http_date ( date ) :
    for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
          m = regex . match ( date )
 if m is not None :
              break
   else :
          raise ValueError ( "%r is not in a valid HTTP date format" % date )
  try :
          year = int ( m . group ( 'year' ) )
 if year < 100 :
              if year < 70 :
                  year += 2000
  else :
                  year += 1900
   month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1
 day = int ( m . group ( 'day' ) )
 hour = int ( m . group ( 'hour' ) )
 min = int ( m . group ( 'min' ) )
 sec = int ( m . group ( 'sec' ) )
 result = datetime . datetime ( year , month , day , hour , min , sec )
 return calendar . timegm ( result . utctimetuple ( ) )
  except Exception :
          six . reraise ( ValueError , ValueError ( "%r is not a valid date" % date ) , sys . exc_info ( ) [ 2 ] )
     def parse_http_date_safe ( date ) :
 try :
          return parse_http_date ( date )
  except Exception :
          pass
       def base36_to_int ( s ) :
    if len ( s ) > 13 :
          raise ValueError ( "Base36 input too large" )
  value = int ( s , 36 )
   if six . PY2 and value > sys . maxint :
          raise ValueError ( "Base36 input too large" )
  return value
    def int_to_base36 ( i ) :
 digits = "0123456789abcdefghijklmnopqrstuvwxyz"
 factor = 0
 if i < 0 :
          raise ValueError ( "Negative base36 conversion input." )
  if six . PY2 :
          if not isinstance ( i , six . integer_types ) :
              raise TypeError ( "Non-integer base36 conversion input." )
  if i > sys . maxint :
              raise ValueError ( "Base36 conversion input too large." )
    while True :
          factor += 1
 if i < 36 ** factor :
              factor -= 1
 break
   base36 = [ ]
  while factor >= 0 :
          j = 36 ** factor
 base36 . append ( digits [ i // j ] )
 i = i % j
 factor -= 1
  return '' . join ( base36 )
    def urlsafe_base64_encode ( s ) :
 return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\n=' )
    def urlsafe_base64_decode ( s ) :
 s = s . encode ( 'utf-8' )
 try :
          return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )
  except ( LookupError , BinasciiError ) as e :
          raise ValueError ( e )
     def parse_etags ( etag_str ) :
 etags = ETAG_MATCH . findall ( etag_str )
 if not etags :
           return [ etag_str ]
  etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]
 return etags
    def quote_etag ( etag ) :
 return '"%s"' % etag . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' )
    def same_origin ( url1 , url2 ) :
 p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
 try :
          return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )
  except ValueError :
          return False
     def is_safe_url ( url , host = None ) :
 if not url :
          return False
   url = url . replace ( '\\' , '/' )
   if url . startswith ( '///' ) :
<body_end><annotation_start_b>  if package doesnt have an 'rindex' attribute,
  raise an ValueError with an argument string "'package' not set to a string".
  substitute length of package for dot.
  for every x is the range of integers from level to the integer 2, in the reversed order,
  try,
  call the method package.rindex with 3 arguments: string '.', integer 0 and dot, substitute the result for dot.
  if ValueError exception is caught,
  raise an ValueError with an argument string "attempted relative import beyond top-level package".
<annotation_end_b>#<body_start> if not hasattr ( package , 'rindex' ) :
          raise ValueError ( "'package' not set to a string" )
  dot = len ( package )
 for x in range ( level , 1 , - 1 ) :
          try :
              dot = package . rindex ( '.' , 0 , dot )
  except ValueError :
              raise ValueError ( "attempted relative import beyond top-level package" )
<body_end><annotation_start_b>  if name starts with an string '.',
  if package is false,
  raise an TypeError with an argument string "relative imports require the 'package' argument".
  level is an integer 0.
  for every character in name,
  if character is not equal to a string '.',
  break from the loop execution.
  increment level by one.
  call the function _resolve_name with 3 arguments: name list elements from the level index to the end, package and level,
  substitute the result for name.   call the function __import__ with an argument name.
<annotation_end_b>#<body_start> if name . startswith ( '.' ) :
              if not package :
                  raise TypeError ( "relative imports require the 'package' argument" )
  level = 0
 for character in name :
                  if character != '.' :
                      break
  level += 1
  name = _resolve_name ( name [ level : ] , package , level )
  __import__ ( name )
<body_end><annotation_start_b>  best_doublecolon_start is an integer -1.
  best_doublecolon_len is an integer 0.
  doublecolon_start is an integer -1.
  doublecolon_len is an integer 0.
  call he function is_valid_ipv6_address with an argument ip_str, if it evaluates to false,
  raise an ValidationError exception with 2 arguments: error_message and code as a string 'invalid'.
  call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
  call the function _explode_shorthand_ip_string with an argument ip_str, substitute the result for ip_str.
  if unpack_ipv4 is true,
  call the function _unpack_ipv4 with an argument ip_str, substitute the result for ipv4_unpacked.
  if ipv4_unpacked is true,
<annotation_end_b>#<body_start> best_doublecolon_start = - 1
 best_doublecolon_len = 0
 doublecolon_start = - 1
 doublecolon_len = 0
  if not is_valid_ipv6_address ( ip_str ) :
          raise ValidationError ( error_message , code = 'invalid' )
     ip_str = _explode_shorthand_ip_string ( ip_str )
  ip_str = _sanitize_ipv4_mapping ( ip_str )
    if unpack_ipv4 :
          ipv4_unpacked = _unpack_ipv4 ( ip_str )
  if ipv4_unpacked :
<body_end><annotation_start_b>  convert ip_str to lowercase, if it doesnt start with a string '0000:0000:0000:0000:0000:ffff:',
<annotation_end_b>#<body_start> if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :
<body_end><annotation_start_b>  convert ip_str to lowercase, if it doesnt start with a string '0000:0000:0000:0000:0000:ffff:',
<annotation_end_b>#<body_start> if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :
<body_end><annotation_start_b>  from django.core.validators import validate_ipv4_address.
  if ':' is not contained in ip_str.
<annotation_end_b>#<body_start> from django . core . validators import validate_ipv4_address
   if ':' not in ip_str :
<body_end><annotation_start_b>  call the function _is_shorthand_ip with an argument ip_str, if it evaluates to false,
<annotation_end_b>#<body_start> if not _is_shorthand_ip ( ip_str ) :
<body_end><annotation_start_b>  if count of occurrence of '::' in ip_str equals integer 1,
<annotation_end_b>#<body_start> if ip_str . count ( '::' ) == 1 :
<body_end><annotation_start_b>  try,
  create an iterator out of x.
  if TypeError exception is caught,
<annotation_end_b>#<body_start> try :
          iter ( x )
  except TypeError :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  substitute length of text for end.
  substitute self.state for state.
  substitute self.regexes for regexes.
  substitute self.toks for toks.
  start is an integer 0.
  while start is lesser than end.
  get the value under the state key of the regexes dictionary, call the method finditer on the result with 2 arguments: text and start,
  for every match in the result,   substitute match.lastgroup for name.
  substitute value under the name key of the toks dictionary for tok.
  call the method match.group with an arugument name, substitute the result for toktext.
  increment start by length of toktext.
  yield a tuple with 2 elements: tok.name and toktext.
  if tok.next is true,
  substitute tok.next for state.
  break from the loop execution.
  substitute state for self.state.
  derive the class JsLexer from the Lexer base class.
<annotation_end_b>#<body_start> end = len ( text )
 state = self . state
 regexes = self . regexes
 toks = self . toks
 start = 0
  while start < end :
              for match in regexes [ state ] . finditer ( text , start ) :
                  name = match . lastgroup
 tok = toks [ name ]
 toktext = match . group ( name )
 start += len ( toktext )
 yield ( tok . name , toktext )
  if tok . next :
                      state = tok . next
 break
     self . state = state
     class JsLexer ( Lexer ) :
<body_end><annotation_start_b>  call the method m.group with an argument integer 0, substitute the result for s.
  if s equals a string '"',
<annotation_end_b>#<body_start> s = m . group ( 0 )
 if s == '"' :
<body_end><annotation_start_b>  define the function escape_quotes with an argument m.
  call the method m.group with an argument integer 0, substitute the result for s.
  if s equals a string '"',
  return an raw string '\"'.
  if not,
<annotation_end_b>#<body_start> def escape_quotes ( m ) :
 s = m . group ( 0 )
 if s == '"' :
              return r'\"'
  else :
<body_end><annotation_start_b>  call the method __init__ with 2 arguments: self.states and string 'reg' from the base class of the class JsLexer.
  define the function prepare_js_for_gettext with an argument js.
  define the function escape_quotes with an argument m.
  call the method m.group with an argument integer 0, substitute the result for s.
  if s equals a string '"',
  return an raw string '\"'.
  if not,
  return s.
  lexer is an instance of JsLexer class.
  c is an empty list.
  call the method lexer.lex with an arguments js, for every name and tok in the result,
  if name equals a string 'regex',
  tok is a string '"REGEX"',
  otherwise if name starts with a string 'string',
  if tok starts with "'",
  call the function re.sub with 3 arguments: raw string "\\.|.", escape_quotes and tok without the first and last element,
  substitute the result for guts.   concatenate string '"', guts and string '"', substitute the result for tok.
  otherwise if name equals a string 'id'.
  replace every occurrence of '\\' in tok with 'U', substitute the result for tok.
  append tok to c.
<annotation_end_b>#<body_start>          super ( JsLexer , self ) . __init__ ( self . states , 'reg' )
     def prepare_js_for_gettext ( js ) :
 def escape_quotes ( m ) :
 s = m . group ( 0 )
 if s == '"' :
              return r'\"'
  else :
              return s
    lexer = JsLexer ( )
 c = [ ]
 for name , tok in lexer . lex ( js ) :
          if name == 'regex' :
                tok = '"REGEX"'
  elif name == 'string' :
                if tok . startswith ( "'" ) :
                  guts = re . sub ( r"\\.|." , escape_quotes , tok [ 1 : - 1 ] )
 tok = '"' + guts + '"'
   elif name == 'id' :
                 tok = tok . replace ( "\\" , "U" )
  c . append ( tok )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
<annotation_end_b>#<body_start> formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
<body_end><annotation_start_b>  call the method self.callback with an argument record, if the result evaluates to true,
<annotation_end_b>#<body_start>          if self . callback ( record ) :
<body_end><annotation_start_b>  substitute callback for self.callback.
  define the method filter with 2 arguments: self and record.
  call the method self.callback with an argument record, if the result evaluates to true,
  return integer 1.
<annotation_end_b>#<body_start>          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
<annotation_end_b>#<body_start> key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
<body_end><annotation_start_b>  substitute tup for elements of self.
  get the hash value of the tup, substitute it for self.hashvalue.
  define the method __hash__ with an argument self.
  return self.hashvalue.
  define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
  return first element of key.
<annotation_end_b>#<body_start>              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
<body_end><annotation_start_b>  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
<annotation_end_b>#<body_start>                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
<body_end><annotation_start_b>  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
<annotation_end_b>#<body_start>                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
<body_end><annotation_start_b>  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
<annotation_end_b>#<body_start>               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
<body_end><annotation_start_b>  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
<annotation_end_b>#<body_start>                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
<body_end><annotation_start_b>  define the function decorating_function with an argument user_function.
  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  if not,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  with lock,
  substitute nonlocal_root for tuple root.
  if key is contained in cache,
  do nothing.
  otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
  substitute root for oldroot.
  substitute key for value under the KEY key of the oldroot dictionary.
  substitute result for value under the RESULT key of the oldroot dictionary.
  substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
   substitute value under the KEY key of the root dictionary for oldkey.
   substitute value under the RESULT key of the root dictionary for oldvalue.
  root dictionary values under the KEY and RESULT keys are both None.
  delete entry under the oldkey key of the cache dictionary.
  substitute oldroot for value under the key key of the cache dictionary.
  if not,
   substitute value under the PREV key of the root dictionary for last.
  link is a list with 4 elements: last, root, key and result.
  substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
  for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
<annotation_end_b>#<body_start>       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
<body_end><annotation_start_b>  with lock,
<annotation_end_b>#<body_start> with lock :
<body_end><annotation_start_b>  with lock,
  call the method cache.clear.
  substitute first element of nonlocal_root for root.
  root is an list with 4 elements: root, root, None and None.
  stats is a list with 2 elements: 2 integers 0.
  substitute user_function for wrapper.__wrapped__.
  substitute cache_info for wrapper.cache_info.
  substitute cache_clear for wrapper.cache_clear.
<annotation_end_b>#<body_start> with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
<body_end><annotation_start_b>  try,
  substitute record.request for request.
  subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
  of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
  call the method filter.get_request_repr with an argument request, format string '\n{0}' with the result, substitute the result for request_repr.
  if Exception exception is caught,
  subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
  request is None.
  request_repr is a string "unavailable".
  call the function self.format_subject with an argument subject, substitute the result for subject.
  if record.exc_info is true,
  substitute record.exc_info for exc_info.
  if not,
  exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
  message is an string "%s\n\nRequest repr(): %s"  formated with the result of the metod self.format with an argument record,
  and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
  unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
  otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
  and connection as the result of the method self.connection.   define the connection with an argument self.
  call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
  define the method format_subject with 2 arguments: self and subject.
  replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
  substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
  derive the class CallbackFilter from logging.Filter base class.
  define the method __init__ with 2 arguments: self and callback.
  substitute callback for self.callback.
  define the method filter with 2 arguments: self and record.
  call the method self.callback with an argument record, if the result evaluates to true,
  return integer 1.
  return integer 0.
  derive the class RequireDebugFalse from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  if settings.DEBUG is true, return boolean False, otherwise return boolean True.
  derive the class RequireDebugTrue from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  return settings.DEBUG.
  try,
  from functools import lru_cache.
  if ImportError exception is caught.
  from collections import namedtuple.
  from functools import update_wrapper.
  from threading import RLock.
  _CacheInfo is an instance of namedtuple class created with 2 arguments: string "CacheInfo" and a list with 4 elements: string 'hits',
  "misses", "maxsize" and "currsize".   derive class _HashedSeq from list base class.
  __slots__ is a string 'hashvalue'.
  define the method __init__ with 3 arguments: self, tup and hash set to hash.
  substitute tup for elements of self.
  get the hash value of the tup, substitute it for self.hashvalue.
  define the method __hash__ with an argument self.
  return self.hashvalue.
  define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
  return first element of key.
  return instance of _HashedSeq class, created with an argument key.
  define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
  define the function decorating_function with an argument user_function.
  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  if not,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  with lock,
  substitute nonlocal_root for tuple root.
  if key is contained in cache,
  do nothing.
  otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
  substitute root for oldroot.
  substitute key for value under the KEY key of the oldroot dictionary.
  substitute result for value under the RESULT key of the oldroot dictionary.
  substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
   substitute value under the KEY key of the root dictionary for oldkey.
   substitute value under the RESULT key of the root dictionary for oldvalue.
  root dictionary values under the KEY and RESULT keys are both None.
  delete entry under the oldkey key of the cache dictionary.
  substitute oldroot for value under the key key of the cache dictionary.
  if not,
   substitute value under the PREV key of the root dictionary for last.
  link is a list with 4 elements: last, root, key and result.
  substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
  for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
  return result.
  define the function cache_info.
  with lock,
  return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
  value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
  with lock,
  call the method cache.clear.
  substitute first element of nonlocal_root for root.
  root is an list with 4 elements: root, root, None and None.
  stats is a list with 2 elements: 2 integers 0.
  substitute user_function for wrapper.__wrapped__.
  substitute cache_info for wrapper.cache_info.
  substitute cache_clear for wrapper.cache_clear.
  call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
<annotation_end_b>#<body_start>          try :
              request = record . request
 subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
 filter = get_exception_reporter_filter ( request )
 request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
  except Exception :
              subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
 request = None
 request_repr = "unavailable"
  subject = self . format_subject ( subject )
  if record . exc_info :
              exc_info = record . exc_info
  else :
              exc_info = ( None , record . getMessage ( ) , None )
   message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
 reporter = ExceptionReporter ( request , is_email = True , * exc_info )
 html_message = reporter . get_traceback_html ( ) if self . include_html else None
 mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
   def connection ( self ) :
          return get_connection ( backend = self . email_backend , fail_silently = True )
   def format_subject ( self , subject ) :
 formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
 return formatted_subject [ : 989 ]
     class CallbackFilter ( logging . Filter ) :
 def __init__ ( self , callback ) :
          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
  return 0
     class RequireDebugFalse ( logging . Filter ) :
      def filter ( self , record ) :
          return not settings . DEBUG
     class RequireDebugTrue ( logging . Filter ) :
      def filter ( self , record ) :
          return settings . DEBUG
try :
      from functools import lru_cache
   except ImportError :
           from collections import namedtuple
 from functools import update_wrapper
 from threading import RLock
  _CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
  class _HashedSeq ( list ) :
          __slots__ = 'hashvalue'
  def __init__ ( self , tup , hash = hash ) :
              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
  return _HashedSeq ( key )
   def lru_cache ( maxsize = 100 , typed = False ) :
       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
  return result
    def cache_info ( ) :
 with lock :
                      return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
    def cache_clear ( ) :
 with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
 return update_wrapper ( wrapper , user_function )
<body_end><annotation_start_b>  try,
  split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
  if ValueError exception is caught,
  msg is a string "%s doesn't look like a module path" formated with dotted_path.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
  try,
<annotation_end_b>#<body_start> try :
          module_path , class_name = dotted_path . rsplit ( '.' , 1 )
  except ValueError :
          msg = "%s doesn't look like a module path" % dotted_path
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
   module = import_module ( module_path )
  try :
<body_end><annotation_start_b>  call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
  RemovedInDjango19Warning and stacklevel as integer 2.   try,
  call the function import_string with an argument dotted_path, substitute the result for attr.
  if ImportError, renamed to e, exception is caught,
  msg is a string '%sError importing module %s: "%s"', where '%s' is replaced with error_prefix, dotted_path and e, respectively.
  call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
<annotation_end_b>#<body_start> warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
 try :
          attr = import_string ( dotted_path )
  except ImportError as e :
          msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
 six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
<body_end><annotation_start_b>  try,
  substitute package.__name__ for package_name.
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
<annotation_end_b>#<body_start> try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
<body_end><annotation_start_b>  from django.apps import apps.
  get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
  call the method apps.get_app_configs, for every app_config in the result,
  try,
  if register_to is true,
  call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
  for every module_to_search in args,
  call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
   is exception is caught,
  if register_to is true,
  substitute before_import_registry for register_to._registry.
  if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
  raise an exception,
  if first and second element of sys.version_info are both equal to integer 3,
  if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
  from importlib.util import find_spec as importlib_find.
  if not,
  from importlib import find_loader as importlib_find.
  define the function module_has_submodule with 2 arguments: package and module_name.
  try,
  substitute package.__name__ for package_name.
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  concatenate package_name, string '.' and module_name, substitute it for full_module_name.
<annotation_end_b>#<body_start> from django . apps import apps
  register_to = kwargs . get ( 'register_to' )
 for app_config in apps . get_app_configs ( ) :
           try :
              if register_to :
                  before_import_registry = copy . copy ( register_to . _registry )
   for module_to_search in args :
                  import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
   except :
                  if register_to :
                  register_to . _registry = before_import_registry
      if module_has_submodule ( app_config . module , module_to_search ) :
                  raise
       if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
      if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
          from importlib . util import find_spec as importlib_find
  else :
          from importlib import find_loader as importlib_find
   def module_has_submodule ( package , module_name ) :
 try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
               return False
   full_module_name = package_name + '.' + module_name
<body_end><annotation_start_b>  join package.__name__ and module_name into a string separated with '.', substitute it for name.
  try,
<annotation_end_b>#<body_start> name = "." . join ( [ package . __name__ , module_name ] )
 try :
<body_end><annotation_start_b>  call the method logging.Handler.__init__ with an argument self.
  substitute include_html for self.include_html.
  substitute email_backend for self.email_backend.
  define the method emit with 2 arguments: self and record.
  try,
  substitute record.request for request.
  subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
  of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
  call the method filter.get_request_repr with an argument request, format string '\n{0}' with the result, substitute the result for request_repr.
  if Exception exception is caught,
  subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
  request is None.
  request_repr is a string "unavailable".
  call the function self.format_subject with an argument subject, substitute the result for subject.
  if record.exc_info is true,
  substitute record.exc_info for exc_info.
  if not,
  exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
  message is an string "%s\n\nRequest repr(): %s"  formated with the result of the metod self.format with an argument record,
  and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
  unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
  otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
  and connection as the result of the method self.connection.   define the connection with an argument self.
  call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
  define the method format_subject with 2 arguments: self and subject.
  replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
  substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
  derive the class CallbackFilter from logging.Filter base class.
  define the method __init__ with 2 arguments: self and callback.
  substitute callback for self.callback.
  define the method filter with 2 arguments: self and record.
  call the method self.callback with an argument record, if the result evaluates to true,
  return integer 1.
  return integer 0.
  derive the class RequireDebugFalse from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  if settings.DEBUG is true, return boolean False, otherwise return boolean True.
  derive the class RequireDebugTrue from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  return settings.DEBUG.
  try,
  from functools import lru_cache.
  if ImportError exception is caught.
  from collections import namedtuple.
  from functools import update_wrapper.
  from threading import RLock.
  _CacheInfo is an instance of namedtuple class created with 2 arguments: string "CacheInfo" and a list with 4 elements: string 'hits',
  "misses", "maxsize" and "currsize".   derive class _HashedSeq from list base class.
  __slots__ is a string 'hashvalue'.
  define the method __init__ with 3 arguments: self, tup and hash set to hash.
  substitute tup for elements of self.
  get the hash value of the tup, substitute it for self.hashvalue.
  define the method __hash__ with an argument self.
  return self.hashvalue.
  define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
  return first element of key.
  return instance of _HashedSeq class, created with an argument key.
  define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
  define the function decorating_function with an argument user_function.
  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  if not,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  with lock,
  substitute nonlocal_root for tuple root.
  if key is contained in cache,
  do nothing.
  otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
  substitute root for oldroot.
  substitute key for value under the KEY key of the oldroot dictionary.
  substitute result for value under the RESULT key of the oldroot dictionary.
  substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
   substitute value under the KEY key of the root dictionary for oldkey.
   substitute value under the RESULT key of the root dictionary for oldvalue.
  root dictionary values under the KEY and RESULT keys are both None.
  delete entry under the oldkey key of the cache dictionary.
  substitute oldroot for value under the key key of the cache dictionary.
  if not,
   substitute value under the PREV key of the root dictionary for last.
  link is a list with 4 elements: last, root, key and result.
  substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
  for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
  return result.
  define the function cache_info.
  with lock,
  return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
  value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
  with lock,
  call the method cache.clear.
  substitute first element of nonlocal_root for root.
  root is an list with 4 elements: root, root, None and None.
  stats is a list with 2 elements: 2 integers 0.
  substitute user_function for wrapper.__wrapped__.
  substitute cache_info for wrapper.cache_info.
  substitute cache_clear for wrapper.cache_clear.
  call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
  return decorating_function.
  from __future__ import absolute_import into default name space.
  import module copy.
  from importlib import import_module into default name space.
  import module os.
  import module sys.
  import module warnings.
  from django.core.exceptions import ImproperlyConfigured into default name space.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  define the function import_string with an argument dotted_path.
  try,
  split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
  if ValueError exception is caught,
  msg is a string "%s doesn't look like a module path" formated with dotted_path.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
  try,
  get attribute class_name form the module object, return it.
  if AttributeError exception is caught,
  msg is a string 'Module "%s" does not define a "%s" attribute/class' formated with dotted_path and class_name, respectively.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..
  call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
  RemovedInDjango19Warning and stacklevel as integer 2.   try,
  call the function import_string with an argument dotted_path, substitute the result for attr.
  if ImportError, renamed to e, exception is caught,
  msg is a string '%sError importing module %s: "%s"', where '%s' is replaced with error_prefix, dotted_path and e, respectively.
  call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
  and third element of the function sys.exc_info result.   return attr.
  define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs.
  from django.apps import apps.
  get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
  call the method apps.get_app_configs, for every app_config in the result,
  try,
  if register_to is true,
  call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
  for every module_to_search in args,
  call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
   is exception is caught,
  if register_to is true,
  substitute before_import_registry for register_to._registry.
  if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
  raise an exception,
  if first and second element of sys.version_info are both equal to integer 3,
  if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
  from importlib.util import find_spec as importlib_find.
  if not,
  from importlib import find_loader as importlib_find.
  define the function module_has_submodule with 2 arguments: package and module_name.
  try,
  substitute package.__name__ for package_name.
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  concatenate package_name, string '.' and module_name, substitute it for full_module_name.
  call the function importlib_find with 2 arguments: full_module_name and package_path, if the result is not None, return boolean True,
  otherwise return boolean False.   if not,
  import imp.
  define the function module_has_submodule with 2 arguments: package and module_name.
  join package.__name__ and module_name into a string separated with '.', substitute it for name.
  try,
  if value under the name key of the sys.modules dictionary is not None, return boolean True, otherwise return boolean False.
  if KeyError exception is caught,
  do nothing.
  try,
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
<annotation_end_b>#<body_start>          logging . Handler . __init__ ( self )
 self . include_html = include_html
 self . email_backend = email_backend
   def emit ( self , record ) :
          try :
              request = record . request
 subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
 filter = get_exception_reporter_filter ( request )
 request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
  except Exception :
              subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
 request = None
 request_repr = "unavailable"
  subject = self . format_subject ( subject )
  if record . exc_info :
              exc_info = record . exc_info
  else :
              exc_info = ( None , record . getMessage ( ) , None )
   message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
 reporter = ExceptionReporter ( request , is_email = True , * exc_info )
 html_message = reporter . get_traceback_html ( ) if self . include_html else None
 mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
   def connection ( self ) :
          return get_connection ( backend = self . email_backend , fail_silently = True )
   def format_subject ( self , subject ) :
 formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
 return formatted_subject [ : 989 ]
     class CallbackFilter ( logging . Filter ) :
 def __init__ ( self , callback ) :
          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
  return 0
     class RequireDebugFalse ( logging . Filter ) :
      def filter ( self , record ) :
          return not settings . DEBUG
     class RequireDebugTrue ( logging . Filter ) :
      def filter ( self , record ) :
          return settings . DEBUG
try :
      from functools import lru_cache
   except ImportError :
           from collections import namedtuple
 from functools import update_wrapper
 from threading import RLock
  _CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
  class _HashedSeq ( list ) :
          __slots__ = 'hashvalue'
  def __init__ ( self , tup , hash = hash ) :
              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
  return _HashedSeq ( key )
   def lru_cache ( maxsize = 100 , typed = False ) :
       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
  return result
    def cache_info ( ) :
 with lock :
                      return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
    def cache_clear ( ) :
 with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
 return update_wrapper ( wrapper , user_function )
   return decorating_function
from __future__ import absolute_import
  import copy
 from importlib import import_module
 import os
 import sys
 import warnings
  from django . core . exceptions import ImproperlyConfigured
 from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
   def import_string ( dotted_path ) :
 try :
          module_path , class_name = dotted_path . rsplit ( '.' , 1 )
  except ValueError :
          msg = "%s doesn't look like a module path" % dotted_path
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
   module = import_module ( module_path )
  try :
          return getattr ( module , class_name )
  except AttributeError :
          msg = 'Module "%s" does not define a "%s" attribute/class' % (  dotted_path , class_name )
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
     def import_by_path ( dotted_path , error_prefix = '' ) :
 warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
 try :
          attr = import_string ( dotted_path )
  except ImportError as e :
          msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
 six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
  return attr
    def autodiscover_modules ( * args , ** kwargs ) :
 from django . apps import apps
  register_to = kwargs . get ( 'register_to' )
 for app_config in apps . get_app_configs ( ) :
           try :
              if register_to :
                  before_import_registry = copy . copy ( register_to . _registry )
   for module_to_search in args :
                  import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
   except :
                  if register_to :
                  register_to . _registry = before_import_registry
      if module_has_submodule ( app_config . module , module_to_search ) :
                  raise
       if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
      if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
          from importlib . util import find_spec as importlib_find
  else :
          from importlib import find_loader as importlib_find
   def module_has_submodule ( package , module_name ) :
 try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
               return False
   full_module_name = package_name + '.' + module_name
 return importlib_find ( full_module_name , package_path ) is not None
    else :
      import imp
  def module_has_submodule ( package , module_name ) :
 name = "." . join ( [ package . __name__ , module_name ] )
 try :
               return sys . modules [ name ] is not None
  except KeyError :
              pass
  try :
              package_path = package . __path__
  except AttributeError :
<body_end><annotation_start_b>  if sys.warnoptions is false,
  call the method logging.captureWarnings with an argument boolean True.
  call the function warnings.simplefilter with 2 arguments: string "default" and RemovedInNextVersionWarning.
  if logging_config is true,
  call the function import_string with an argument logging_config, substitute the result for logging_config_func.
  call the function logging_config_func with an argument DEFAULT_LOGGING.
  if logging_settings is true,
  call the function logging_config_func with an argument logging_settings.
  derive the class AdminEmailHandler from logging.Handler base class.
  define the method __init__ with 3 arguments: self, include_html set to boolean False and email_backend set to None.
  call the method logging.Handler.__init__ with an argument self.
  substitute include_html for self.include_html.
  substitute email_backend for self.email_backend.
  define the method emit with 2 arguments: self and record.
  try,
  substitute record.request for request.
  subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
  of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
  call the method filter.get_request_repr with an argument request, format string '\n{0}' with the result, substitute the result for request_repr.
  if Exception exception is caught,
  subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
  request is None.
  request_repr is a string "unavailable".
  call the function self.format_subject with an argument subject, substitute the result for subject.
  if record.exc_info is true,
  substitute record.exc_info for exc_info.
  if not,
  exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
  message is an string "%s\n\nRequest repr(): %s"  formated with the result of the metod self.format with an argument record,
  and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
  unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
  otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
  and connection as the result of the method self.connection.   define the connection with an argument self.
  call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
  define the method format_subject with 2 arguments: self and subject.
  replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
  substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
  derive the class CallbackFilter from logging.Filter base class.
  define the method __init__ with 2 arguments: self and callback.
  substitute callback for self.callback.
  define the method filter with 2 arguments: self and record.
  call the method self.callback with an argument record, if the result evaluates to true,
  return integer 1.
  return integer 0.
  derive the class RequireDebugFalse from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  if settings.DEBUG is true, return boolean False, otherwise return boolean True.
  derive the class RequireDebugTrue from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  return settings.DEBUG.
  try,
  from functools import lru_cache.
  if ImportError exception is caught.
  from collections import namedtuple.
  from functools import update_wrapper.
  from threading import RLock.
  _CacheInfo is an instance of namedtuple class created with 2 arguments: string "CacheInfo" and a list with 4 elements: string 'hits',
  "misses", "maxsize" and "currsize".   derive class _HashedSeq from list base class.
  __slots__ is a string 'hashvalue'.
  define the method __init__ with 3 arguments: self, tup and hash set to hash.
  substitute tup for elements of self.
  get the hash value of the tup, substitute it for self.hashvalue.
  define the method __hash__ with an argument self.
  return self.hashvalue.
  define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
  return first element of key.
  return instance of _HashedSeq class, created with an argument key.
  define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
  define the function decorating_function with an argument user_function.
  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  if not,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  with lock,
  substitute nonlocal_root for tuple root.
  if key is contained in cache,
  do nothing.
  otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
  substitute root for oldroot.
  substitute key for value under the KEY key of the oldroot dictionary.
  substitute result for value under the RESULT key of the oldroot dictionary.
  substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
   substitute value under the KEY key of the root dictionary for oldkey.
   substitute value under the RESULT key of the root dictionary for oldvalue.
  root dictionary values under the KEY and RESULT keys are both None.
  delete entry under the oldkey key of the cache dictionary.
  substitute oldroot for value under the key key of the cache dictionary.
  if not,
   substitute value under the PREV key of the root dictionary for last.
  link is a list with 4 elements: last, root, key and result.
  substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
  for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
  return result.
  define the function cache_info.
  with lock,
  return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
  value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
  with lock,
  call the method cache.clear.
  substitute first element of nonlocal_root for root.
  root is an list with 4 elements: root, root, None and None.
  stats is a list with 2 elements: 2 integers 0.
  substitute user_function for wrapper.__wrapped__.
  substitute cache_info for wrapper.cache_info.
  substitute cache_clear for wrapper.cache_clear.
  call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
  return decorating_function.
  from __future__ import absolute_import into default name space.
  import module copy.
  from importlib import import_module into default name space.
  import module os.
  import module sys.
  import module warnings.
  from django.core.exceptions import ImproperlyConfigured into default name space.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  define the function import_string with an argument dotted_path.
  try,
  split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
  if ValueError exception is caught,
  msg is a string "%s doesn't look like a module path" formated with dotted_path.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
  try,
  get attribute class_name form the module object, return it.
  if AttributeError exception is caught,
  msg is a string 'Module "%s" does not define a "%s" attribute/class' formated with dotted_path and class_name, respectively.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..
  call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
  RemovedInDjango19Warning and stacklevel as integer 2.   try,
  call the function import_string with an argument dotted_path, substitute the result for attr.
  if ImportError, renamed to e, exception is caught,
  msg is a string '%sError importing module %s: "%s"', where '%s' is replaced with error_prefix, dotted_path and e, respectively.
  call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
  and third element of the function sys.exc_info result.   return attr.
  define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs.
  from django.apps import apps.
  get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
  call the method apps.get_app_configs, for every app_config in the result,
  try,
  if register_to is true,
  call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
  for every module_to_search in args,
  call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
   is exception is caught,
  if register_to is true,
  substitute before_import_registry for register_to._registry.
  if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
  raise an exception,
  if first and second element of sys.version_info are both equal to integer 3,
  if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
  from importlib.util import find_spec as importlib_find.
  if not,
  from importlib import find_loader as importlib_find.
  define the function module_has_submodule with 2 arguments: package and module_name.
  try,
  substitute package.__name__ for package_name.
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  concatenate package_name, string '.' and module_name, substitute it for full_module_name.
  call the function importlib_find with 2 arguments: full_module_name and package_path, if the result is not None, return boolean True,
  otherwise return boolean False.   if not,
  import imp.
  define the function module_has_submodule with 2 arguments: package and module_name.
  join package.__name__ and module_name into a string separated with '.', substitute it for name.
  try,
  if value under the name key of the sys.modules dictionary is not None, return boolean True, otherwise return boolean False.
  if KeyError exception is caught,
  do nothing.
  try,
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  for every finder in sys.meta_path,
  if call to the method finder.find_module with 2 arguments: name and package_path evaluates to true,
<annotation_end_b>#<body_start>      if not sys . warnoptions :
           logging . captureWarnings ( True )
   warnings . simplefilter ( "default" , RemovedInNextVersionWarning )
   if logging_config :
           logging_config_func = import_string ( logging_config )
  logging_config_func ( DEFAULT_LOGGING )
   if logging_settings :
              logging_config_func ( logging_settings )
      class AdminEmailHandler ( logging . Handler ) :
  def __init__ ( self , include_html = False , email_backend = None ) :
          logging . Handler . __init__ ( self )
 self . include_html = include_html
 self . email_backend = email_backend
   def emit ( self , record ) :
          try :
              request = record . request
 subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
 filter = get_exception_reporter_filter ( request )
 request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
  except Exception :
              subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
 request = None
 request_repr = "unavailable"
  subject = self . format_subject ( subject )
  if record . exc_info :
              exc_info = record . exc_info
  else :
              exc_info = ( None , record . getMessage ( ) , None )
   message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
 reporter = ExceptionReporter ( request , is_email = True , * exc_info )
 html_message = reporter . get_traceback_html ( ) if self . include_html else None
 mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
   def connection ( self ) :
          return get_connection ( backend = self . email_backend , fail_silently = True )
   def format_subject ( self , subject ) :
 formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
 return formatted_subject [ : 989 ]
     class CallbackFilter ( logging . Filter ) :
 def __init__ ( self , callback ) :
          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
  return 0
     class RequireDebugFalse ( logging . Filter ) :
      def filter ( self , record ) :
          return not settings . DEBUG
     class RequireDebugTrue ( logging . Filter ) :
      def filter ( self , record ) :
          return settings . DEBUG
try :
      from functools import lru_cache
   except ImportError :
           from collections import namedtuple
 from functools import update_wrapper
 from threading import RLock
  _CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
  class _HashedSeq ( list ) :
          __slots__ = 'hashvalue'
  def __init__ ( self , tup , hash = hash ) :
              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
  return _HashedSeq ( key )
   def lru_cache ( maxsize = 100 , typed = False ) :
       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
  return result
    def cache_info ( ) :
 with lock :
                      return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
    def cache_clear ( ) :
 with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
 return update_wrapper ( wrapper , user_function )
   return decorating_function
from __future__ import absolute_import
  import copy
 from importlib import import_module
 import os
 import sys
 import warnings
  from django . core . exceptions import ImproperlyConfigured
 from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
   def import_string ( dotted_path ) :
 try :
          module_path , class_name = dotted_path . rsplit ( '.' , 1 )
  except ValueError :
          msg = "%s doesn't look like a module path" % dotted_path
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
   module = import_module ( module_path )
  try :
          return getattr ( module , class_name )
  except AttributeError :
          msg = 'Module "%s" does not define a "%s" attribute/class' % (  dotted_path , class_name )
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
     def import_by_path ( dotted_path , error_prefix = '' ) :
 warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
 try :
          attr = import_string ( dotted_path )
  except ImportError as e :
          msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
 six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
  return attr
    def autodiscover_modules ( * args , ** kwargs ) :
 from django . apps import apps
  register_to = kwargs . get ( 'register_to' )
 for app_config in apps . get_app_configs ( ) :
           try :
              if register_to :
                  before_import_registry = copy . copy ( register_to . _registry )
   for module_to_search in args :
                  import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
   except :
                  if register_to :
                  register_to . _registry = before_import_registry
      if module_has_submodule ( app_config . module , module_to_search ) :
                  raise
       if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
      if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
          from importlib . util import find_spec as importlib_find
  else :
          from importlib import find_loader as importlib_find
   def module_has_submodule ( package , module_name ) :
 try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
               return False
   full_module_name = package_name + '.' + module_name
 return importlib_find ( full_module_name , package_path ) is not None
    else :
      import imp
  def module_has_submodule ( package , module_name ) :
 name = "." . join ( [ package . __name__ , module_name ] )
 try :
               return sys . modules [ name ] is not None
  except KeyError :
              pass
  try :
              package_path = package . __path__
  except AttributeError :
                return False
  for finder in sys . meta_path :
              if finder . find_module ( name , package_path ) :
<body_end><annotation_start_b>  self.regexes is an empty dictionary.
  self.tokens is an empty dictionary.
  call the method states.items, for every state and rules in the result,
  parts is an empty list.
  for every tok in rules,
  groupid is a string "t%d" formated with tok.id.
  substitute tok for value under the groupid key of the self.toks dictionary.
  format a string "(?P<%s>%s)" with groupid and tok.regex, append it to the parts.
  call the function re.compile with 2 arguments: elements of parts joined into a string, separated with '|',
  and result of bitwise OR performed on 2 operands: re.MULTILINE and re.VERBOSE,   substitute the result for value under the state key of the self.regexes dictionary.   substitute first for self.state.
  define the method lex with 2 arguments self and text.
  substitute length of text for end.
  substitute self.state for state.
  substitute self.regexes for regexes.
  substitute self.toks for toks.
  start is an integer 0.
  while start is lesser than end.
  get the value under the state key of the regexes dictionary, call the method finditer on the result with 2 arguments: text and start,
  for every match in the result,   substitute match.lastgroup for name.
  substitute value under the name key of the toks dictionary for tok.
  call the method match.group with an arugument name, substitute the result for toktext.
  increment start by length of toktext.
  yield a tuple with 2 elements: tok.name and toktext.
  if tok.next is true,
  substitute tok.next for state.
  break from the loop execution.
  substitute state for self.state.
  derive the class JsLexer from the Lexer base class.
  both_before is a list containing 14 elements, all of them are instances of Tok class, created with 2 arguments, a string and a raw string.
  both_after is an list with an element instance of Tok class, created with 2 arguments: string 'other' and raw string '.'.
  states is a dictionary with 2 arguments: appended list with an element instance of a class Tok, created with 3 arguments: "punct",
  result of the function literals called with an argument string "/= /" and next as a string 'reg', to the both_before,   appended both_after to the previous result, for 'div' and appended list with an element instance of a class Tok,   created with 3 arguments: string "regex",   raw string '/([^*\\/[]|\\.|\[(   [^\]\\]|   \\.)*\])(   [^\\/[]|   \\.|   \[(   [^\]\\]|   \\.)*\])*/[a-zA-Z0-9]*',   and next as a string 'div', to the both_before, appended both_after to the previous result for 'div'.   define the method __init__ with an argument self.
  call the method __init__ with 2 arguments: self.states and string 'reg' from the base class of the class JsLexer.
  define the function prepare_js_for_gettext with an argument js.
  define the function escape_quotes with an argument m.
  call the method m.group with an argument integer 0, substitute the result for s.
  if s equals a string '"',
  return an raw string '\"'.
  if not,
  return s.
  lexer is an instance of JsLexer class.
  c is an empty list.
  call the method lexer.lex with an arguments js, for every name and tok in the result,
  if name equals a string 'regex',
  tok is a string '"REGEX"',
  otherwise if name starts with a string 'string',
  if tok starts with "'",
  call the function re.sub with 3 arguments: raw string "\\.|.", escape_quotes and tok without the first and last element,
  substitute the result for guts.   concatenate string '"', guts and string '"', substitute the result for tok.
  otherwise if name equals a string 'id'.
  replace every occurrence of '\\' in tok with 'U', substitute the result for tok.
  append tok to c.
  join elements of c into a string, return it.
  import module logging.
  import module sys.
  import module warnings.
  from django.conf import settings into default name space.
  from django.core import mail into default name space.
  from django.core.mail import get_connection into default name space.
  from django.utils.deprecation import RemovedInNextVersionWarning into default name space.
  from django.utils.module_loading import import_string into default name space.
  from django.views.debug import ExceptionReporter and get_exception_reporter_filter into default name space.
  from logging import NullHandler.
  from logging.config import dictConfig.
  substitute logging.getLogger for getLogger.
  DEFAULT_LOGGING is a dictionary with 5 initial entries: 1 for 'version', False for 'disable_existing_loggers',
  and 3 additional pairs of dictionaries for string.   define the function configure_logging with 2 arguments: logging_config and logging_settings.
  if sys.warnoptions is false,
  call the method logging.captureWarnings with an argument boolean True.
  call the function warnings.simplefilter with 2 arguments: string "default" and RemovedInNextVersionWarning.
  if logging_config is true,
  call the function import_string with an argument logging_config, substitute the result for logging_config_func.
  call the function logging_config_func with an argument DEFAULT_LOGGING.
  if logging_settings is true,
  call the function logging_config_func with an argument logging_settings.
  derive the class AdminEmailHandler from logging.Handler base class.
  define the method __init__ with 3 arguments: self, include_html set to boolean False and email_backend set to None.
  call the method logging.Handler.__init__ with an argument self.
  substitute include_html for self.include_html.
  substitute email_backend for self.email_backend.
  define the method emit with 2 arguments: self and record.
  try,
  substitute record.request for request.
  subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
  of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
  call the method filter.get_request_repr with an argument request, format string '\n{0}' with the result, substitute the result for request_repr.
  if Exception exception is caught,
  subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
  request is None.
  request_repr is a string "unavailable".
  call the function self.format_subject with an argument subject, substitute the result for subject.
  if record.exc_info is true,
  substitute record.exc_info for exc_info.
  if not,
  exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
  message is an string "%s\n\nRequest repr(): %s"  formated with the result of the metod self.format with an argument record,
  and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
  unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
  otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
  and connection as the result of the method self.connection.   define the connection with an argument self.
  call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
  define the method format_subject with 2 arguments: self and subject.
  replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
  substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
  derive the class CallbackFilter from logging.Filter base class.
  define the method __init__ with 2 arguments: self and callback.
  substitute callback for self.callback.
  define the method filter with 2 arguments: self and record.
  call the method self.callback with an argument record, if the result evaluates to true,
  return integer 1.
  return integer 0.
  derive the class RequireDebugFalse from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  if settings.DEBUG is true, return boolean False, otherwise return boolean True.
  derive the class RequireDebugTrue from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  return settings.DEBUG.
  try,
  from functools import lru_cache.
  if ImportError exception is caught.
  from collections import namedtuple.
  from functools import update_wrapper.
  from threading import RLock.
  _CacheInfo is an instance of namedtuple class created with 2 arguments: string "CacheInfo" and a list with 4 elements: string 'hits',
  "misses", "maxsize" and "currsize".   derive class _HashedSeq from list base class.
  __slots__ is a string 'hashvalue'.
  define the method __init__ with 3 arguments: self, tup and hash set to hash.
  substitute tup for elements of self.
  get the hash value of the tup, substitute it for self.hashvalue.
  define the method __hash__ with an argument self.
  return self.hashvalue.
  define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
  return first element of key.
  return instance of _HashedSeq class, created with an argument key.
  define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
  define the function decorating_function with an argument user_function.
  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  if not,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  with lock,
  substitute nonlocal_root for tuple root.
  if key is contained in cache,
  do nothing.
  otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
  substitute root for oldroot.
  substitute key for value under the KEY key of the oldroot dictionary.
  substitute result for value under the RESULT key of the oldroot dictionary.
  substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
   substitute value under the KEY key of the root dictionary for oldkey.
   substitute value under the RESULT key of the root dictionary for oldvalue.
  root dictionary values under the KEY and RESULT keys are both None.
  delete entry under the oldkey key of the cache dictionary.
  substitute oldroot for value under the key key of the cache dictionary.
  if not,
   substitute value under the PREV key of the root dictionary for last.
  link is a list with 4 elements: last, root, key and result.
  substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
  for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
  return result.
  define the function cache_info.
  with lock,
  return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
  value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
  with lock,
  call the method cache.clear.
  substitute first element of nonlocal_root for root.
  root is an list with 4 elements: root, root, None and None.
  stats is a list with 2 elements: 2 integers 0.
  substitute user_function for wrapper.__wrapped__.
  substitute cache_info for wrapper.cache_info.
  substitute cache_clear for wrapper.cache_clear.
  call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
  return decorating_function.
  from __future__ import absolute_import into default name space.
  import module copy.
  from importlib import import_module into default name space.
  import module os.
  import module sys.
  import module warnings.
  from django.core.exceptions import ImproperlyConfigured into default name space.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  define the function import_string with an argument dotted_path.
  try,
  split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
  if ValueError exception is caught,
  msg is a string "%s doesn't look like a module path" formated with dotted_path.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
  try,
  get attribute class_name form the module object, return it.
  if AttributeError exception is caught,
  msg is a string 'Module "%s" does not define a "%s" attribute/class' formated with dotted_path and class_name, respectively.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..
  call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
  RemovedInDjango19Warning and stacklevel as integer 2.   try,
  call the function import_string with an argument dotted_path, substitute the result for attr.
  if ImportError, renamed to e, exception is caught,
  msg is a string '%sError importing module %s: "%s"', where '%s' is replaced with error_prefix, dotted_path and e, respectively.
  call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
  and third element of the function sys.exc_info result.   return attr.
  define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs.
  from django.apps import apps.
  get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
  call the method apps.get_app_configs, for every app_config in the result,
  try,
  if register_to is true,
  call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
  for every module_to_search in args,
  call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
   is exception is caught,
  if register_to is true,
  substitute before_import_registry for register_to._registry.
  if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
  raise an exception,
  if first and second element of sys.version_info are both equal to integer 3,
  if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
  from importlib.util import find_spec as importlib_find.
  if not,
  from importlib import find_loader as importlib_find.
  define the function module_has_submodule with 2 arguments: package and module_name.
  try,
  substitute package.__name__ for package_name.
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  concatenate package_name, string '.' and module_name, substitute it for full_module_name.
  call the function importlib_find with 2 arguments: full_module_name and package_path, if the result is not None, return boolean True,
  otherwise return boolean False.   if not,
  import imp.
  define the function module_has_submodule with 2 arguments: package and module_name.
  join package.__name__ and module_name into a string separated with '.', substitute it for name.
  try,
  if value under the name key of the sys.modules dictionary is not None, return boolean True, otherwise return boolean False.
  if KeyError exception is caught,
  do nothing.
  try,
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  for every finder in sys.meta_path,
  if call to the method finder.find_module with 2 arguments: name and package_path evaluates to true,
  return boolean True.
  for every entry in package_path,
  try,
  substitute the value under the entry key of the sys.path_importer_cache dictionary for finder.
  if finder is None,
  try,
  call the method imp.find_module with 2 arguments: module_name and list containing element entry, assign the result to file_, _,
  and _, respectively.   if file_ is true,
  close file_ file descriptor.
<annotation_end_b>#<body_start>          self . regexes = { }
 self . toks = { }
  for state , rules in states . items ( ) :
              parts = [ ]
 for tok in rules :
                  groupid = "t%d" % tok . id
 self . toks [ groupid ] = tok
 parts . append ( "(?P<%s>%s)" % ( groupid , tok . regex ) )
  self . regexes [ state ] = re . compile ( "|" . join ( parts ) , re . MULTILINE | re . VERBOSE )
   self . state = first
   def lex ( self , text ) :
 end = len ( text )
 state = self . state
 regexes = self . regexes
 toks = self . toks
 start = 0
  while start < end :
              for match in regexes [ state ] . finditer ( text , start ) :
                  name = match . lastgroup
 tok = toks [ name ]
 toktext = match . group ( name )
 start += len ( toktext )
 yield ( tok . name , toktext )
  if tok . next :
                      state = tok . next
 break
     self . state = state
     class JsLexer ( Lexer ) :
               both_before = [  Tok ( "comment" , r"/\*(.|\n)*?\*/" ) ,  Tok ( "linecomment" , r"//.*?$" ) ,  Tok ( "ws" , r"\s+" ) ,  Tok ( "keyword" , literals ( """                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            """ , suffix = r"\b" ) , next = 'reg' ) ,  Tok ( "reserved" , literals ( "null true false" , suffix = r"\b" ) , next = 'div' ) ,  Tok ( "id" , r"""                   ([a-zA-Z_$   ]|\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*  # rest chars                   """ , next = 'div' ) ,  Tok ( "hnum" , r"0[xX][0-9a-fA-F]+" , next = 'div' ) ,  Tok ( "onum" , r"0[0-7]+" ) ,  Tok ( "dnum" , r"""                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     """ , next = 'div' ) ,  Tok ( "punct" , literals ( """                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          """ ) , next = "reg" ) ,  Tok ( "punct" , literals ( "++ -- ) ]" ) , next = 'div' ) ,  Tok ( "punct" , literals ( "{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =" ) , next = 'reg' ) ,  Tok ( "string" , r'"([^"\\]|(\\(.|\n)))*?"' , next = 'div' ) ,  Tok ( "string" , r"'([^'\\]|(\\(.|\n)))*?'" , next = 'div' ) ,  ]
  both_after = [  Tok ( "other" , r"." ) ,  ]
  states = {   'div' : both_before + [  Tok ( "punct" , literals ( "/= /" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( "regex" ,  r"""                     /                       # opening slash                     # First character is..                     (   [^*\\/[]            # anything but * \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )                     # Following characters are same, except for excluding a star                     (   [^\\/[]             # anything but \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 """ , next = 'div' ) ,  ] + both_after ,  }
  def __init__ ( self ) :
          super ( JsLexer , self ) . __init__ ( self . states , 'reg' )
     def prepare_js_for_gettext ( js ) :
 def escape_quotes ( m ) :
 s = m . group ( 0 )
 if s == '"' :
              return r'\"'
  else :
              return s
    lexer = JsLexer ( )
 c = [ ]
 for name , tok in lexer . lex ( js ) :
          if name == 'regex' :
                tok = '"REGEX"'
  elif name == 'string' :
                if tok . startswith ( "'" ) :
                  guts = re . sub ( r"\\.|." , escape_quotes , tok [ 1 : - 1 ] )
 tok = '"' + guts + '"'
   elif name == 'id' :
                 tok = tok . replace ( "\\" , "U" )
  c . append ( tok )
  return '' . join ( c )
import logging
 import sys
 import warnings
  from django . conf import settings
 from django . core import mail
 from django . core . mail import get_connection
 from django . utils . deprecation import RemovedInNextVersionWarning
 from django . utils . module_loading import import_string
 from django . views . debug import ExceptionReporter , get_exception_reporter_filter
   from logging import NullHandler
 from logging . config import dictConfig
  getLogger = logging . getLogger
     DEFAULT_LOGGING = {  'version' : 1 ,  'disable_existing_loggers' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }
   def configure_logging ( logging_config , logging_settings ) :
      if not sys . warnoptions :
           logging . captureWarnings ( True )
   warnings . simplefilter ( "default" , RemovedInNextVersionWarning )
   if logging_config :
           logging_config_func = import_string ( logging_config )
  logging_config_func ( DEFAULT_LOGGING )
   if logging_settings :
              logging_config_func ( logging_settings )
      class AdminEmailHandler ( logging . Handler ) :
  def __init__ ( self , include_html = False , email_backend = None ) :
          logging . Handler . __init__ ( self )
 self . include_html = include_html
 self . email_backend = email_backend
   def emit ( self , record ) :
          try :
              request = record . request
 subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
 filter = get_exception_reporter_filter ( request )
 request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
  except Exception :
              subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
 request = None
 request_repr = "unavailable"
  subject = self . format_subject ( subject )
  if record . exc_info :
              exc_info = record . exc_info
  else :
              exc_info = ( None , record . getMessage ( ) , None )
   message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
 reporter = ExceptionReporter ( request , is_email = True , * exc_info )
 html_message = reporter . get_traceback_html ( ) if self . include_html else None
 mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
   def connection ( self ) :
          return get_connection ( backend = self . email_backend , fail_silently = True )
   def format_subject ( self , subject ) :
 formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
 return formatted_subject [ : 989 ]
     class CallbackFilter ( logging . Filter ) :
 def __init__ ( self , callback ) :
          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
  return 0
     class RequireDebugFalse ( logging . Filter ) :
      def filter ( self , record ) :
          return not settings . DEBUG
     class RequireDebugTrue ( logging . Filter ) :
      def filter ( self , record ) :
          return settings . DEBUG
try :
      from functools import lru_cache
   except ImportError :
           from collections import namedtuple
 from functools import update_wrapper
 from threading import RLock
  _CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
  class _HashedSeq ( list ) :
          __slots__ = 'hashvalue'
  def __init__ ( self , tup , hash = hash ) :
              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
  return _HashedSeq ( key )
   def lru_cache ( maxsize = 100 , typed = False ) :
       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
  return result
    def cache_info ( ) :
 with lock :
                      return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
    def cache_clear ( ) :
 with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
 return update_wrapper ( wrapper , user_function )
   return decorating_function
from __future__ import absolute_import
  import copy
 from importlib import import_module
 import os
 import sys
 import warnings
  from django . core . exceptions import ImproperlyConfigured
 from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
   def import_string ( dotted_path ) :
 try :
          module_path , class_name = dotted_path . rsplit ( '.' , 1 )
  except ValueError :
          msg = "%s doesn't look like a module path" % dotted_path
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
   module = import_module ( module_path )
  try :
          return getattr ( module , class_name )
  except AttributeError :
          msg = 'Module "%s" does not define a "%s" attribute/class' % (  dotted_path , class_name )
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
     def import_by_path ( dotted_path , error_prefix = '' ) :
 warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
 try :
          attr = import_string ( dotted_path )
  except ImportError as e :
          msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
 six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
  return attr
    def autodiscover_modules ( * args , ** kwargs ) :
 from django . apps import apps
  register_to = kwargs . get ( 'register_to' )
 for app_config in apps . get_app_configs ( ) :
           try :
              if register_to :
                  before_import_registry = copy . copy ( register_to . _registry )
   for module_to_search in args :
                  import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
   except :
                  if register_to :
                  register_to . _registry = before_import_registry
      if module_has_submodule ( app_config . module , module_to_search ) :
                  raise
       if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
      if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
          from importlib . util import find_spec as importlib_find
  else :
          from importlib import find_loader as importlib_find
   def module_has_submodule ( package , module_name ) :
 try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
               return False
   full_module_name = package_name + '.' + module_name
 return importlib_find ( full_module_name , package_path ) is not None
    else :
      import imp
  def module_has_submodule ( package , module_name ) :
 name = "." . join ( [ package . __name__ , module_name ] )
 try :
               return sys . modules [ name ] is not None
  except KeyError :
              pass
  try :
              package_path = package . __path__
  except AttributeError :
                return False
  for finder in sys . meta_path :
              if finder . find_module ( name , package_path ) :
                  return True
   for entry in package_path :
              try :
                   finder = sys . path_importer_cache [ entry ]
 if finder is None :
                       try :
                          file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
 if file_ :
                              file_ . close ( )
<body_end><annotation_start_b>  substitute Tok.num for self.id.
  increment Tok.num with an integer 1.
  substitute name for self.name.
  substitute regex for self.regex.
  substitute next for self.next.
  define the function literals with 3 arguments: choices, prefix set to an empty string and suffix set to an empty string.
  for every c in choices split into words, concatenate prefix, result of the function re.escape with an argument c and suffix,
  and join the results into a string, separated with '|' character, return the result.   derive the class Lexer from the object base class.
  define the method __init__ with 3 arguments self, states and first.
  self.regexes is an empty dictionary.
  self.tokens is an empty dictionary.
  call the method states.items, for every state and rules in the result,
  parts is an empty list.
  for every tok in rules,
  groupid is a string "t%d" formated with tok.id.
  substitute tok for value under the groupid key of the self.toks dictionary.
  format a string "(?P<%s>%s)" with groupid and tok.regex, append it to the parts.
  call the function re.compile with 2 arguments: elements of parts joined into a string, separated with '|',
  and result of bitwise OR performed on 2 operands: re.MULTILINE and re.VERBOSE,   substitute the result for value under the state key of the self.regexes dictionary.   substitute first for self.state.
  define the method lex with 2 arguments self and text.
  substitute length of text for end.
  substitute self.state for state.
  substitute self.regexes for regexes.
  substitute self.toks for toks.
  start is an integer 0.
  while start is lesser than end.
  get the value under the state key of the regexes dictionary, call the method finditer on the result with 2 arguments: text and start,
  for every match in the result,   substitute match.lastgroup for name.
  substitute value under the name key of the toks dictionary for tok.
  call the method match.group with an arugument name, substitute the result for toktext.
  increment start by length of toktext.
  yield a tuple with 2 elements: tok.name and toktext.
  if tok.next is true,
  substitute tok.next for state.
  break from the loop execution.
  substitute state for self.state.
  derive the class JsLexer from the Lexer base class.
  both_before is a list containing 14 elements, all of them are instances of Tok class, created with 2 arguments, a string and a raw string.
  both_after is an list with an element instance of Tok class, created with 2 arguments: string 'other' and raw string '.'.
  states is a dictionary with 2 arguments: appended list with an element instance of a class Tok, created with 3 arguments: "punct",
  result of the function literals called with an argument string "/= /" and next as a string 'reg', to the both_before,   appended both_after to the previous result, for 'div' and appended list with an element instance of a class Tok,   created with 3 arguments: string "regex",   raw string '/([^*\\/[]|\\.|\[(   [^\]\\]|   \\.)*\])(   [^\\/[]|   \\.|   \[(   [^\]\\]|   \\.)*\])*/[a-zA-Z0-9]*',   and next as a string 'div', to the both_before, appended both_after to the previous result for 'div'.   define the method __init__ with an argument self.
  call the method __init__ with 2 arguments: self.states and string 'reg' from the base class of the class JsLexer.
  define the function prepare_js_for_gettext with an argument js.
  define the function escape_quotes with an argument m.
  call the method m.group with an argument integer 0, substitute the result for s.
  if s equals a string '"',
  return an raw string '\"'.
  if not,
  return s.
  lexer is an instance of JsLexer class.
  c is an empty list.
  call the method lexer.lex with an arguments js, for every name and tok in the result,
  if name equals a string 'regex',
  tok is a string '"REGEX"',
  otherwise if name starts with a string 'string',
  if tok starts with "'",
  call the function re.sub with 3 arguments: raw string "\\.|.", escape_quotes and tok without the first and last element,
  substitute the result for guts.   concatenate string '"', guts and string '"', substitute the result for tok.
  otherwise if name equals a string 'id'.
  replace every occurrence of '\\' in tok with 'U', substitute the result for tok.
  append tok to c.
  join elements of c into a string, return it.
  import module logging.
  import module sys.
  import module warnings.
  from django.conf import settings into default name space.
  from django.core import mail into default name space.
  from django.core.mail import get_connection into default name space.
  from django.utils.deprecation import RemovedInNextVersionWarning into default name space.
  from django.utils.module_loading import import_string into default name space.
  from django.views.debug import ExceptionReporter and get_exception_reporter_filter into default name space.
  from logging import NullHandler.
  from logging.config import dictConfig.
  substitute logging.getLogger for getLogger.
  DEFAULT_LOGGING is a dictionary with 5 initial entries: 1 for 'version', False for 'disable_existing_loggers',
  and 3 additional pairs of dictionaries for string.   define the function configure_logging with 2 arguments: logging_config and logging_settings.
  if sys.warnoptions is false,
  call the method logging.captureWarnings with an argument boolean True.
  call the function warnings.simplefilter with 2 arguments: string "default" and RemovedInNextVersionWarning.
  if logging_config is true,
  call the function import_string with an argument logging_config, substitute the result for logging_config_func.
  call the function logging_config_func with an argument DEFAULT_LOGGING.
  if logging_settings is true,
  call the function logging_config_func with an argument logging_settings.
  derive the class AdminEmailHandler from logging.Handler base class.
  define the method __init__ with 3 arguments: self, include_html set to boolean False and email_backend set to None.
  call the method logging.Handler.__init__ with an argument self.
  substitute include_html for self.include_html.
  substitute email_backend for self.email_backend.
  define the method emit with 2 arguments: self and record.
  try,
  substitute record.request for request.
  subject is an string '%s (%s IP): %s', formated with record.levelname, string 'internal' if value under the 'REMOTE_ADDR' key,
  of the request.META dictionary is contained in settings.INTERNAL_IPS, otherwise use string 'EXTERNAL',   and result of the method record.getMessage.   call the function get_exception_reporter_filter with an argument request, substitute the result for filter.
  call the method filter.get_request_repr with an argument request, format string '\n{0}' with the result, substitute the result for request_repr.
  if Exception exception is caught,
  subject is an string '%s: %s' formated with record.levelname and result of the method record.getMessage, respectively.
  request is None.
  request_repr is a string "unavailable".
  call the function self.format_subject with an argument subject, substitute the result for subject.
  if record.exc_info is true,
  substitute record.exc_info for exc_info.
  if not,
  exc_info is an tuple with 3 elements: None, result of method record.getMessage and None.
  message is an string "%s\n\nRequest repr(): %s"  formated with the result of the metod self.format with an argument record,
  and request_repr, respectively.   reporter is an instance of ExceptionReporter class, created with 3 arguments: request, is_email as boolean True,
  unpacked list exc_info.   if self.include_html is true, call the method reporter.get_traceback_html and substitute the result for html_message,
  otherwise html_message is None.   call the method mail.mail_admins with 5 arguments: subject, message, fail_silently as boolean True, tml_message as html_message,
  and connection as the result of the method self.connection.   define the connection with an argument self.
  call the function get_connection with 2 arguments: backend set to self.email_backend and fail_silently set to boolean True.
  define the method format_subject with 2 arguments: self and subject.
  replace every occurrence of '\n' in subject with '\\n' and replace every occurrence of '\r' in subject with '\\r',
  substitute the result for formatted_subject.   return first 989 elements of formatted_subject.
  derive the class CallbackFilter from logging.Filter base class.
  define the method __init__ with 2 arguments: self and callback.
  substitute callback for self.callback.
  define the method filter with 2 arguments: self and record.
  call the method self.callback with an argument record, if the result evaluates to true,
  return integer 1.
  return integer 0.
  derive the class RequireDebugFalse from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  if settings.DEBUG is true, return boolean False, otherwise return boolean True.
  derive the class RequireDebugTrue from logging.Filter base class.
  define the method filter with 2 arguments: self and record.
  return settings.DEBUG.
  try,
  from functools import lru_cache.
  if ImportError exception is caught.
  from collections import namedtuple.
  from functools import update_wrapper.
  from threading import RLock.
  _CacheInfo is an instance of namedtuple class created with 2 arguments: string "CacheInfo" and a list with 4 elements: string 'hits',
  "misses", "maxsize" and "currsize".   derive class _HashedSeq from list base class.
  __slots__ is a string 'hashvalue'.
  define the method __init__ with 3 arguments: self, tup and hash set to hash.
  substitute tup for elements of self.
  get the hash value of the tup, substitute it for self.hashvalue.
  define the method __hash__ with an argument self.
  return self.hashvalue.
  define the function _make_key with 9 arguments: args, kwds, typed, kwd_mark as a tuple with an element result of the function object,
  substitute args for key.
  if kwds is true,
  sort elements of kwds, substitute the result for sorted_items.
  increment key by kwd_mark.
  for every item in sorted_items,
  increment key by item.
  if typed is true,
  create a tuple out of types of v, for every v in args, extend key tuple with the result.
  if kwds is true,
  create a tuple out of types of v, for every k and v in sorted_items, extend key tuple with the result.
  otherwise if length of key equals integer 1 and type of first element of key is contained in fasttypes,
  return first element of key.
  return instance of _HashedSeq class, created with an argument key.
  define the function lru_cache with 2 arguments maxsize set to integer 100 and typed set to boolean False.
  define the function decorating_function with an argument user_function.
  cache is an empty dictionary.
  stats is an list with 2 elements: 2 integers 0.
  HITS and MISSES are integer 0 and 1, respectively.
  substitute _make_key for make_key.
  substitute cache.get for cache_get.
  substitute len for _len.
  lock is an instance of RLock class.
  root is an empty list.
  root is a list with elements: root, root, None and None.
  nonlocal_root is an list with an element root.
  substitute integers 0, 1, 2 and 3 for PREV, NEXT, KEY and RESULT, respectivley.
  if maxsize equals integer 0,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  otherwise if maxsize is None,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key.
  call the function cache_get with 2 arguments: key and root, substitute the result for result.
  if result is not root,
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments unpacked list args and unpacked dictionary kwds, substitute the result for result.
  substitute result for cache dictionary value under the key key.
  increment stats dictionary value under the MISSES key by integer 1.
  return result.
  if not,
  define the function wrapper with 2 arguments: unpacked list args and unpacked dictionary kwds.
  if kwds is true or typed is true, call the function make_key with 3 arguments: args, kwds and typed, substitute the result for key,
  otherwise substitute args for key.   with lock,
  call the function cache_get with an argument key, substitute the result for link.
  if link is not None,
  substitute nonlocal_root for a tuple with an element root.
  substitute link for link_prev, link_next, key and result, respectively.
  substitute link_next for value under the NEXT key of the link_prev dictionary.
  substitute link_prev for value under the PREV key of the link_next dictionary.
  substitute value under the PREV key of the root dictionary for last.
  substitute link for values under the NEXT key of the last dictionary and PREV key of the root dictionary.
  substitute last for value under the PREV key of the link dictionary.
  substitute root for value under the NEXT key of the link dictionary.
  increment stats dictionary value under the HITS key by integer 1.
  return result.
  call the function user_function with 2 arguments: unpacked list args and unpacked dictionary kwds, substitute the result for result.
  with lock,
  substitute nonlocal_root for tuple root.
  if key is contained in cache,
  do nothing.
  otherwise if result of the call to the function _len with an argument cache is greater than or equal to maxsize,
  substitute root for oldroot.
  substitute key for value under the KEY key of the oldroot dictionary.
  substitute result for value under the RESULT key of the oldroot dictionary.
  substitute value under the NEXT key of the oldroot dictionary for root and first element of nonlocal_root.
   substitute value under the KEY key of the root dictionary for oldkey.
   substitute value under the RESULT key of the root dictionary for oldvalue.
  root dictionary values under the KEY and RESULT keys are both None.
  delete entry under the oldkey key of the cache dictionary.
  substitute oldroot for value under the key key of the cache dictionary.
  if not,
   substitute value under the PREV key of the root dictionary for last.
  link is a list with 4 elements: last, root, key and result.
  substitute link for value under the NEXT key of the last dictionary, for value under the PREV key of the root dictionary,
  for value under the key key of the cache dictionary.   increment stats dictionary value under the MISSES key by integer 1.
  return result.
  define the function cache_info.
  with lock,
  return an instance of _CacheInfo class, created with 4 arguments: value under the HITS key of the stats dictionary,
  value under the MISSES key of the stats dictionary, maxsize and length of cache.   define the function cache_clear.
  with lock,
  call the method cache.clear.
  substitute first element of nonlocal_root for root.
  root is an list with 4 elements: root, root, None and None.
  stats is a list with 2 elements: 2 integers 0.
  substitute user_function for wrapper.__wrapped__.
  substitute cache_info for wrapper.cache_info.
  substitute cache_clear for wrapper.cache_clear.
  call the function update_wrapper with 2 arguments: wrapper and user_function, return the result.
  return decorating_function.
  from __future__ import absolute_import into default name space.
  import module copy.
  from importlib import import_module into default name space.
  import module os.
  import module sys.
  import module warnings.
  from django.core.exceptions import ImproperlyConfigured into default name space.
  from django.utils import six into default name space.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  define the function import_string with an argument dotted_path.
  try,
  split dotted_path into two parts from the right at the '.' character, assign the result to module_path and class_name, respectively.
  if ValueError exception is caught,
  msg is a string "%s doesn't look like a module path" formated with dotted_path.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   call the function import_module with an argument module_path, substitute the result for module.
  try,
  get attribute class_name form the module object, return it.
  if AttributeError exception is caught,
  msg is a string 'Module "%s" does not define a "%s" attribute/class' formated with dotted_path and class_name, respectively.
  call the function six.reraise with 3 arguments: ImportError, instance of ImportError class created with an argument msg,
  and third element of result of the function sys.exc_info.   define the function import_by_path with 2 arguments dotted_path and error_prefix set to an empty string..
  call the function warnings.warn with 3 arguments: string 'import_by_path() has been deprecated. Use import_string() instead.',
  RemovedInDjango19Warning and stacklevel as integer 2.   try,
  call the function import_string with an argument dotted_path, substitute the result for attr.
  if ImportError, renamed to e, exception is caught,
  msg is a string '%sError importing module %s: "%s"', where '%s' is replaced with error_prefix, dotted_path and e, respectively.
  call the function six.reraise with 3 arguments: ImproperlyConfigured, instance of ImproperlyConfigured class created with msg,
  and third element of the function sys.exc_info result.   return attr.
  define the function autodiscover_modules with 2 arguments unpacked list args and unpacked dictionary kwargs.
  from django.apps import apps.
  get value under the 'register_to' key of the kwargs dictionary, substitute it for register_to.
  call the method apps.get_app_configs, for every app_config in the result,
  try,
  if register_to is true,
  call the method copy.copy with an argument register_to._registry, substitute the result for before_import_registry.
  for every module_to_search in args,
  call the function import_module with an argument string '%s.%s', where '%s' is replaced with app_config.name and module_to_search.
   is exception is caught,
  if register_to is true,
  substitute before_import_registry for register_to._registry.
  if call to the function module_has_submodule with 2 arguments: app_config.module and module_to_search evaluates to true,
  raise an exception,
  if first and second element of sys.version_info are both equal to integer 3,
  if first and second element of sys.version_info are equal to integers 3 and 4, respectively,
  from importlib.util import find_spec as importlib_find.
  if not,
  from importlib import find_loader as importlib_find.
  define the function module_has_submodule with 2 arguments: package and module_name.
  try,
  substitute package.__name__ for package_name.
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  concatenate package_name, string '.' and module_name, substitute it for full_module_name.
  call the function importlib_find with 2 arguments: full_module_name and package_path, if the result is not None, return boolean True,
  otherwise return boolean False.   if not,
  import imp.
  define the function module_has_submodule with 2 arguments: package and module_name.
  join package.__name__ and module_name into a string separated with '.', substitute it for name.
  try,
  if value under the name key of the sys.modules dictionary is not None, return boolean True, otherwise return boolean False.
  if KeyError exception is caught,
  do nothing.
  try,
  substitute package.__path__ for package_path.
  if AttributeError exception is caught,
  return boolean False.
  for every finder in sys.meta_path,
  if call to the method finder.find_module with 2 arguments: name and package_path evaluates to true,
  return boolean True.
  for every entry in package_path,
  try,
  substitute the value under the entry key of the sys.path_importer_cache dictionary for finder.
  if finder is None,
  try,
  call the method imp.find_module with 2 arguments: module_name and list containing element entry, assign the result to file_, _,
  and _, respectively.   if file_ is true,
  close file_ file descriptor.
  return boolean True.
  if ImportError exception is caught,
  skip this loop iteration,
  otherwise if call to the method finder.find_module with an argument name evaluates to true,
<annotation_end_b>#<body_start>          self . id = Tok . num
 Tok . num += 1
 self . name = name
 self . regex = regex
 self . next = next
     def literals ( choices , prefix = "" , suffix = "" ) :
 return "|" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
    class Lexer ( object ) :
  def __init__ ( self , states , first ) :
          self . regexes = { }
 self . toks = { }
  for state , rules in states . items ( ) :
              parts = [ ]
 for tok in rules :
                  groupid = "t%d" % tok . id
 self . toks [ groupid ] = tok
 parts . append ( "(?P<%s>%s)" % ( groupid , tok . regex ) )
  self . regexes [ state ] = re . compile ( "|" . join ( parts ) , re . MULTILINE | re . VERBOSE )
   self . state = first
   def lex ( self , text ) :
 end = len ( text )
 state = self . state
 regexes = self . regexes
 toks = self . toks
 start = 0
  while start < end :
              for match in regexes [ state ] . finditer ( text , start ) :
                  name = match . lastgroup
 tok = toks [ name ]
 toktext = match . group ( name )
 start += len ( toktext )
 yield ( tok . name , toktext )
  if tok . next :
                      state = tok . next
 break
     self . state = state
     class JsLexer ( Lexer ) :
               both_before = [  Tok ( "comment" , r"/\*(.|\n)*?\*/" ) ,  Tok ( "linecomment" , r"//.*?$" ) ,  Tok ( "ws" , r"\s+" ) ,  Tok ( "keyword" , literals ( """                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            """ , suffix = r"\b" ) , next = 'reg' ) ,  Tok ( "reserved" , literals ( "null true false" , suffix = r"\b" ) , next = 'div' ) ,  Tok ( "id" , r"""                   ([a-zA-Z_$   ]|\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*  # rest chars                   """ , next = 'div' ) ,  Tok ( "hnum" , r"0[xX][0-9a-fA-F]+" , next = 'div' ) ,  Tok ( "onum" , r"0[0-7]+" ) ,  Tok ( "dnum" , r"""                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     """ , next = 'div' ) ,  Tok ( "punct" , literals ( """                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          """ ) , next = "reg" ) ,  Tok ( "punct" , literals ( "++ -- ) ]" ) , next = 'div' ) ,  Tok ( "punct" , literals ( "{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =" ) , next = 'reg' ) ,  Tok ( "string" , r'"([^"\\]|(\\(.|\n)))*?"' , next = 'div' ) ,  Tok ( "string" , r"'([^'\\]|(\\(.|\n)))*?'" , next = 'div' ) ,  ]
  both_after = [  Tok ( "other" , r"." ) ,  ]
  states = {   'div' : both_before + [  Tok ( "punct" , literals ( "/= /" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( "regex" ,  r"""                     /                       # opening slash                     # First character is..                     (   [^*\\/[]            # anything but * \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )                     # Following characters are same, except for excluding a star                     (   [^\\/[]             # anything but \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 """ , next = 'div' ) ,  ] + both_after ,  }
  def __init__ ( self ) :
          super ( JsLexer , self ) . __init__ ( self . states , 'reg' )
     def prepare_js_for_gettext ( js ) :
 def escape_quotes ( m ) :
 s = m . group ( 0 )
 if s == '"' :
              return r'\"'
  else :
              return s
    lexer = JsLexer ( )
 c = [ ]
 for name , tok in lexer . lex ( js ) :
          if name == 'regex' :
                tok = '"REGEX"'
  elif name == 'string' :
                if tok . startswith ( "'" ) :
                  guts = re . sub ( r"\\.|." , escape_quotes , tok [ 1 : - 1 ] )
 tok = '"' + guts + '"'
   elif name == 'id' :
                 tok = tok . replace ( "\\" , "U" )
  c . append ( tok )
  return '' . join ( c )
import logging
 import sys
 import warnings
  from django . conf import settings
 from django . core import mail
 from django . core . mail import get_connection
 from django . utils . deprecation import RemovedInNextVersionWarning
 from django . utils . module_loading import import_string
 from django . views . debug import ExceptionReporter , get_exception_reporter_filter
   from logging import NullHandler
 from logging . config import dictConfig
  getLogger = logging . getLogger
     DEFAULT_LOGGING = {  'version' : 1 ,  'disable_existing_loggers' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }
   def configure_logging ( logging_config , logging_settings ) :
      if not sys . warnoptions :
           logging . captureWarnings ( True )
   warnings . simplefilter ( "default" , RemovedInNextVersionWarning )
   if logging_config :
           logging_config_func = import_string ( logging_config )
  logging_config_func ( DEFAULT_LOGGING )
   if logging_settings :
              logging_config_func ( logging_settings )
      class AdminEmailHandler ( logging . Handler ) :
  def __init__ ( self , include_html = False , email_backend = None ) :
          logging . Handler . __init__ ( self )
 self . include_html = include_html
 self . email_backend = email_backend
   def emit ( self , record ) :
          try :
              request = record . request
 subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
 filter = get_exception_reporter_filter ( request )
 request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
  except Exception :
              subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
 request = None
 request_repr = "unavailable"
  subject = self . format_subject ( subject )
  if record . exc_info :
              exc_info = record . exc_info
  else :
              exc_info = ( None , record . getMessage ( ) , None )
   message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
 reporter = ExceptionReporter ( request , is_email = True , * exc_info )
 html_message = reporter . get_traceback_html ( ) if self . include_html else None
 mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
   def connection ( self ) :
          return get_connection ( backend = self . email_backend , fail_silently = True )
   def format_subject ( self , subject ) :
 formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
 return formatted_subject [ : 989 ]
     class CallbackFilter ( logging . Filter ) :
 def __init__ ( self , callback ) :
          self . callback = callback
   def filter ( self , record ) :
          if self . callback ( record ) :
              return 1
  return 0
     class RequireDebugFalse ( logging . Filter ) :
      def filter ( self , record ) :
          return not settings . DEBUG
     class RequireDebugTrue ( logging . Filter ) :
      def filter ( self , record ) :
          return settings . DEBUG
try :
      from functools import lru_cache
   except ImportError :
           from collections import namedtuple
 from functools import update_wrapper
 from threading import RLock
  _CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
  class _HashedSeq ( list ) :
          __slots__ = 'hashvalue'
  def __init__ ( self , tup , hash = hash ) :
              self [ : ] = tup
 self . hashvalue = hash ( tup )
   def __hash__ ( self ) :
              return self . hashvalue
    def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
 key = args
 if kwds :
              sorted_items = sorted ( kwds . items ( ) )
 key += kwd_mark
 for item in sorted_items :
                  key += item
   if typed :
              key += tuple ( type ( v ) for v in args )
 if kwds :
                  key += tuple ( type ( v ) for k , v in sorted_items )
   elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
              return key [ 0 ]
  return _HashedSeq ( key )
   def lru_cache ( maxsize = 100 , typed = False ) :
       def decorating_function ( user_function ) :
               cache = dict ( )
 stats = [ 0 , 0 ]
 HITS , MISSES = 0 , 1
 make_key = _make_key
 cache_get = cache . get
 _len = len
 lock = RLock ( )
 root = [ ]
 root [ : ] = [ root , root , None , None ]
 nonlocal_root = [ root ]
 PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
  if maxsize == 0 :
                   def wrapper ( * args , ** kwds ) :
                       result = user_function ( * args , ** kwds )
 stats [ MISSES ] += 1
 return result
    elif maxsize is None :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed )
 result = cache_get ( key , root )
 if result is not root :
                          stats [ HITS ] += 1
 return result
  result = user_function ( * args , ** kwds )
 cache [ key ] = result
 stats [ MISSES ] += 1
 return result
    else :
                   def wrapper ( * args , ** kwds ) :
                       key = make_key ( args , kwds , typed ) if kwds or typed else args
 with lock :
                          link = cache_get ( key )
 if link is not None :
                               root , = nonlocal_root
 link_prev , link_next , key , result = link
 link_prev [ NEXT ] = link_next
 link_next [ PREV ] = link_prev
 last = root [ PREV ]
 last [ NEXT ] = root [ PREV ] = link
 link [ PREV ] = last
 link [ NEXT ] = root
 stats [ HITS ] += 1
 return result
   result = user_function ( * args , ** kwds )
 with lock :
                          root , = nonlocal_root
 if key in cache :
                                  pass
  elif _len ( cache ) >= maxsize :
                               oldroot = root
 oldroot [ KEY ] = key
 oldroot [ RESULT ] = result
  root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
 oldkey = root [ KEY ]
 oldvalue = root [ RESULT ]
 root [ KEY ] = root [ RESULT ] = None
  del cache [ oldkey ]
 cache [ key ] = oldroot
  else :
                               last = root [ PREV ]
 link = [ last , root , key , result ]
 last [ NEXT ] = root [ PREV ] = cache [ key ] = link
  stats [ MISSES ] += 1
  return result
    def cache_info ( ) :
 with lock :
                      return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
    def cache_clear ( ) :
 with lock :
                      cache . clear ( )
 root = nonlocal_root [ 0 ]
 root [ : ] = [ root , root , None , None ]
 stats [ : ] = [ 0 , 0 ]
    wrapper . __wrapped__ = user_function
 wrapper . cache_info = cache_info
 wrapper . cache_clear = cache_clear
 return update_wrapper ( wrapper , user_function )
   return decorating_function
from __future__ import absolute_import
  import copy
 from importlib import import_module
 import os
 import sys
 import warnings
  from django . core . exceptions import ImproperlyConfigured
 from django . utils import six
 from django . utils . deprecation import RemovedInDjango19Warning
   def import_string ( dotted_path ) :
 try :
          module_path , class_name = dotted_path . rsplit ( '.' , 1 )
  except ValueError :
          msg = "%s doesn't look like a module path" % dotted_path
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
   module = import_module ( module_path )
  try :
          return getattr ( module , class_name )
  except AttributeError :
          msg = 'Module "%s" does not define a "%s" attribute/class' % (  dotted_path , class_name )
 six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
     def import_by_path ( dotted_path , error_prefix = '' ) :
 warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
 try :
          attr = import_string ( dotted_path )
  except ImportError as e :
          msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
 six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
  return attr
    def autodiscover_modules ( * args , ** kwargs ) :
 from django . apps import apps
  register_to = kwargs . get ( 'register_to' )
 for app_config in apps . get_app_configs ( ) :
           try :
              if register_to :
                  before_import_registry = copy . copy ( register_to . _registry )
   for module_to_search in args :
                  import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
   except :
                  if register_to :
                  register_to . _registry = before_import_registry
      if module_has_submodule ( app_config . module , module_to_search ) :
                  raise
       if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
      if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
          from importlib . util import find_spec as importlib_find
  else :
          from importlib import find_loader as importlib_find
   def module_has_submodule ( package , module_name ) :
 try :
              package_name = package . __name__
 package_path = package . __path__
  except AttributeError :
               return False
   full_module_name = package_name + '.' + module_name
 return importlib_find ( full_module_name , package_path ) is not None
    else :
      import imp
  def module_has_submodule ( package , module_name ) :
 name = "." . join ( [ package . __name__ , module_name ] )
 try :
               return sys . modules [ name ] is not None
  except KeyError :
              pass
  try :
              package_path = package . __path__
  except AttributeError :
                return False
  for finder in sys . meta_path :
              if finder . find_module ( name , package_path ) :
                  return True
   for entry in package_path :
              try :
                   finder = sys . path_importer_cache [ entry ]
 if finder is None :
                       try :
                          file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
 if file_ :
                              file_ . close ( )
  return True
  except ImportError :
                          continue
    elif finder . find_module ( name ) :
<body_end><annotation_start_b>  if settings.USE_L10N is true, substitute settings.USE_THOUSAND_SEPARATOR for use_grouping,
  otherwise substitute settings.USE_L10N for use_grouping.   if use_grouping is true substitute it for use_grouping, otherwise substitute force_grouping for use_grouping.
  if use_grouping is true and grouping is greater than integer 0, use_grouping is boolean True, otherwise it is boolean False.
  if number is an integer and use_grouping is false and decimal_pos is false,
<annotation_end_b>#<body_start> use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR
 use_grouping = use_grouping or force_grouping
 use_grouping = use_grouping and grouping > 0
  if isinstance ( number , int ) and not use_grouping and not decimal_pos :
<body_end><annotation_start_b>  result is an empty list.
  non_capturing_groups is an empty list.
  consume_next is boolean True.
  call the function next_char with an argument iterator pattern, substitute the result for pattern_iter.
  num_args is an integer 0.
  try,
  get the next element of the iterable pattern_iter, assign the result for ch and escaped, respectively.
  if StopIteration exception,
<annotation_end_b>#<body_start>    result = [ ]
 non_capturing_groups = [ ]
 consume_next = True
 pattern_iter = next_char ( iter ( pattern ) )
 num_args = 0
     try :
          ch , escaped = next ( pattern_iter )
  except StopIteration :
<body_end><annotation_start_b>  if ch equal a string '(',
  nesting is integer 1.
  if not,
  nesting is integer 0.
  for every ch and escaped in input_iter,
  if escaped is true,
  skip this loop iteration.
  otherwise if ch equals a string '(',
  increment nesting by one.
  otherwise if ch equals a string ')',
  if nesting is false,
<annotation_end_b>#<body_start> if ch == '(' :
          nesting = 1
  else :
          nesting = 0
  for ch , escaped in input_iter :
          if escaped :
              continue
  elif ch == '(' :
              nesting += 1
  elif ch == ')' :
              if not nesting :
<body_end><annotation_start_b>  if ch is contained in string '*?+',
  try,
  get the next element of the iterable pattern_iter, assign the result for ch2 and escaped, respectively.
  if StopIteration exception,
  ch2 is None.
  if ch2 equals string '?',
  ch2 is None.
  if ch equals string '+',
<annotation_end_b>#<body_start> if ch in '*?+' :
          try :
              ch2 , escaped = next ( input_iter )
  except StopIteration :
              ch2 = None
  if ch2 == '?' :
              ch2 = None
  if ch == '+' :
<body_end><annotation_start_b>  for every ch in input_iter,
  if ch is not equal to string '\\'.
  yield ch and boolean False.
  skip this loop iteration.
  get the next element of the iterable pattern_iter, assign the result for ch.
  get the value under ch key of the ESCAPE_MAPPINGS dictionary, if it exists substitute it for representative, if not substitute ch for representative.
  if representative is None,
  skip this loop iteration.
  yield representative and boolean True.
  define the function walk_to_end with 2 arguments ch and input_iter.
  if ch equal a string '(',
  nesting is integer 1.
  if not,
  nesting is integer 0.
  for every ch and escaped in input_iter,
  if escaped is true,
  skip this loop iteration.
  otherwise if ch equals a string '(',
  increment nesting by one.
  otherwise if ch equals a string ')',
  if nesting is false,
  return nothing.
  decrement nesting by one.
  define the function get_quantifier with 2 arguments ch and input_iter.
  if ch is contained in string '*?+',
  try,
  get the next element of the iterable pattern_iter, assign the result for ch2 and escaped, respectively.
  if StopIteration exception,
  ch2 is None.
  if ch2 equals string '?',
  ch2 is None.
  if ch equals string '+',
  return integer 1 and ch2.
<annotation_end_b>#<body_start> for ch in input_iter :
          if ch != '\\' :
              yield ch , False
 continue
  ch = next ( input_iter )
 representative = ESCAPE_MAPPINGS . get ( ch , ch )
 if representative is None :
              continue
  yield representative , True
     def walk_to_end ( ch , input_iter ) :
 if ch == '(' :
          nesting = 1
  else :
          nesting = 0
  for ch , escaped in input_iter :
          if escaped :
              continue
  elif ch == '(' :
              nesting += 1
  elif ch == ')' :
              if not nesting :
                  return
  nesting -= 1
      def get_quantifier ( ch , input_iter ) :
 if ch in '*?+' :
          try :
              ch2 , escaped = next ( input_iter )
  except StopIteration :
              ch2 = None
  if ch2 == '?' :
              ch2 = None
  if ch == '+' :
              return 1 , ch2
<body_end><annotation_start_b>  if source is an instance of inst class,
<annotation_end_b>#<body_start> if isinstance ( source , inst ) :
<body_end><annotation_start_b>  if source is None,
<annotation_end_b>#<body_start> if source is None :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  call the __add__ method with an arguments rhs from the base class of the class SafeBytes, substitute the result for t.
  if rhs is an instance of SafeText,
<annotation_end_b>#<body_start> t = super ( SafeBytes , self ) . __add__ ( rhs )
 if isinstance ( rhs , SafeText ) :
<body_end><annotation_start_b>  remove kwargs dictionary element under the 'method' key, substitute it for method.
  call the function method with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, substitute the result for data.
  if data is an instance of bytes,
<annotation_end_b>#<body_start> method = kwargs . pop ( 'method' )
 data = method ( self , * args , ** kwargs )
 if isinstance ( data , bytes ) :
<body_end><annotation_start_b>  call the __add__ method with an arguments rhs from the base class of the class SafeText, substitute the result for t.
  if rhs is an instance of SafeData.
<annotation_end_b>#<body_start> t = super ( SafeText , self ) . __add__ ( rhs )
 if isinstance ( rhs , SafeData ) :
<body_end><annotation_start_b>  remove kwargs dictionary element under the 'method' key, substitute it for method.
  call the function method with 3 arguments: self, unpacked list args and unpacked dictionary kwargs, substitute the result for data.
  if data is an instance of bytes.
<annotation_end_b>#<body_start> method = kwargs . pop ( 'method' )
 data = method ( self , * args , ** kwargs )
 if isinstance ( data , bytes ) :
<body_end><annotation_start_b>  if s is an instance of SafeData.
<annotation_end_b>#<body_start> if isinstance ( s , SafeData ) :
<body_end><annotation_start_b>  if s is an instance of SafeData or EscapeData,
<annotation_end_b>#<body_start> if isinstance ( s , ( SafeData , EscapeData ) ) :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  call the function __import__ with an argument name.
<annotation_end_b>#<body_start> __import__ ( name )
<body_end><annotation_start_b>  try,
  call the method self._resolve, substitute the result for result.
  if ImportError exception is caught,
  raise an AttributeError with an argument string "%s could not be imported ", formated with self.name.
  set self.name attribute of the obj object to result.
  delete self.name attribute from the obj.__class__ object.
<annotation_end_b>#<body_start>          try :
              result = self . _resolve ( )
  except ImportError :
               raise AttributeError ( "%s could not be imported " % self . name )
  setattr ( obj , self . name , result )
  delattr ( obj . __class__ , self . name )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if attr equals any of the strings "__file__", "__name__" or "__path__" and self.mod is not contained in sys.modules,
  raise an AttributeError with an argument attr.
  try,
  call the method self._resolve, substitute the result for _module.
  if ImportError exception is caught,
  raise an AttributeError with an argument attr.
  get attr attribute from the _module object, substitute it for value.
  set attr attribute of the self object to value.
<annotation_end_b>#<body_start>                   if ( attr in ( "__file__" , "__name__" , "__path__" ) and  self . mod not in sys . modules ) :
              raise AttributeError ( attr )
  try :
              _module = self . _resolve ( )
  except ImportError :
              raise AttributeError ( attr )
  value = getattr ( _module , attr )
 setattr ( self , attr , value )
<body_end><annotation_start_b>  attrs is a list with 2 elements: strings "__doc__" and "__name__".
  append attr.name to attrs for every attr in self._moved_attributes.
<annotation_end_b>#<body_start>          attrs = [ "__doc__" , "__name__" ]
 attrs += [ attr . name for attr in self . _moved_attributes ]
<body_end><annotation_start_b>  call the function _import_module with an argument self.mod, substitute the result for module.
<annotation_end_b>#<body_start>          module = _import_module ( self . mod )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
<annotation_end_b>#<body_start> fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
<body_end><annotation_start_b>  if this_bases is None,
<annotation_end_b>#<body_start>              if this_bases is None :
<body_end><annotation_start_b>  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
<annotation_end_b>#<body_start>       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
<body_end><annotation_start_b>  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
<annotation_end_b>#<body_start>              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
<body_end><annotation_start_b>  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
<annotation_end_b>#<body_start>          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
<body_end><annotation_start_b>  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
<annotation_end_b>#<body_start> def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
<annotation_end_b>#<body_start> code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
<body_end><annotation_start_b>  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
<annotation_end_b>#<body_start>          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if config_string is false,
<annotation_end_b>#<body_start> if not config_string :
<body_end><annotation_start_b>   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
<annotation_end_b>#<body_start>          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
<body_end><annotation_start_b>  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
<annotation_end_b>#<body_start>          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
<body_end><annotation_start_b>  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
<annotation_end_b>#<body_start>          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
<body_end><annotation_start_b>  if truncate is None,
<annotation_end_b>#<body_start>          if truncate is None :
<body_end><annotation_start_b>  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
<annotation_end_b>#<body_start>          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
<body_end><annotation_start_b>  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
<annotation_end_b>#<body_start> text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
<body_end><annotation_start_b>  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
<annotation_end_b>#<body_start>          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
<body_end><annotation_start_b>  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
<annotation_end_b>#<body_start> length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
<body_end><annotation_start_b>  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
<annotation_end_b>#<body_start>          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
<body_end><annotation_start_b>  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
<annotation_end_b>#<body_start> s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
<body_end><annotation_start_b>  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
<annotation_end_b>#<body_start>          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
<body_end><annotation_start_b>  convert num to an integer, substitute the result for length.
  if html is true,
<annotation_end_b>#<body_start> length = int ( num )
 if html :
<body_end><annotation_start_b>  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
<annotation_end_b>#<body_start>          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
<body_end><annotation_start_b>  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
<annotation_end_b>#<body_start> words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
<body_end><annotation_start_b>  get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
  if print_ is None,
  define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
  return nothing.
  define the function write with an argument data.
  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
  return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
  define the function add_metaclass with an argument metaclass.
  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
  return wrapper.
  if PY3 is true,
  _assertCountEqual is a strnig "assertCountEqual".
   _assertRaisesRegex is a strnig "assertRaisesRegex".
  _assertRegex is a strnig "assertRegex".
  substitute memoryview for memoryview.
  buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
  if not,
  _assertCountEqual is a strnig "assertItemsEqual".
  _assertRaisesRegex is a strnig "assertRaisesRegexp".
  _assertRegex is a strnig "assertRegexpMatches".
  if sys.platform starts with a string 'java',
  substitute memoryview for memoryview.
  if not,
  substitute buffer for memoryview.
  buffer_types is a tuple with 2 elements bytearray and memoryview.
  define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
  use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
  import module contextlib.
  try,
  import threading.
  except ImportError.
  import dummy_threading as threading.
  derive the class RWLock from the object base class.
  define the method __init__ with an argument self.
  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
  call the method self._text_words with 2 arguments length and truncate, return the result.
  call the function allow_lazy with an argument words, substitute the result for words.
  define the method _text_words with 3 arguments: self, length and truncate.
  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
  call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
<annotation_end_b>#<body_start>    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
<body_end><annotation_start_b>  if words is not empty and length is smaller than or equal to integer 0,
<annotation_end_b>#<body_start> if words and length <= 0 :
<body_end><annotation_start_b>  if _globs_ is None,
  call the method sys._getframe with an argument 1, substitute the result for frame.
  substitute frame.f_globals for _globs_.
  if _locs_ is None,
  substitute if _locs_ is None for _locs_.
  delete frame.
  otherwise if _locs_ is None,
  substitute _globs_ with an argument _locs_.
  execute code statement """exec _code_ in _globs_, _locs_""".
  call the function exec_ with an argument string """def reraise(tp, value, tb=None):    raise tp, value, tb""".
  get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
  if print_ is None,
  define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
  return nothing.
  define the function write with an argument data.
  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
  return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
  define the function add_metaclass with an argument metaclass.
  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
  return wrapper.
  if PY3 is true,
  _assertCountEqual is a strnig "assertCountEqual".
   _assertRaisesRegex is a strnig "assertRaisesRegex".
  _assertRegex is a strnig "assertRegex".
  substitute memoryview for memoryview.
  buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
  if not,
  _assertCountEqual is a strnig "assertItemsEqual".
  _assertRaisesRegex is a strnig "assertRaisesRegexp".
  _assertRegex is a strnig "assertRegexpMatches".
  if sys.platform starts with a string 'java',
  substitute memoryview for memoryview.
  if not,
  substitute buffer for memoryview.
  buffer_types is a tuple with 2 elements bytearray and memoryview.
  define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
  use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
  import module contextlib.
  try,
  import threading.
  except ImportError.
  import dummy_threading as threading.
  derive the class RWLock from the object base class.
  define the method __init__ with an argument self.
  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
  call the method self._text_words with 2 arguments length and truncate, return the result.
  call the function allow_lazy with an argument words, substitute the result for words.
  define the method _text_words with 3 arguments: self, length and truncate.
  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
  call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
  and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
  define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
  if words is not empty and length is smaller than or equal to integer 0,
  return an empty string.
  html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
  pos is equal to integer 0.
  end_text_pos is equal to integer 0.
  current_len is equal to integer 0.
  open_tags is an empty list.
  if words is true, substitute re_words for regex, if not substitute re_chars for regex.
  while current_len is smaller than or equal to length,
  call the method regex.search with 2 arguments: text and pos.
  if m is false,
  break from the loop execution,
  call the method m.end with an argument integer 0, substitute the result for pos.
  call the function m.group, if the result evaluates to true,
  increment current_len by integer 1,
  if current_len equals truncate_len,
  substitute pos for end_text_pos.
  skip this loop iteration.
  call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
  substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
  skip this loop iteration.
  call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
  convert tagname to lowercase, substitute it for tagname.
  if self_closing is true or tagname is contained in html4_singlets,
  do nothing.
  otherwise if closing_tag is true,
  try,
  get the index of the first occurrence of tagname, substitute it for i.
  if ValueError exception is caught,
  do nothing.
  if not,
  create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
  if not,
  insert tagname at the beginning of open_tags.
  if current_len is smaller than or equal to length,
<annotation_end_b>#<body_start> if _globs_ is None :
              frame = sys . _getframe ( 1 )
 _globs_ = frame . f_globals
 if _locs_ is None :
                  _locs_ = frame . f_locals
  del frame
  elif _locs_ is None :
              _locs_ = _globs_
  exec ( """exec _code_ in _globs_, _locs_""" )
    exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
  return ' ' . join ( words )
   def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
 if words and length <= 0 :
              return ''
   html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
   pos = 0
 end_text_pos = 0
 current_len = 0
 open_tags = [ ]
  regex = re_words if words else re_chars
  while current_len <= length :
              m = regex . search ( text , pos )
 if not m :
                   break
  pos = m . end ( 0 )
 if m . group ( 1 ) :
                   current_len += 1
 if current_len == truncate_len :
                      end_text_pos = pos
  continue
   tag = re_tag . match ( m . group ( 0 ) )
 if not tag or current_len >= truncate_len :
                   continue
  closing_tag , tagname , self_closing = tag . groups ( )
  tagname = tagname . lower ( )
 if self_closing or tagname in html4_singlets :
                  pass
  elif closing_tag :
                   try :
                      i = open_tags . index ( tagname )
  except ValueError :
                      pass
  else :
                        open_tags = open_tags [ i + 1 : ]
   else :
                   open_tags . insert ( 0 , tagname )
    if current_len <= length :
<body_end><annotation_start_b>  if value.__traceback__ is not tb,
  raise an value.with_traceback exception with an argument tb.
  raise an exception value.
  if not,
  define the function exec with 3 arguments: _code_, _globs_ set to None and _locs_ set to None.
  if _globs_ is None,
  call the method sys._getframe with an argument 1, substitute the result for frame.
  substitute frame.f_globals for _globs_.
  if _locs_ is None,
  substitute if _locs_ is None for _locs_.
  delete frame.
  otherwise if _locs_ is None,
  substitute _globs_ with an argument _locs_.
  execute code statement """exec _code_ in _globs_, _locs_""".
  call the function exec_ with an argument string """def reraise(tp, value, tb=None):    raise tp, value, tb""".
  get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
  if print_ is None,
  define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
  return nothing.
  define the function write with an argument data.
  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
  return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
  define the function add_metaclass with an argument metaclass.
  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
  return wrapper.
  if PY3 is true,
  _assertCountEqual is a strnig "assertCountEqual".
   _assertRaisesRegex is a strnig "assertRaisesRegex".
  _assertRegex is a strnig "assertRegex".
  substitute memoryview for memoryview.
  buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
  if not,
  _assertCountEqual is a strnig "assertItemsEqual".
  _assertRaisesRegex is a strnig "assertRaisesRegexp".
  _assertRegex is a strnig "assertRegexpMatches".
  if sys.platform starts with a string 'java',
  substitute memoryview for memoryview.
  if not,
  substitute buffer for memoryview.
  buffer_types is a tuple with 2 elements bytearray and memoryview.
  define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
  use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
  import module contextlib.
  try,
  import threading.
  except ImportError.
  import dummy_threading as threading.
  derive the class RWLock from the object base class.
  define the method __init__ with an argument self.
  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
  call the method self._text_words with 2 arguments length and truncate, return the result.
  call the function allow_lazy with an argument words, substitute the result for words.
  define the method _text_words with 3 arguments: self, length and truncate.
  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
  call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
  and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
  define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
  if words is not empty and length is smaller than or equal to integer 0,
  return an empty string.
  html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
  pos is equal to integer 0.
  end_text_pos is equal to integer 0.
  current_len is equal to integer 0.
  open_tags is an empty list.
  if words is true, substitute re_words for regex, if not substitute re_chars for regex.
  while current_len is smaller than or equal to length,
  call the method regex.search with 2 arguments: text and pos.
  if m is false,
  break from the loop execution,
  call the method m.end with an argument integer 0, substitute the result for pos.
  call the function m.group, if the result evaluates to true,
  increment current_len by integer 1,
  if current_len equals truncate_len,
  substitute pos for end_text_pos.
  skip this loop iteration.
  call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
  substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
  skip this loop iteration.
  call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
  convert tagname to lowercase, substitute it for tagname.
  if self_closing is true or tagname is contained in html4_singlets,
  do nothing.
  otherwise if closing_tag is true,
  try,
  get the index of the first occurrence of tagname, substitute it for i.
  if ValueError exception is caught,
  do nothing.
  if not,
  create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
  if not,
  insert tagname at the beginning of open_tags.
  if current_len is smaller than or equal to length,
  return text.
  create a list out of fist end_text_pos text elemnts, substitue it for out.
  call the method self.add_truncation_text with 2 arguments: an empty string and truncate, substitute it for truncate_text.
  if truncate_text is true,
  append truncate_text to out.
  for every tag in open_tags,
  replace '%s' in string '</%s>' with tag, append the result to out.
<annotation_end_b>#<body_start>          if value . __traceback__ is not tb :
              raise value . with_traceback ( tb )
  raise value
    else :
      def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
 if _globs_ is None :
              frame = sys . _getframe ( 1 )
 _globs_ = frame . f_globals
 if _locs_ is None :
                  _locs_ = frame . f_locals
  del frame
  elif _locs_ is None :
              _locs_ = _globs_
  exec ( """exec _code_ in _globs_, _locs_""" )
    exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
  return ' ' . join ( words )
   def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
 if words and length <= 0 :
              return ''
   html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
   pos = 0
 end_text_pos = 0
 current_len = 0
 open_tags = [ ]
  regex = re_words if words else re_chars
  while current_len <= length :
              m = regex . search ( text , pos )
 if not m :
                   break
  pos = m . end ( 0 )
 if m . group ( 1 ) :
                   current_len += 1
 if current_len == truncate_len :
                      end_text_pos = pos
  continue
   tag = re_tag . match ( m . group ( 0 ) )
 if not tag or current_len >= truncate_len :
                   continue
  closing_tag , tagname , self_closing = tag . groups ( )
  tagname = tagname . lower ( )
 if self_closing or tagname in html4_singlets :
                  pass
  elif closing_tag :
                   try :
                      i = open_tags . index ( tagname )
  except ValueError :
                      pass
  else :
                        open_tags = open_tags [ i + 1 : ]
   else :
                   open_tags . insert ( 0 , tagname )
    if current_len <= length :
              return text
  out = text [ : end_text_pos ]
 truncate_text = self . add_truncation_text ( '' , truncate )
 if truncate_text :
              out += truncate_text
   for tag in open_tags :
              out += '</%s>' % tag
<body_end><annotation_start_b>  call the function force_text with an argument s, strip the result of whitespaces from both ends,
<annotation_end_b>#<body_start> s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )
<body_end><annotation_start_b>  is length of list_ equals integer 0,
<annotation_end_b>#<body_start> if len ( list_ ) == 0 :
<body_end><annotation_start_b>  try,
  delete name attribute of the _MovedItems object.
  if AttributeError exception is caught,
  try,
  delete entry under the name key of the moves.__dict__ dictionary.
  if NameError exception is caught,
  raise an AttributeError with an argument string "no such move, %r", formated with a tuple with an element name.
  if PY3 is true,
  _meth_func is a string "__func__".
  _meth_self is a string "__self__".
  _func_closure is a string "__closure__".
  _func_code is a string "__code__".
  _func_defaults is a string "__defaults__".
  _func_globals is a string "__globals__".
  _iterkeys is a string "keys".
  _itervalues is a string "values".
  _iteritems is a string "items".
  _iterlists is a string "lists".
  if not,
  _meth_func is a string "im_func".
  _meth_self is a string "im_self".
  _func_closure is a string "func_closure".
  _func_code is a string "func_code".
  _func_defaults is a string "func_defaults".
  _func_globals is a string "func_globals".
  _iterkeys is a string "iterkeys".
  _iterkeys is a string "iterkeys".
  _iteritems is a string "iteritems".
  _iterlists is a string "iterlists".
  try,
  substitute next for advance_iterator.
  if NameError exception is caught,
  define the function advance_iterator with an argument it.
  return next element of the iterable it.
  substitute klass.__dict__ for next.
  try,
  substitute callable for callable.
  if NameError exception is caught,
  define the function callable with an argument obj.
  if "__call__" is contained in klass.__dict__ for any klass in __mro__ field of the obj class, return boolean True, otherwise return False.
  if PY3 is true,
  define the function get_unbound_function with an argument unbound.
  return unbound.
  substitute Iterator for create_bound_method.
  substitute object for Iterator.
  if not,
  define the function get_unbound_function with an argument unbound.
  return unbound.im_func.
  define the function create_bound_function with 2 arguments: func and obj.
  call the method types.MethodType with 3 arguments: func, obj and obj.__class__, return the result.
  derive the class Iterator from the base class object.
  define the method next with an argument self.
  call the function type with an argument self, on the result call the method __next__ with an argument self, return the result.
  substitute callable for callable.
  call the function _add_doc with 2 arguments: get_unbound_function and string """Get the function out of a possibly unbound function""".
  call the method operator.attrgetter with an argument _meth_func, substitute the result for get_method_function.
  call the method operator.attrgetter with an argument _meth_self, substitute the result for get_method_self.
  call the method operator.attrgetter with an argument _func_closure, substitute the result for get_method_closure.
  call the method operator.attrgetter with an argument _func_code, substitute the result for get_method_code.
  call the method operator.attrgetter with an argument _func_defaults, substitute the result for get_method_defaults.
  call the method operator.attrgetter with an argument _func_globals, substitute the result for get_method_globals.
  define the function iterkeys with 2 arguments: d and unpacked dictionary  kw.
  get _iterkeys attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function itervalues with 2 arguments: d and unpacked dictionary  kw.
  get _itervalues attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function iteritems with 2 arguments: d and unpacked dictionary  kw.
  get _iteritems attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function iterlists with 2 arguments: d and unpacked dictionary  kw.
  get _iterlists attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   if PY3 is true,
  define the function b with an argument s.
  call the method e.encode with an argument string "latin-1".
  define the function u with an argument s.
  return s.
  substitute chr for unichr.
  if second element of sys.version_info is smaller than or equal to integer 1,
  define the function int2byte with an argument i.
  call the function bytes with an argument tuple with an element i, return the result.
  if not,
  call the method operator.methodcaller with 3 arguments: string 'to_bytes', integer 1 and string 'big', substitute the result for int2byte.
  call te method operator.itemgetter with an argument integer 0, substitute the result for byte2int.
  substitute operator.getitem for indexbytes.
  substitute iter for iterbytes.
  import io.
  substitute io.StringIO for StringIO.
  substitute io.BytesIO for BytesIO.
  if not,
  define the function b with an argument s.
  return s.
  define the function u with an argument s.
  replace every occurrence of raw string '\\' in s with a raw string '\\\\', use the result and string "unicode_escape",
  as arguments for the call to the unicode function, return the result.  substitute unichr for unichr.
  substitute chr for int2byte.
  define the function byte2int with an argument bs.
  get the integer representation of the first element of bs, return it.
  define the function indexbytes with 2 arguments buf and i.
  get the integer representation of the i-th element of buf, return it.
  define the function iterbytes with an argument buf.
  convert byte to its integer representation, return all of the results for every byte in buf.
  import StringIO.
  assign StringIO.StringIO to StringIO and BytesIO.
  call the function _add_doc with 2 arguments: b and string """Byte literal""".
  call the function _add_doc with 2 arguments: u and string """Text literal""".
  if PY3 is true,
  get 'exec' attribute from the moves.builtins object, substitute it for exec_.
  define the function reraise with 3 arguments: tp, value and tb set to None.
  if value.__traceback__ is not tb,
  raise an value.with_traceback exception with an argument tb.
  raise an exception value.
  if not,
  define the function exec with 3 arguments: _code_, _globs_ set to None and _locs_ set to None.
  if _globs_ is None,
  call the method sys._getframe with an argument 1, substitute the result for frame.
  substitute frame.f_globals for _globs_.
  if _locs_ is None,
  substitute if _locs_ is None for _locs_.
  delete frame.
  otherwise if _locs_ is None,
  substitute _globs_ with an argument _locs_.
  execute code statement """exec _code_ in _globs_, _locs_""".
  call the function exec_ with an argument string """def reraise(tp, value, tb=None):    raise tp, value, tb""".
  get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
  if print_ is None,
  define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
  return nothing.
  define the function write with an argument data.
  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
  return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
  define the function add_metaclass with an argument metaclass.
  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
  return wrapper.
  if PY3 is true,
  _assertCountEqual is a strnig "assertCountEqual".
   _assertRaisesRegex is a strnig "assertRaisesRegex".
  _assertRegex is a strnig "assertRegex".
  substitute memoryview for memoryview.
  buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
  if not,
  _assertCountEqual is a strnig "assertItemsEqual".
  _assertRaisesRegex is a strnig "assertRaisesRegexp".
  _assertRegex is a strnig "assertRegexpMatches".
  if sys.platform starts with a string 'java',
  substitute memoryview for memoryview.
  if not,
  substitute buffer for memoryview.
  buffer_types is a tuple with 2 elements bytearray and memoryview.
  define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
  use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
  import module contextlib.
  try,
  import threading.
  except ImportError.
  import dummy_threading as threading.
  derive the class RWLock from the object base class.
  define the method __init__ with an argument self.
  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
  call the method self._text_words with 2 arguments length and truncate, return the result.
  call the function allow_lazy with an argument words, substitute the result for words.
  define the method _text_words with 3 arguments: self, length and truncate.
  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
  call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
  and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
  define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
  if words is not empty and length is smaller than or equal to integer 0,
  return an empty string.
  html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
  pos is equal to integer 0.
  end_text_pos is equal to integer 0.
  current_len is equal to integer 0.
  open_tags is an empty list.
  if words is true, substitute re_words for regex, if not substitute re_chars for regex.
  while current_len is smaller than or equal to length,
  call the method regex.search with 2 arguments: text and pos.
  if m is false,
  break from the loop execution,
  call the method m.end with an argument integer 0, substitute the result for pos.
  call the function m.group, if the result evaluates to true,
  increment current_len by integer 1,
  if current_len equals truncate_len,
  substitute pos for end_text_pos.
  skip this loop iteration.
  call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
  substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
  skip this loop iteration.
  call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
  convert tagname to lowercase, substitute it for tagname.
  if self_closing is true or tagname is contained in html4_singlets,
  do nothing.
  otherwise if closing_tag is true,
  try,
  get the index of the first occurrence of tagname, substitute it for i.
  if ValueError exception is caught,
  do nothing.
  if not,
  create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
  if not,
  insert tagname at the beginning of open_tags.
  if current_len is smaller than or equal to length,
  return text.
  create a list out of fist end_text_pos text elemnts, substitue it for out.
  call the method self.add_truncation_text with 2 arguments: an empty string and truncate, substitute it for truncate_text.
  if truncate_text is true,
  append truncate_text to out.
  for every tag in open_tags,
  replace '%s' in string '</%s>' with tag, append the result to out.
  return out.
  define the function get_valid_filename with an argument s.
  call the function force_text with an argument s, strip the result of whitespaces from both ends,
  replace every occurrence of whitespaces in the previous result for '_', substitute the result for s.   call the function re.sub with 3 arguments: raw string '(?u)[^-\w.]', an empty string and s, return the result.
  call the function allow_lazy with 2 arguments: get_valid_filename and six.text_type, substitute the result for get_valid_filename.
  define the function get_text_list with 2 arguments: list_ and last_word set to result of the function ugettext_lazy called with an argument string 'or'.
  is length of list_ equals integer 0,
  return an empty string.
  if length of list_ equals integer 1,
<annotation_end_b>#<body_start> try :
          delattr ( _MovedItems , name )
  except AttributeError :
          try :
              del moves . __dict__ [ name ]
  except KeyError :
              raise AttributeError ( "no such move, %r" % ( name , ) )
      if PY3 :
      _meth_func = "__func__"
 _meth_self = "__self__"
  _func_closure = "__closure__"
 _func_code = "__code__"
 _func_defaults = "__defaults__"
 _func_globals = "__globals__"
  _iterkeys = "keys"
 _itervalues = "values"
 _iteritems = "items"
 _iterlists = "lists"
  else :
      _meth_func = "im_func"
 _meth_self = "im_self"
  _func_closure = "func_closure"
 _func_code = "func_code"
 _func_defaults = "func_defaults"
 _func_globals = "func_globals"
  _iterkeys = "iterkeys"
 _itervalues = "itervalues"
 _iteritems = "iteritems"
 _iterlists = "iterlists"
    try :
      advance_iterator = next
  except NameError :
      def advance_iterator ( it ) :
          return it . next ( )
   next = advance_iterator
   try :
      callable = callable
  except NameError :
      def callable ( obj ) :
          return any ( "__call__" in klass . __dict__ for klass in type ( obj ) . __mro__ )
     if PY3 :
      def get_unbound_function ( unbound ) :
          return unbound
   create_bound_method = types . MethodType
  Iterator = object
  else :
      def get_unbound_function ( unbound ) :
          return unbound . im_func
   def create_bound_method ( func , obj ) :
          return types . MethodType ( func , obj , obj . __class__ )
   class Iterator ( object ) :
           def next ( self ) :
              return type ( self ) . __next__ ( self )
    callable = callable
  _add_doc ( get_unbound_function ,  """Get the function out of a possibly unbound function""" )
   get_method_function = operator . attrgetter ( _meth_func )
 get_method_self = operator . attrgetter ( _meth_self )
 get_function_closure = operator . attrgetter ( _func_closure )
 get_function_code = operator . attrgetter ( _func_code )
 get_function_defaults = operator . attrgetter ( _func_defaults )
 get_function_globals = operator . attrgetter ( _func_globals )
   def iterkeys ( d , ** kw ) :
 return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
   def itervalues ( d , ** kw ) :
 return iter ( getattr ( d , _itervalues ) ( ** kw ) )
   def iteritems ( d , ** kw ) :
 return iter ( getattr ( d , _iteritems ) ( ** kw ) )
   def iterlists ( d , ** kw ) :
 return iter ( getattr ( d , _iterlists ) ( ** kw ) )
    if PY3 :
      def b ( s ) :
          return s . encode ( "latin-1" )
  def u ( s ) :
          return s
  unichr = chr
 if sys . version_info [ 1 ] <= 1 :
          def int2byte ( i ) :
              return bytes ( ( i , ) )
   else :
           int2byte = operator . methodcaller ( "to_bytes" , 1 , "big" )
  byte2int = operator . itemgetter ( 0 )
 indexbytes = operator . getitem
 iterbytes = iter
 import io
 StringIO = io . StringIO
 BytesIO = io . BytesIO
  else :
      def b ( s ) :
          return s
   def u ( s ) :
          return unicode ( s . replace ( r'\\' , r'\\\\' ) , "unicode_escape" )
  unichr = unichr
 int2byte = chr
 def byte2int ( bs ) :
          return ord ( bs [ 0 ] )
  def indexbytes ( buf , i ) :
          return ord ( buf [ i ] )
  def iterbytes ( buf ) :
          return ( ord ( byte ) for byte in buf )
  import StringIO
 StringIO = BytesIO = StringIO . StringIO
  _add_doc ( b , """Byte literal""" )
 _add_doc ( u , """Text literal""" )
   if PY3 :
      exec_ = getattr ( moves . builtins , "exec" )
   def reraise ( tp , value , tb = None ) :
          if value . __traceback__ is not tb :
              raise value . with_traceback ( tb )
  raise value
    else :
      def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
 if _globs_ is None :
              frame = sys . _getframe ( 1 )
 _globs_ = frame . f_globals
 if _locs_ is None :
                  _locs_ = frame . f_locals
  del frame
  elif _locs_ is None :
              _locs_ = _globs_
  exec ( """exec _code_ in _globs_, _locs_""" )
    exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
  return ' ' . join ( words )
   def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
 if words and length <= 0 :
              return ''
   html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
   pos = 0
 end_text_pos = 0
 current_len = 0
 open_tags = [ ]
  regex = re_words if words else re_chars
  while current_len <= length :
              m = regex . search ( text , pos )
 if not m :
                   break
  pos = m . end ( 0 )
 if m . group ( 1 ) :
                   current_len += 1
 if current_len == truncate_len :
                      end_text_pos = pos
  continue
   tag = re_tag . match ( m . group ( 0 ) )
 if not tag or current_len >= truncate_len :
                   continue
  closing_tag , tagname , self_closing = tag . groups ( )
  tagname = tagname . lower ( )
 if self_closing or tagname in html4_singlets :
                  pass
  elif closing_tag :
                   try :
                      i = open_tags . index ( tagname )
  except ValueError :
                      pass
  else :
                        open_tags = open_tags [ i + 1 : ]
   else :
                   open_tags . insert ( 0 , tagname )
    if current_len <= length :
              return text
  out = text [ : end_text_pos ]
 truncate_text = self . add_truncation_text ( '' , truncate )
 if truncate_text :
              out += truncate_text
   for tag in open_tags :
              out += '</%s>' % tag
   return out
     def get_valid_filename ( s ) :
 s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )
 return re . sub ( r'(?u)[^-\w.]' , '' , s )
  get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
   def get_text_list ( list_ , last_word = ugettext_lazy ( 'or' ) ) :
 if len ( list_ ) == 0 :
          return ''
  if len ( list_ ) == 1 :
<body_end><annotation_start_b>  set move.name attribute of the _MovedItems to move.
  define the function remove_move with an argument name.
  try,
  delete name attribute of the _MovedItems object.
  if AttributeError exception is caught,
  try,
  delete entry under the name key of the moves.__dict__ dictionary.
  if NameError exception is caught,
  raise an AttributeError with an argument string "no such move, %r", formated with a tuple with an element name.
  if PY3 is true,
  _meth_func is a string "__func__".
  _meth_self is a string "__self__".
  _func_closure is a string "__closure__".
  _func_code is a string "__code__".
  _func_defaults is a string "__defaults__".
  _func_globals is a string "__globals__".
  _iterkeys is a string "keys".
  _itervalues is a string "values".
  _iteritems is a string "items".
  _iterlists is a string "lists".
  if not,
  _meth_func is a string "im_func".
  _meth_self is a string "im_self".
  _func_closure is a string "func_closure".
  _func_code is a string "func_code".
  _func_defaults is a string "func_defaults".
  _func_globals is a string "func_globals".
  _iterkeys is a string "iterkeys".
  _iterkeys is a string "iterkeys".
  _iteritems is a string "iteritems".
  _iterlists is a string "iterlists".
  try,
  substitute next for advance_iterator.
  if NameError exception is caught,
  define the function advance_iterator with an argument it.
  return next element of the iterable it.
  substitute klass.__dict__ for next.
  try,
  substitute callable for callable.
  if NameError exception is caught,
  define the function callable with an argument obj.
  if "__call__" is contained in klass.__dict__ for any klass in __mro__ field of the obj class, return boolean True, otherwise return False.
  if PY3 is true,
  define the function get_unbound_function with an argument unbound.
  return unbound.
  substitute Iterator for create_bound_method.
  substitute object for Iterator.
  if not,
  define the function get_unbound_function with an argument unbound.
  return unbound.im_func.
  define the function create_bound_function with 2 arguments: func and obj.
  call the method types.MethodType with 3 arguments: func, obj and obj.__class__, return the result.
  derive the class Iterator from the base class object.
  define the method next with an argument self.
  call the function type with an argument self, on the result call the method __next__ with an argument self, return the result.
  substitute callable for callable.
  call the function _add_doc with 2 arguments: get_unbound_function and string """Get the function out of a possibly unbound function""".
  call the method operator.attrgetter with an argument _meth_func, substitute the result for get_method_function.
  call the method operator.attrgetter with an argument _meth_self, substitute the result for get_method_self.
  call the method operator.attrgetter with an argument _func_closure, substitute the result for get_method_closure.
  call the method operator.attrgetter with an argument _func_code, substitute the result for get_method_code.
  call the method operator.attrgetter with an argument _func_defaults, substitute the result for get_method_defaults.
  call the method operator.attrgetter with an argument _func_globals, substitute the result for get_method_globals.
  define the function iterkeys with 2 arguments: d and unpacked dictionary  kw.
  get _iterkeys attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function itervalues with 2 arguments: d and unpacked dictionary  kw.
  get _itervalues attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function iteritems with 2 arguments: d and unpacked dictionary  kw.
  get _iteritems attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function iterlists with 2 arguments: d and unpacked dictionary  kw.
  get _iterlists attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   if PY3 is true,
  define the function b with an argument s.
  call the method e.encode with an argument string "latin-1".
  define the function u with an argument s.
  return s.
  substitute chr for unichr.
  if second element of sys.version_info is smaller than or equal to integer 1,
  define the function int2byte with an argument i.
  call the function bytes with an argument tuple with an element i, return the result.
  if not,
  call the method operator.methodcaller with 3 arguments: string 'to_bytes', integer 1 and string 'big', substitute the result for int2byte.
  call te method operator.itemgetter with an argument integer 0, substitute the result for byte2int.
  substitute operator.getitem for indexbytes.
  substitute iter for iterbytes.
  import io.
  substitute io.StringIO for StringIO.
  substitute io.BytesIO for BytesIO.
  if not,
  define the function b with an argument s.
  return s.
  define the function u with an argument s.
  replace every occurrence of raw string '\\' in s with a raw string '\\\\', use the result and string "unicode_escape",
  as arguments for the call to the unicode function, return the result.  substitute unichr for unichr.
  substitute chr for int2byte.
  define the function byte2int with an argument bs.
  get the integer representation of the first element of bs, return it.
  define the function indexbytes with 2 arguments buf and i.
  get the integer representation of the i-th element of buf, return it.
  define the function iterbytes with an argument buf.
  convert byte to its integer representation, return all of the results for every byte in buf.
  import StringIO.
  assign StringIO.StringIO to StringIO and BytesIO.
  call the function _add_doc with 2 arguments: b and string """Byte literal""".
  call the function _add_doc with 2 arguments: u and string """Text literal""".
  if PY3 is true,
  get 'exec' attribute from the moves.builtins object, substitute it for exec_.
  define the function reraise with 3 arguments: tp, value and tb set to None.
  if value.__traceback__ is not tb,
  raise an value.with_traceback exception with an argument tb.
  raise an exception value.
  if not,
  define the function exec with 3 arguments: _code_, _globs_ set to None and _locs_ set to None.
  if _globs_ is None,
  call the method sys._getframe with an argument 1, substitute the result for frame.
  substitute frame.f_globals for _globs_.
  if _locs_ is None,
  substitute if _locs_ is None for _locs_.
  delete frame.
  otherwise if _locs_ is None,
  substitute _globs_ with an argument _locs_.
  execute code statement """exec _code_ in _globs_, _locs_""".
  call the function exec_ with an argument string """def reraise(tp, value, tb=None):    raise tp, value, tb""".
  get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
  if print_ is None,
  define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
  return nothing.
  define the function write with an argument data.
  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
  return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
  define the function add_metaclass with an argument metaclass.
  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
  return wrapper.
  if PY3 is true,
  _assertCountEqual is a strnig "assertCountEqual".
   _assertRaisesRegex is a strnig "assertRaisesRegex".
  _assertRegex is a strnig "assertRegex".
  substitute memoryview for memoryview.
  buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
  if not,
  _assertCountEqual is a strnig "assertItemsEqual".
  _assertRaisesRegex is a strnig "assertRaisesRegexp".
  _assertRegex is a strnig "assertRegexpMatches".
  if sys.platform starts with a string 'java',
  substitute memoryview for memoryview.
  if not,
  substitute buffer for memoryview.
  buffer_types is a tuple with 2 elements bytearray and memoryview.
  define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
  use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
  import module contextlib.
  try,
  import threading.
  except ImportError.
  import dummy_threading as threading.
  derive the class RWLock from the object base class.
  define the method __init__ with an argument self.
  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
  call the method self._text_words with 2 arguments length and truncate, return the result.
  call the function allow_lazy with an argument words, substitute the result for words.
  define the method _text_words with 3 arguments: self, length and truncate.
  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
  call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
  and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
  define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
  if words is not empty and length is smaller than or equal to integer 0,
  return an empty string.
  html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
  pos is equal to integer 0.
  end_text_pos is equal to integer 0.
  current_len is equal to integer 0.
  open_tags is an empty list.
  if words is true, substitute re_words for regex, if not substitute re_chars for regex.
  while current_len is smaller than or equal to length,
  call the method regex.search with 2 arguments: text and pos.
  if m is false,
  break from the loop execution,
  call the method m.end with an argument integer 0, substitute the result for pos.
  call the function m.group, if the result evaluates to true,
  increment current_len by integer 1,
  if current_len equals truncate_len,
  substitute pos for end_text_pos.
  skip this loop iteration.
  call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
  substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
  skip this loop iteration.
  call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
  convert tagname to lowercase, substitute it for tagname.
  if self_closing is true or tagname is contained in html4_singlets,
  do nothing.
  otherwise if closing_tag is true,
  try,
  get the index of the first occurrence of tagname, substitute it for i.
  if ValueError exception is caught,
  do nothing.
  if not,
  create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
  if not,
  insert tagname at the beginning of open_tags.
  if current_len is smaller than or equal to length,
  return text.
  create a list out of fist end_text_pos text elemnts, substitue it for out.
  call the method self.add_truncation_text with 2 arguments: an empty string and truncate, substitute it for truncate_text.
  if truncate_text is true,
  append truncate_text to out.
  for every tag in open_tags,
  replace '%s' in string '</%s>' with tag, append the result to out.
  return out.
  define the function get_valid_filename with an argument s.
  call the function force_text with an argument s, strip the result of whitespaces from both ends,
  replace every occurrence of whitespaces in the previous result for '_', substitute the result for s.   call the function re.sub with 3 arguments: raw string '(?u)[^-\w.]', an empty string and s, return the result.
  call the function allow_lazy with 2 arguments: get_valid_filename and six.text_type, substitute the result for get_valid_filename.
  define the function get_text_list with 2 arguments: list_ and last_word set to result of the function ugettext_lazy called with an argument string 'or'.
  is length of list_ equals integer 0,
  return an empty string.
  if length of list_ equals integer 1,
  call the function force_text with first element of list_ as an argument, return the result.
<annotation_end_b>#<body_start> setattr ( _MovedItems , move . name , move )
    def remove_move ( name ) :
 try :
          delattr ( _MovedItems , name )
  except AttributeError :
          try :
              del moves . __dict__ [ name ]
  except KeyError :
              raise AttributeError ( "no such move, %r" % ( name , ) )
      if PY3 :
      _meth_func = "__func__"
 _meth_self = "__self__"
  _func_closure = "__closure__"
 _func_code = "__code__"
 _func_defaults = "__defaults__"
 _func_globals = "__globals__"
  _iterkeys = "keys"
 _itervalues = "values"
 _iteritems = "items"
 _iterlists = "lists"
  else :
      _meth_func = "im_func"
 _meth_self = "im_self"
  _func_closure = "func_closure"
 _func_code = "func_code"
 _func_defaults = "func_defaults"
 _func_globals = "func_globals"
  _iterkeys = "iterkeys"
 _itervalues = "itervalues"
 _iteritems = "iteritems"
 _iterlists = "iterlists"
    try :
      advance_iterator = next
  except NameError :
      def advance_iterator ( it ) :
          return it . next ( )
   next = advance_iterator
   try :
      callable = callable
  except NameError :
      def callable ( obj ) :
          return any ( "__call__" in klass . __dict__ for klass in type ( obj ) . __mro__ )
     if PY3 :
      def get_unbound_function ( unbound ) :
          return unbound
   create_bound_method = types . MethodType
  Iterator = object
  else :
      def get_unbound_function ( unbound ) :
          return unbound . im_func
   def create_bound_method ( func , obj ) :
          return types . MethodType ( func , obj , obj . __class__ )
   class Iterator ( object ) :
           def next ( self ) :
              return type ( self ) . __next__ ( self )
    callable = callable
  _add_doc ( get_unbound_function ,  """Get the function out of a possibly unbound function""" )
   get_method_function = operator . attrgetter ( _meth_func )
 get_method_self = operator . attrgetter ( _meth_self )
 get_function_closure = operator . attrgetter ( _func_closure )
 get_function_code = operator . attrgetter ( _func_code )
 get_function_defaults = operator . attrgetter ( _func_defaults )
 get_function_globals = operator . attrgetter ( _func_globals )
   def iterkeys ( d , ** kw ) :
 return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
   def itervalues ( d , ** kw ) :
 return iter ( getattr ( d , _itervalues ) ( ** kw ) )
   def iteritems ( d , ** kw ) :
 return iter ( getattr ( d , _iteritems ) ( ** kw ) )
   def iterlists ( d , ** kw ) :
 return iter ( getattr ( d , _iterlists ) ( ** kw ) )
    if PY3 :
      def b ( s ) :
          return s . encode ( "latin-1" )
  def u ( s ) :
          return s
  unichr = chr
 if sys . version_info [ 1 ] <= 1 :
          def int2byte ( i ) :
              return bytes ( ( i , ) )
   else :
           int2byte = operator . methodcaller ( "to_bytes" , 1 , "big" )
  byte2int = operator . itemgetter ( 0 )
 indexbytes = operator . getitem
 iterbytes = iter
 import io
 StringIO = io . StringIO
 BytesIO = io . BytesIO
  else :
      def b ( s ) :
          return s
   def u ( s ) :
          return unicode ( s . replace ( r'\\' , r'\\\\' ) , "unicode_escape" )
  unichr = unichr
 int2byte = chr
 def byte2int ( bs ) :
          return ord ( bs [ 0 ] )
  def indexbytes ( buf , i ) :
          return ord ( buf [ i ] )
  def iterbytes ( buf ) :
          return ( ord ( byte ) for byte in buf )
  import StringIO
 StringIO = BytesIO = StringIO . StringIO
  _add_doc ( b , """Byte literal""" )
 _add_doc ( u , """Text literal""" )
   if PY3 :
      exec_ = getattr ( moves . builtins , "exec" )
   def reraise ( tp , value , tb = None ) :
          if value . __traceback__ is not tb :
              raise value . with_traceback ( tb )
  raise value
    else :
      def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
 if _globs_ is None :
              frame = sys . _getframe ( 1 )
 _globs_ = frame . f_globals
 if _locs_ is None :
                  _locs_ = frame . f_locals
  del frame
  elif _locs_ is None :
              _locs_ = _globs_
  exec ( """exec _code_ in _globs_, _locs_""" )
    exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
  return ' ' . join ( words )
   def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
 if words and length <= 0 :
              return ''
   html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
   pos = 0
 end_text_pos = 0
 current_len = 0
 open_tags = [ ]
  regex = re_words if words else re_chars
  while current_len <= length :
              m = regex . search ( text , pos )
 if not m :
                   break
  pos = m . end ( 0 )
 if m . group ( 1 ) :
                   current_len += 1
 if current_len == truncate_len :
                      end_text_pos = pos
  continue
   tag = re_tag . match ( m . group ( 0 ) )
 if not tag or current_len >= truncate_len :
                   continue
  closing_tag , tagname , self_closing = tag . groups ( )
  tagname = tagname . lower ( )
 if self_closing or tagname in html4_singlets :
                  pass
  elif closing_tag :
                   try :
                      i = open_tags . index ( tagname )
  except ValueError :
                      pass
  else :
                        open_tags = open_tags [ i + 1 : ]
   else :
                   open_tags . insert ( 0 , tagname )
    if current_len <= length :
              return text
  out = text [ : end_text_pos ]
 truncate_text = self . add_truncation_text ( '' , truncate )
 if truncate_text :
              out += truncate_text
   for tag in open_tags :
              out += '</%s>' % tag
   return out
     def get_valid_filename ( s ) :
 s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )
 return re . sub ( r'(?u)[^-\w.]' , '' , s )
  get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
   def get_text_list ( list_ , last_word = ugettext_lazy ( 'or' ) ) :
 if len ( list_ ) == 0 :
          return ''
  if len ( list_ ) == 1 :
          return force_text ( list_ [ 0 ] )
<body_end><annotation_start_b>  call the function force_text with an argument text, substitute the result for text.
<annotation_end_b>#<body_start> text = force_text ( text )
<body_end><annotation_start_b>  char2number is an dictionary, with 26 elements: 2 for 'a', 2 for 'b', 2 for 'c', 3 for 'd', 3 for 'e', 3 for 'f', 4 for 'g',
<annotation_end_b>#<body_start> char2number = { 'a' : '2' , 'b' : '2' , 'c' : '2' , 'd' : '3' , 'e' : '3' , 'f' : '3' ,  'g' : '4' , 'h' : '4' , 'i' : '4' , 'j' : '5' , 'k' : '5' , 'l' : '5' , 'm' : '6' ,  'n' : '6' , 'o' : '6' , 'p' : '7' , 'q' : '7' , 'r' : '7' , 's' : '7' , 't' : '8' ,  'u' : '8' , 'v' : '8' , 'w' : '9' , 'x' : '9' , 'y' : '9' , 'z' : '9' }
<body_end><annotation_start_b>  zbuf is an instance of BytesIO class.
  zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
  and fileobj set to zbuf.   call the method zfile.write with an argument s.
  call the method zfile.close.
<annotation_end_b>#<body_start>      zbuf = BytesIO ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = zbuf )
 zfile . write ( s )
 zfile . close ( )
<body_end><annotation_start_b>  join elements of self.vals into a bytes string, substitute the result for ret.
  self.vals is an empty list.
<annotation_end_b>#<body_start>          ret = b'' . join ( self . vals )
 self . vals = [ ]
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  msg is an string "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.".
  call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
  define the function fix with an argument match.
  get the unicode representation of result of the method match.group called with an integer 1, format with in a string "\\u%04x",
  return the result.   if type of s equals bytes,
  call the method s.decode with an argument string 'utf-8', substitute the result for s.
  otherwise if, type of s doesnt equal to six.text_type,
  raise an TypeError with an argument s.
  replace every occurrence of '\\' in s with '\\\\'.
  replace every occurrence of '\r' in s with '\\r'.
  replace every occurrence of '\n' in s with '\\n'.
  replace every occurrence of '\t' in s with '\\t'.
  replace every occurrence of "'" in s with "\\'".
  replace every occurrence of '</' in s with '<\\/'.
  if quote_double_quotes is true,
  replace every occurrence of '"' in s with '&quot;'.
<annotation_end_b>#<body_start>      msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
 warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
  def fix ( match ) :
          return "\\u%04x" % ord ( match . group ( 1 ) )
   if type ( s ) == bytes :
          s = s . decode ( 'utf-8' )
  elif type ( s ) != six . text_type :
          raise TypeError ( s )
  s = s . replace ( '\\' , '\\\\' )
 s = s . replace ( '\r' , '\\r' )
 s = s . replace ( '\n' , '\\n' )
 s = s . replace ( '\t' , '\\t' )
 s = s . replace ( "'" , "\\'" )
 s = s . replace ( '</' , '<\\/' )
 if quote_double_quotes :
          s = s . replace ( '"' , '&quot;' )
<body_end><annotation_start_b>  call the method match.group with an argument integer 1, substitute the result for text.
  if first element of text equals '#',
  remove first element of text.
  try,
  if first element of text is contained in 'xX'.
  convert text without first element to hexadecimal integer, substitute it for c.
  if nor,
  convert text to an integer, substitute it for c.
<annotation_end_b>#<body_start>      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
<body_end><annotation_start_b>  call the function force_text with an argument text, substitute the result for text.
  call the method smart_split_re.finditer with an argument text, for every bit in result,
  call the method bit.group with an argument integer 0, yield the result.
  define the function _replace_entity with an argument match.
  call the method match.group with an argument integer 1, substitute the result for text.
  if first element of text equals '#',
  remove first element of text.
  try,
  if first element of text is contained in 'xX'.
  convert text without first element to hexadecimal integer, substitute it for c.
  if nor,
  convert text to an integer, substitute it for c.
  call the method six.unichr with an argument c, return the result.
  if ValueError exception is caught,
<annotation_end_b>#<body_start> text = force_text ( text )
 for bit in smart_split_re . finditer ( text ) :
          yield bit . group ( 0 )
     def _replace_entity ( match ) :
      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
  return six . unichr ( c )
  except ValueError :
<body_end><annotation_start_b>  buf is an instance of StreamingBuffer class.
  zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
  and fileobj set to buf.   read data from buf file stream, yield the result.
  for every item in sequence,
  write item to zfile stream.
  flush zfile stream buffer.
  read data from buf, yield the result.
  close zfile stream.
  read data from buf, yield the result.
  call the function re.compile with an argument string "([\u0080-\uffff])", substitute the result for ustring_re.
  define the function javascript_quote with 2 arguments: s and quote_double_quotes set to boolean False.
  msg is an string "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.".
  call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
  define the function fix with an argument match.
  get the unicode representation of result of the method match.group called with an integer 1, format with in a string "\\u%04x",
  return the result.   if type of s equals bytes,
  call the method s.decode with an argument string 'utf-8', substitute the result for s.
  otherwise if, type of s doesnt equal to six.text_type,
  raise an TypeError with an argument s.
  replace every occurrence of '\\' in s with '\\\\'.
  replace every occurrence of '\r' in s with '\\r'.
  replace every occurrence of '\n' in s with '\\n'.
  replace every occurrence of '\t' in s with '\\t'.
  replace every occurrence of "'" in s with "\\'".
  replace every occurrence of '</' in s with '<\\/'.
  if quote_double_quotes is true,
  replace every occurrence of '"' in s with '&quot;'.
  call the method ustring_re.sub with 2 arguments: fix and s, return the result.
  call the function allow_lazy with 2 arguments: javascript_quote and six.text_type, substitute the result for javascript_quote.
  call the function re.compile with 2 arguments: raw string "((?:[^\s'"]*(?:(?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')[^\s'"]*)+) | \+)",
  and re.VERBOSE, substitute the result for smart_split_re.   define the function smart_split with an argument text.
  call the function force_text with an argument text, substitute the result for text.
  call the method smart_split_re.finditer with an argument text, for every bit in result,
  call the method bit.group with an argument integer 0, yield the result.
  define the function _replace_entity with an argument match.
  call the method match.group with an argument integer 1, substitute the result for text.
  if first element of text equals '#',
  remove first element of text.
  try,
  if first element of text is contained in 'xX'.
  convert text without first element to hexadecimal integer, substitute it for c.
  if nor,
  convert text to an integer, substitute it for c.
  call the method six.unichr with an argument c, return the result.
  if ValueError exception is caught,
  call the method match.group with an argument integer 0, return the result.
  if not,
  try,
<annotation_end_b>#<body_start>      buf = StreamingBuffer ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )
  yield buf . read ( )
 for item in sequence :
          zfile . write ( item )
 zfile . flush ( )
 yield buf . read ( )
  zfile . close ( )
 yield buf . read ( )
   ustring_re = re . compile ( "([\u0080-\uffff])" )
   def javascript_quote ( s , quote_double_quotes = False ) :
      msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
 warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
  def fix ( match ) :
          return "\\u%04x" % ord ( match . group ( 1 ) )
   if type ( s ) == bytes :
          s = s . decode ( 'utf-8' )
  elif type ( s ) != six . text_type :
          raise TypeError ( s )
  s = s . replace ( '\\' , '\\\\' )
 s = s . replace ( '\r' , '\\r' )
 s = s . replace ( '\n' , '\\n' )
 s = s . replace ( '\t' , '\\t' )
 s = s . replace ( "'" , "\\'" )
 s = s . replace ( '</' , '<\\/' )
 if quote_double_quotes :
          s = s . replace ( '"' , '&quot;' )
  return ustring_re . sub ( fix , s )
  javascript_quote = allow_lazy ( javascript_quote , six . text_type )
    smart_split_re = re . compile ( r"""     ((?:         [^\s'"]*         (?:             (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) """ , re . VERBOSE )
   def smart_split ( text ) :
 text = force_text ( text )
 for bit in smart_split_re . finditer ( text ) :
          yield bit . group ( 0 )
     def _replace_entity ( match ) :
      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
  return six . unichr ( c )
  except ValueError :
              return match . group ( 0 )
   else :
          try :
<body_end><annotation_start_b>  append val to self.vals.
  define the method read with an argument self.
  join elements of self.vals into a bytes string, substitute the result for ret.
  self.vals is an empty list.
  return ret.
  define the method flush with an argument self.
  return nothing.
  define the method close with an argument self.
  return nothing.
  define the function compress_sequence with an argument sequence.
  buf is an instance of StreamingBuffer class.
  zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
  and fileobj set to buf.   read data from buf file stream, yield the result.
  for every item in sequence,
  write item to zfile stream.
  flush zfile stream buffer.
  read data from buf, yield the result.
  close zfile stream.
  read data from buf, yield the result.
  call the function re.compile with an argument string "([\u0080-\uffff])", substitute the result for ustring_re.
  define the function javascript_quote with 2 arguments: s and quote_double_quotes set to boolean False.
  msg is an string "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.".
  call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
  define the function fix with an argument match.
  get the unicode representation of result of the method match.group called with an integer 1, format with in a string "\\u%04x",
  return the result.   if type of s equals bytes,
  call the method s.decode with an argument string 'utf-8', substitute the result for s.
  otherwise if, type of s doesnt equal to six.text_type,
  raise an TypeError with an argument s.
  replace every occurrence of '\\' in s with '\\\\'.
  replace every occurrence of '\r' in s with '\\r'.
  replace every occurrence of '\n' in s with '\\n'.
  replace every occurrence of '\t' in s with '\\t'.
  replace every occurrence of "'" in s with "\\'".
  replace every occurrence of '</' in s with '<\\/'.
  if quote_double_quotes is true,
  replace every occurrence of '"' in s with '&quot;'.
  call the method ustring_re.sub with 2 arguments: fix and s, return the result.
  call the function allow_lazy with 2 arguments: javascript_quote and six.text_type, substitute the result for javascript_quote.
  call the function re.compile with 2 arguments: raw string "((?:[^\s'"]*(?:(?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')[^\s'"]*)+) | \+)",
  and re.VERBOSE, substitute the result for smart_split_re.   define the function smart_split with an argument text.
  call the function force_text with an argument text, substitute the result for text.
  call the method smart_split_re.finditer with an argument text, for every bit in result,
  call the method bit.group with an argument integer 0, yield the result.
  define the function _replace_entity with an argument match.
  call the method match.group with an argument integer 1, substitute the result for text.
  if first element of text equals '#',
  remove first element of text.
  try,
  if first element of text is contained in 'xX'.
  convert text without first element to hexadecimal integer, substitute it for c.
  if nor,
  convert text to an integer, substitute it for c.
  call the method six.unichr with an argument c, return the result.
  if ValueError exception is caught,
  call the method match.group with an argument integer 0, return the result.
  if not,
  try,
  call the function six.unichr with value under the text key of the html_entities.name2codepoint dictionary, return the result.
  if OverflowError or ValueError exceptions are caught,
<annotation_end_b>#<body_start>          self . vals . append ( val )
   def read ( self ) :
          ret = b'' . join ( self . vals )
 self . vals = [ ]
 return ret
   def flush ( self ) :
          return
   def close ( self ) :
          return
      def compress_sequence ( sequence ) :
      buf = StreamingBuffer ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )
  yield buf . read ( )
 for item in sequence :
          zfile . write ( item )
 zfile . flush ( )
 yield buf . read ( )
  zfile . close ( )
 yield buf . read ( )
   ustring_re = re . compile ( "([\u0080-\uffff])" )
   def javascript_quote ( s , quote_double_quotes = False ) :
      msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
 warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
  def fix ( match ) :
          return "\\u%04x" % ord ( match . group ( 1 ) )
   if type ( s ) == bytes :
          s = s . decode ( 'utf-8' )
  elif type ( s ) != six . text_type :
          raise TypeError ( s )
  s = s . replace ( '\\' , '\\\\' )
 s = s . replace ( '\r' , '\\r' )
 s = s . replace ( '\n' , '\\n' )
 s = s . replace ( '\t' , '\\t' )
 s = s . replace ( "'" , "\\'" )
 s = s . replace ( '</' , '<\\/' )
 if quote_double_quotes :
          s = s . replace ( '"' , '&quot;' )
  return ustring_re . sub ( fix , s )
  javascript_quote = allow_lazy ( javascript_quote , six . text_type )
    smart_split_re = re . compile ( r"""     ((?:         [^\s'"]*         (?:             (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) """ , re . VERBOSE )
   def smart_split ( text ) :
 text = force_text ( text )
 for bit in smart_split_re . finditer ( text ) :
          yield bit . group ( 0 )
     def _replace_entity ( match ) :
      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
  return six . unichr ( c )
  except ValueError :
              return match . group ( 0 )
   else :
          try :
              return six . unichr ( html_entities . name2codepoint [ text ] )
  except ( ValueError , KeyError ) :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if first element of s is not contained in "\"'" or last element of s is not equal to first element of s,
  raise an ValueError exception wit an argument string "Not a string literal: %r", where "%r" is replaced with s.
  substitute first element of s for quote.
<annotation_end_b>#<body_start> if s [ 0 ] not in "\"'" or s [ - 1 ] != s [ 0 ] :
          raise ValueError ( "Not a string literal: %r" % s )
  quote = s [ 0 ]
<body_end><annotation_start_b>  call the method unicodedata.normalize with 2 arguments: string 'NFKD' and value, encode the result with 2 arguments: string 'ascii',
  and string 'ignore', call the method decode on the result with an argument string 'ascii', substitute the result for value.   call the method re.sub with 3 arguments: string '[^\w\s-]', empty string and value, strip the result of whitespaces from both ends,
<annotation_end_b>#<body_start> value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' )
 value = re . sub ( '[^\w\s-]' , '' , value ) . strip ( ) . lower ( )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  chunks is a tuple containing 6 initial tuples:
  result of multiplication of integers: 60,60,24,365, and return value of ungettext_lazy with 2 arguments: '%d year', '%d years',   result of multiplication of integers: 60,60,24,30, and return value of ungettext_lazy with 2 arguments: '%d month', '%d month',   result of multiplication of integers: 60,60,24,7, and return value of ungettext_lazy with 2 arguments: '%d weeks', '%d weeks',   result of multiplication of integers: 60,60,24, and return value of ungettext_lazy with 2 arguments: '%d days', '%d days',   result of multiplication of integers: 60,60, and return value of ungettext_lazy with 2 arguments: '%d hours', '%d hours',   result of multiplication of integers: 60, and return value of ungettext_lazy with 2 arguments: '%d minutes', '%d minutes',   if d is not an instance of datetime.datetime,
  call the function datetime.datetime with 3 arguments, d.year, d.month and d.day, substitute the result for d.
  if now equals to boolean True and now is not an instance of datetime.datetime,
  call the function datetime.datetime with 3 arguments, now.year, now.month and now.day, substitute the result for now.
  if now is false,
  call the function datetime.datetime with utc as argument if call to the is_aware(d) returns True, if not None is the argument, store the result in now.
  if reversed is True substitute difference of d and now for delta, if not substitute the difference of now and d for delta.
  multiply delta.days, integer 24, integer 60 and integer 60 add delta.seconds to it, substitute the result for since.
  if since is lesser or equal to integer 0,
<annotation_end_b>#<body_start> chunks = (  ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d year' , '%d years' ) ) ,  ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d month' , '%d months' ) ) ,  ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d week' , '%d weeks' ) ) ,  ( 60 * 60 * 24 , ungettext_lazy ( '%d day' , '%d days' ) ) ,  ( 60 * 60 , ungettext_lazy ( '%d hour' , '%d hours' ) ) ,  ( 60 , ungettext_lazy ( '%d minute' , '%d minutes' ) )  )
   if not isinstance ( d , datetime . datetime ) :
          d = datetime . datetime ( d . year , d . month , d . day )
  if now and not isinstance ( now , datetime . datetime ) :
          now = datetime . datetime ( now . year , now . month , now . day )
   if not now :
          now = datetime . datetime . now ( utc if is_aware ( d ) else None )
   delta = ( d - now ) if reversed else ( now - d )
  since = delta . days * 24 * 60 * 60 + delta . seconds
 if since <= 0 :
<body_end><annotation_start_b>  self.vals is an empty list.
  define the method write with 2 arguments: self and val.
  append val to self.vals.
  define the method read with an argument self.
  join elements of self.vals into a bytes string, substitute the result for ret.
  self.vals is an empty list.
  return ret.
  define the method flush with an argument self.
  return nothing.
  define the method close with an argument self.
  return nothing.
  define the function compress_sequence with an argument sequence.
  buf is an instance of StreamingBuffer class.
  zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
  and fileobj set to buf.   read data from buf file stream, yield the result.
  for every item in sequence,
  write item to zfile stream.
  flush zfile stream buffer.
  read data from buf, yield the result.
  close zfile stream.
  read data from buf, yield the result.
  call the function re.compile with an argument string "([\u0080-\uffff])", substitute the result for ustring_re.
  define the function javascript_quote with 2 arguments: s and quote_double_quotes set to boolean False.
  msg is an string "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.".
  call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
  define the function fix with an argument match.
  get the unicode representation of result of the method match.group called with an integer 1, format with in a string "\\u%04x",
  return the result.   if type of s equals bytes,
  call the method s.decode with an argument string 'utf-8', substitute the result for s.
  otherwise if, type of s doesnt equal to six.text_type,
  raise an TypeError with an argument s.
  replace every occurrence of '\\' in s with '\\\\'.
  replace every occurrence of '\r' in s with '\\r'.
  replace every occurrence of '\n' in s with '\\n'.
  replace every occurrence of '\t' in s with '\\t'.
  replace every occurrence of "'" in s with "\\'".
  replace every occurrence of '</' in s with '<\\/'.
  if quote_double_quotes is true,
  replace every occurrence of '"' in s with '&quot;'.
  call the method ustring_re.sub with 2 arguments: fix and s, return the result.
  call the function allow_lazy with 2 arguments: javascript_quote and six.text_type, substitute the result for javascript_quote.
  call the function re.compile with 2 arguments: raw string "((?:[^\s'"]*(?:(?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')[^\s'"]*)+) | \+)",
  and re.VERBOSE, substitute the result for smart_split_re.   define the function smart_split with an argument text.
  call the function force_text with an argument text, substitute the result for text.
  call the method smart_split_re.finditer with an argument text, for every bit in result,
  call the method bit.group with an argument integer 0, yield the result.
  define the function _replace_entity with an argument match.
  call the method match.group with an argument integer 1, substitute the result for text.
  if first element of text equals '#',
  remove first element of text.
  try,
  if first element of text is contained in 'xX'.
  convert text without first element to hexadecimal integer, substitute it for c.
  if nor,
  convert text to an integer, substitute it for c.
  call the method six.unichr with an argument c, return the result.
  if ValueError exception is caught,
  call the method match.group with an argument integer 0, return the result.
  if not,
  try,
  call the function six.unichr with value under the text key of the html_entities.name2codepoint dictionary, return the result.
  if OverflowError or ValueError exceptions are caught,
  call the method match.group with an argument integer 0, return the result.
  call the method re.compile with an argument raw string "&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));", substitute the result for _entity_re.
  define the function unescape_entities with an argument text.
  call the method _entity_re.sub with 2 arguments: _replace_entity and text, return the result.
  call the function allow_lazy with 2 arguments: unescape_entities and six.text_type, substitute the result for unescape_entities.
  define the function unescape_string_literal with an argument s.
  if first element of s is not contained in "\"'" or last element of s is not equal to first element of s,
  raise an ValueError exception wit an argument string "Not a string literal: %r", where "%r" is replaced with s.
  substitute first element of s for quote.
  remove first and last elements of s, replace every occurrence of string '\%s' formated with quote with quote,
  replace every occurrence of raw string '\\' in the result with string '\\', return the result.   call the function allow_lazy with an argument unescape_string_literal, substitute the result for unescape_string_literal.
  define the function slugify with an argument value.
  call the method unicodedata.normalize with 2 arguments: string 'NFKD' and value, encode the result with 2 arguments: string 'ascii',
  and string 'ignore', call the method decode on the result with an argument string 'ascii', substitute the result for value.   call the method re.sub with 3 arguments: string '[^\w\s-]', empty string and value, strip the result of whitespaces from both ends,
  and convert it to lowercase, substitute the result for value.   call the function re.sub with 3 arguments: string '[-\s]+', string '-' and value, use the result as an argument for the call to the,
  mark_safe function, return the result.   call the function allow_lazy with 2 arguments: slugify and six.text_type, substitute the result slugify.
  define the function camel_case_to_spaces with an argument value.
  call the method re_camel_case.sub with 2 arguments: raw string ' \1' and value, strip the result of whitespaces from both ends,
  from __future__ import unicode_literals into default name space.
  import module datetime.
  from django.utils.html import avoid_wrapping into default name space.
  from django.utils.timezone import is_aware and utc into default name space.
  from django.utils.translation import ugettext and ungettext_lazy into default name space.
  define the function timesince with d, now defaulting to None, reversed defaulting to False as arguments.
  chunks is a tuple containing 6 initial tuples:
  result of multiplication of integers: 60,60,24,365, and return value of ungettext_lazy with 2 arguments: '%d year', '%d years',   result of multiplication of integers: 60,60,24,30, and return value of ungettext_lazy with 2 arguments: '%d month', '%d month',   result of multiplication of integers: 60,60,24,7, and return value of ungettext_lazy with 2 arguments: '%d weeks', '%d weeks',   result of multiplication of integers: 60,60,24, and return value of ungettext_lazy with 2 arguments: '%d days', '%d days',   result of multiplication of integers: 60,60, and return value of ungettext_lazy with 2 arguments: '%d hours', '%d hours',   result of multiplication of integers: 60, and return value of ungettext_lazy with 2 arguments: '%d minutes', '%d minutes',   if d is not an instance of datetime.datetime,
  call the function datetime.datetime with 3 arguments, d.year, d.month and d.day, substitute the result for d.
  if now equals to boolean True and now is not an instance of datetime.datetime,
  call the function datetime.datetime with 3 arguments, now.year, now.month and now.day, substitute the result for now.
  if now is false,
  call the function datetime.datetime with utc as argument if call to the is_aware(d) returns True, if not None is the argument, store the result in now.
  if reversed is True substitute difference of d and now for delta, if not substitute the difference of now and d for delta.
  multiply delta.days, integer 24, integer 60 and integer 60 add delta.seconds to it, substitute the result for since.
  if since is lesser or equal to integer 0,
  call the function ugettext with '0 minutes' as argument, use the result as the argument for the call to the avoid_wrapping function, return the result.
  for every i and tuple containing 2 elements: seconds and name, in enumerated chunks,
  divide since by seconds, store the floored result in count.
  if count does not equals to integer 0,
  break the execution of the smallest enclosing loop.
  use the remainder of the division of name by count as the argument for the call to the avoid_wrapping function, store the result in result.
  if i incremented by 1 is lesser than length of chunks,
  get the element of chunks at the (i+1)-the index, assign it to the seconds2 and name2, respectively.
  multiply seconds by count, subtract it from since, divide the result by seconds2, store the floored result in count2.
  if count2 does not equals to integer 0,
  call avoid_wrapping function with name2 modulus count2 as argument, call the ugettext with ', ' as argument, add previous 2 results, increment variable result by it.
<annotation_end_b>#<body_start>          self . vals = [ ]
   def write ( self , val ) :
          self . vals . append ( val )
   def read ( self ) :
          ret = b'' . join ( self . vals )
 self . vals = [ ]
 return ret
   def flush ( self ) :
          return
   def close ( self ) :
          return
      def compress_sequence ( sequence ) :
      buf = StreamingBuffer ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )
  yield buf . read ( )
 for item in sequence :
          zfile . write ( item )
 zfile . flush ( )
 yield buf . read ( )
  zfile . close ( )
 yield buf . read ( )
   ustring_re = re . compile ( "([\u0080-\uffff])" )
   def javascript_quote ( s , quote_double_quotes = False ) :
      msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
 warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
  def fix ( match ) :
          return "\\u%04x" % ord ( match . group ( 1 ) )
   if type ( s ) == bytes :
          s = s . decode ( 'utf-8' )
  elif type ( s ) != six . text_type :
          raise TypeError ( s )
  s = s . replace ( '\\' , '\\\\' )
 s = s . replace ( '\r' , '\\r' )
 s = s . replace ( '\n' , '\\n' )
 s = s . replace ( '\t' , '\\t' )
 s = s . replace ( "'" , "\\'" )
 s = s . replace ( '</' , '<\\/' )
 if quote_double_quotes :
          s = s . replace ( '"' , '&quot;' )
  return ustring_re . sub ( fix , s )
  javascript_quote = allow_lazy ( javascript_quote , six . text_type )
    smart_split_re = re . compile ( r"""     ((?:         [^\s'"]*         (?:             (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) """ , re . VERBOSE )
   def smart_split ( text ) :
 text = force_text ( text )
 for bit in smart_split_re . finditer ( text ) :
          yield bit . group ( 0 )
     def _replace_entity ( match ) :
      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
  return six . unichr ( c )
  except ValueError :
              return match . group ( 0 )
   else :
          try :
              return six . unichr ( html_entities . name2codepoint [ text ] )
  except ( ValueError , KeyError ) :
              return match . group ( 0 )
     _entity_re = re . compile ( r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));" )
   def unescape_entities ( text ) :
      return _entity_re . sub ( _replace_entity , text )
  unescape_entities = allow_lazy ( unescape_entities , six . text_type )
   def unescape_string_literal ( s ) :
 if s [ 0 ] not in "\"'" or s [ - 1 ] != s [ 0 ] :
          raise ValueError ( "Not a string literal: %r" % s )
  quote = s [ 0 ]
 return s [ 1 : - 1 ] . replace ( r'\%s' % quote , quote ) . replace ( r'\\' , '\\' )
  unescape_string_literal = allow_lazy ( unescape_string_literal )
   def slugify ( value ) :
 value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' )
 value = re . sub ( '[^\w\s-]' , '' , value ) . strip ( ) . lower ( )
 return mark_safe ( re . sub ( '[-\s]+' , '-' , value ) )
  slugify = allow_lazy ( slugify , six . text_type )
   def camel_case_to_spaces ( value ) :
 return re_camel_case . sub ( r' \1' , value ) . strip ( ) . lower ( )
from __future__ import unicode_literals
  import datetime
  from django . utils . html import avoid_wrapping
 from django . utils . timezone import is_aware , utc
 from django . utils . translation import ugettext , ungettext_lazy
   def timesince ( d , now = None , reversed = False ) :
 chunks = (  ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d year' , '%d years' ) ) ,  ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d month' , '%d months' ) ) ,  ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d week' , '%d weeks' ) ) ,  ( 60 * 60 * 24 , ungettext_lazy ( '%d day' , '%d days' ) ) ,  ( 60 * 60 , ungettext_lazy ( '%d hour' , '%d hours' ) ) ,  ( 60 , ungettext_lazy ( '%d minute' , '%d minutes' ) )  )
   if not isinstance ( d , datetime . datetime ) :
          d = datetime . datetime ( d . year , d . month , d . day )
  if now and not isinstance ( now , datetime . datetime ) :
          now = datetime . datetime ( now . year , now . month , now . day )
   if not now :
          now = datetime . datetime . now ( utc if is_aware ( d ) else None )
   delta = ( d - now ) if reversed else ( now - d )
  since = delta . days * 24 * 60 * 60 + delta . seconds
 if since <= 0 :
           return avoid_wrapping ( ugettext ( '0 minutes' ) )
  for i , ( seconds , name ) in enumerate ( chunks ) :
          count = since // seconds
 if count != 0 :
              break
   result = avoid_wrapping ( name % count )
 if i + 1 < len ( chunks ) :
           seconds2 , name2 = chunks [ i + 1 ]
 count2 = ( since - ( seconds * count ) ) // seconds2
 if count2 != 0 :
              result += ugettext ( ', ' ) + avoid_wrapping ( name2 % count2 )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  call the method self._isdst with an argument dt, if it evaluates to true,
<annotation_end_b>#<body_start>          if self . _isdst ( dt ) :
<body_end><annotation_start_b>  call the function timedelta with an argument seconds set to negative _time.timezone, substitute the result for self.STDOFFSET.
  if _time.daylight is true,
  call the function timedelta with an argument seconds set to negative _time.altzone, substitute the result for self.DSTOFFSET.
  if not,
  substitute self.STDOFFSET for self.DSTOFFSET.
  subtract self.STDOFFSET with self.DSTOFFSET, substitute the result for self.DSTDIFF.
  call the method tzinfo.__init__ with an argument self.
  define the method utcoffset with 2 arguments: self and dt.
  call the method self._isdst with an argument dt, if it evaluates to true,
  return self.DSTOFFSET.
  if not,
<annotation_end_b>#<body_start>          self . STDOFFSET = timedelta ( seconds = - _time . timezone )
 if _time . daylight :
              self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
  else :
              self . DSTOFFSET = self . STDOFFSET
  self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
 tzinfo . __init__ ( self )
   def utcoffset ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTOFFSET
  else :
<body_end><annotation_start_b>  call the method self._isdst with an argument dt, if it evaluates to true,
<annotation_end_b>#<body_start>          if self . _isdst ( dt ) :
<body_end><annotation_start_b>  if offset is not None,
  call the function timedelta with an argument minutes set to offset, substitute the result for self.__offset.
  if name is not None,
  substitute name for self.__name.
  define the method utcoffset with 2 arguments: self and dt.
  return self.__offset.
  define the method tzname with 2 arguments: self and dt.
  return self.__name.
  define the method dst with 2 arguments: self and dt.
  return ZERO.
  derive the class ReferenceLocalTimezone from the tzinfo base class.
  define the method __init__ with an argument self.
  call the function timedelta with an argument seconds set to negative _time.timezone, substitute the result for self.STDOFFSET.
  if _time.daylight is true,
  call the function timedelta with an argument seconds set to negative _time.altzone, substitute the result for self.DSTOFFSET.
  if not,
  substitute self.STDOFFSET for self.DSTOFFSET.
  subtract self.STDOFFSET with self.DSTOFFSET, substitute the result for self.DSTDIFF.
  call the method tzinfo.__init__ with an argument self.
  define the method utcoffset with 2 arguments: self and dt.
  call the method self._isdst with an argument dt, if it evaluates to true,
  return self.DSTOFFSET.
  if not,
  return self.STDOFFSET.
  define the method utcoffset with 2 arguments: self and dt.
  call the method self._isdst with an argument dt, if it evaluates to true,
  return self.DSTDIFF.
  if not,
<annotation_end_b>#<body_start>          if offset is not None :
              self . __offset = timedelta ( minutes = offset )
  if name is not None :
              self . __name = name
    def utcoffset ( self , dt ) :
          return self . __offset
   def tzname ( self , dt ) :
          return self . __name
   def dst ( self , dt ) :
          return ZERO
     class ReferenceLocalTimezone ( tzinfo ) :
  def __init__ ( self ) :
          self . STDOFFSET = timedelta ( seconds = - _time . timezone )
 if _time . daylight :
              self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
  else :
              self . DSTOFFSET = self . STDOFFSET
  self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
 tzinfo . __init__ ( self )
   def utcoffset ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTOFFSET
  else :
              return self . STDOFFSET
    def dst ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTDIFF
  else :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  tt is a tuple with 9 elements: dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, result of the method dt.weekday,
  ingeter 0 and integer 0.   call the method _time.mktime with an argument tt, substitute the result for stamp.
  call the method _time.localtime with an argument stamp, substitute the result for tt.
<annotation_end_b>#<body_start>          tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )
 stamp = _time . mktime ( tt )
 tt = _time . localtime ( stamp )
<body_end><annotation_start_b>  if dt is None, is_dst is boolean False, otherwise call the method _isdst with an argument dt, substitute the result for is_dst.
<annotation_end_b>#<body_start>          is_dst = False if dt is None else self . _isdst ( dt )
<body_end><annotation_start_b>  try,
<annotation_end_b>#<body_start>          try :
<body_end><annotation_start_b>  if offset is an instance of timedelta class,
  substitute offset.seconds for offset.
  if offset is smaller than integer 0, sign is '-', otherwise sign is '+'.
  divide absolute offset by module 60, use the result to format string '%02d%02d', substitute it for hhmm.
  sum sign and hhmm, substitute the result for name.
<annotation_end_b>#<body_start> if isinstance ( offset , timedelta ) :
          offset = offset . seconds // 60
  sign = '-' if offset < 0 else '+'
 hhmm = '%02d%02d' % divmod ( abs ( offset ) , 60 )
 name = sign + hhmm
<body_end><annotation_start_b>  use global variable _localtime.
  if _localtime is None,
  if settings.TIME_ZONE is an instance of six.string_types and pytz is not None,
  call the method pytz.timezone with an argument settings.TIME_ZONE, substitute the result for _localtime.
  if not,
  _localtime is an instance of LocalTimezone class.
<annotation_end_b>#<body_start> global _localtime
 if _localtime is None :
          if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
              _localtime = pytz . timezone ( settings . TIME_ZONE )
  else :
               _localtime = LocalTimezone ( )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  try,
<annotation_end_b>#<body_start> try :
<body_end><annotation_start_b>  call the method __init__ with an argument name form the base class of the class MovedAttribute.
  if PY3 is true,
  if new_mod is None,
  substitute name for new_mod.
  substitute new_mod for self.mod.
  if new_attr is None,
  if old_attr is None,
  substitute name for new_attr.
  if not,
  substitute old_attr for new_attr.
  substitute new_attr for self.attr.
  if not,
  substitute old_mod for self.mod.
  if old_attr is None,
  substitute name for old_attr.
  substitute old_attr for self.attr.
  define the method _resolve with an argument self.
  call the function _import_module with an argument self.mod, substitute the result for module.
  gett self.attr from the module object, return it.
  derive class _MovedItems from the _LazyModule base class.
  _moved_attributes is a list with 55 initial elements, 13 of them are the results of the call to the function MovedAttribute,
  with different 3 string arguments, the others are results of the call to the function MovedModule called with 3 string arguments.   for every attr in _moved_attributes,
  set attr.name attribute of the _MovedItemst object to attr.
  if attr is an instance of MovedModule.
  concatenate __name__, string '.moves' and attr.name together, use it as an key to get the value from the sys.modules dictionary,
  substitute attr for the obtained value.   delete attr.
  substitute _moved_attributes for _MovedItems._moved_attributes.
  append string '.moves' to __name__, use it as an argument to instantiate _MovedItems class, assign it to moves,
  and to value under the '.moves' appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_parse from the _LazyModule base class.
  _urllib_parse_moved_attributes is a list with 16 elemetns, all of them are the results of the call to the function MovedAttribute with different 3 string arguments.
  for every attr in _urllib_parse_moved_attributes,
  set attr.name attribute of the Module_six_moves_urllib_parse object to attr.
  delete attr.
  substitute _urllib_parse_moved_attributes for Module_six_moves_urllib_parse._moved_attributes.
  call the method Module_six_moves_urllib_request with an argument: string ".moves.urllib_parse" appended to __name__,
  assign the result to the value under the string ".moves.urllib_parse" appended to __name__ key of the sys.modules dictionary,   and to the value under the string ".moves.urllib.parse" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_error from the _LazyModule base class.
  _urllib_error_moved_attributes is a list with 3 elements: result of the call to the function MovedAttribute with 3 arguments:
  strings "URLError", "urllib2", "urllib.error", result of the call to the function MovedAttribute with 3 arguments:   strings "HTTPError", "urllib2", "urllib.error" and result of the call to the function MovedAttribute with 3 arguments:   strings "ContentTooShortError", "urllib", "urllib.error".   for every attr in _urllib_error_moved_attributes,
  set attr.name attribute of the Module_six_moves_urllib_error object to attr.
  delete attr.
  substitute _urllib_error_moved_attributes for Module_six_moves_urllib_error._moved_attributes.
  call the method Module_six_moves_urllib_request with an argument: string ".moves.urllib.error" appended to __name__,
  assign the result to the value under the string ".moves.urllib_error" appended to __name__ key of the sys.modules dictionary,   and to the value under the string ".moves.urllib.error" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_request from the _LazyModule base class.
  _urllib_request_moved_attributes is an list with 33 elements, all of them are the results of the call to the function MovedAttribute with 3 different string arguments.
  for every attr in _urllib_request_moved_attributes,
  set attr.name attribute of the Module_six_moves_urllib_request object to attr.
  delete attr.
  substitute _urllib_request_moved_attributes for Module_six_moves_urllib_request._moved_attributes.
  call the method Module_six_moves_urllib_request with an argument: string ".moves.urllib.request" appended to __name__,
  assign the result to the value under the string ".moves.urllib_request" appended to __name__ key of the sys.modules dictionary,   and to the value under the string ".moves.urllib.request" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_response from the _LazyModule base class.
  _urllib_response_moved_attributes is a list with 4 elements: result of the function MovedAttribute, called with 3 arguments:
  strings "addbase", "urllib" and "urllib.response", result of the function MovedAttribute, called with 3 arguments:   strings "addclosehook", "urllib", "urllib.response", result of the function MovedAttribute, called with 3 arguments:   strings "addinfo", "urllib", "urllib.response" and result of the function MovedAttribute, called with 3 arguments:   strings "addinfourl", "urllib", "urllib.response".   for every attr in _urllib_response_moved_attributes,
  set attr.name attribute of Module_six_moves_urllib_response object to attr.
  delete attr.
  substitute _urllib_response_moved_attributes for Module_six_moves_urllib_response._moved_attributes.
  instantiate class Module_six_moves_urllib_response with an argument, string ".moves.urllib.response" appended to __name__,
  assign it to value under the string ".moves.urllib_response" appended to __name__ key of the sys.modules dictionary,   and to value under the string ".moves.urllib.response" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib_robotparser from the _LazyModule base class.
  _urllib_robotparser_moved_attributes is a list containing an instance of MovedAttribute class, created with 3 argument: strings,
  "RobotFileParser", "robotparser", "urllib.robotparser".   for every attr in _urllib_robotparser_moved_attributes,
  set attr.name attribute of Module_six_moves_urllib_robotparser object to attr.
  delete attr.
  substitute _urllib_robotparser_moved_attributes for Module_six_moves_urllib_robotparser._moved_attributes.
  instantiate class Module_six_moves_urllib_robotparser with an argument, string ".moves.urllib.robotparser" appended to __name__,
  assign it to value under the string ".moves.urllib_robotparser" appended to __name__ key of the sys.modules dictionary,   and to value under the string ".moves.urllib.robotparser" appended to __name__ key of the sys.modules dictionary.   derive class Module_six_moves_urllib from the types.ModuleType base class.
  append string ".moves.urllib_parse" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for parse.
  append string ".moves.urllib_error" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for error.
  append string ".moves.urllib_request" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for request.
  append string ".moves.urllib_response" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for response.
  append string ".moves.urllib_robotparser" to __name__, use it as an key to get the value from the sys.modules dictionary, substitute it for robotparser.
  define the method __dir__ with an argument self.
  return a list with 5 elements: strings 'parse', 'error', 'request', 'response' and 'robotparser'.
  instantiate class Module_six_moves_urllib with an argument, string ".moves.urllib" appended to __name__,
  substitute it for value under the string ".moves.urllib" appended to __name__ key of the sys.modules dictionary.   define the function add_move with an argument move.
  set move.name attribute of the _MovedItems to move.
  define the function remove_move with an argument name.
  try,
  delete name attribute of the _MovedItems object.
  if AttributeError exception is caught,
  try,
  delete entry under the name key of the moves.__dict__ dictionary.
  if NameError exception is caught,
  raise an AttributeError with an argument string "no such move, %r", formated with a tuple with an element name.
  if PY3 is true,
  _meth_func is a string "__func__".
  _meth_self is a string "__self__".
  _func_closure is a string "__closure__".
  _func_code is a string "__code__".
  _func_defaults is a string "__defaults__".
  _func_globals is a string "__globals__".
  _iterkeys is a string "keys".
  _itervalues is a string "values".
  _iteritems is a string "items".
  _iterlists is a string "lists".
  if not,
  _meth_func is a string "im_func".
  _meth_self is a string "im_self".
  _func_closure is a string "func_closure".
  _func_code is a string "func_code".
  _func_defaults is a string "func_defaults".
  _func_globals is a string "func_globals".
  _iterkeys is a string "iterkeys".
  _iterkeys is a string "iterkeys".
  _iteritems is a string "iteritems".
  _iterlists is a string "iterlists".
  try,
  substitute next for advance_iterator.
  if NameError exception is caught,
  define the function advance_iterator with an argument it.
  return next element of the iterable it.
  substitute klass.__dict__ for next.
  try,
  substitute callable for callable.
  if NameError exception is caught,
  define the function callable with an argument obj.
  if "__call__" is contained in klass.__dict__ for any klass in __mro__ field of the obj class, return boolean True, otherwise return False.
  if PY3 is true,
  define the function get_unbound_function with an argument unbound.
  return unbound.
  substitute Iterator for create_bound_method.
  substitute object for Iterator.
  if not,
  define the function get_unbound_function with an argument unbound.
  return unbound.im_func.
  define the function create_bound_function with 2 arguments: func and obj.
  call the method types.MethodType with 3 arguments: func, obj and obj.__class__, return the result.
  derive the class Iterator from the base class object.
  define the method next with an argument self.
  call the function type with an argument self, on the result call the method __next__ with an argument self, return the result.
  substitute callable for callable.
  call the function _add_doc with 2 arguments: get_unbound_function and string """Get the function out of a possibly unbound function""".
  call the method operator.attrgetter with an argument _meth_func, substitute the result for get_method_function.
  call the method operator.attrgetter with an argument _meth_self, substitute the result for get_method_self.
  call the method operator.attrgetter with an argument _func_closure, substitute the result for get_method_closure.
  call the method operator.attrgetter with an argument _func_code, substitute the result for get_method_code.
  call the method operator.attrgetter with an argument _func_defaults, substitute the result for get_method_defaults.
  call the method operator.attrgetter with an argument _func_globals, substitute the result for get_method_globals.
  define the function iterkeys with 2 arguments: d and unpacked dictionary  kw.
  get _iterkeys attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function itervalues with 2 arguments: d and unpacked dictionary  kw.
  get _itervalues attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function iteritems with 2 arguments: d and unpacked dictionary  kw.
  get _iteritems attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   define the function iterlists with 2 arguments: d and unpacked dictionary  kw.
  get _iterlists attribute of the class d, call the result with an argument unpacked dictionary kw, convert the result to a iterable,
  return it.   if PY3 is true,
  define the function b with an argument s.
  call the method e.encode with an argument string "latin-1".
  define the function u with an argument s.
  return s.
  substitute chr for unichr.
  if second element of sys.version_info is smaller than or equal to integer 1,
  define the function int2byte with an argument i.
  call the function bytes with an argument tuple with an element i, return the result.
  if not,
  call the method operator.methodcaller with 3 arguments: string 'to_bytes', integer 1 and string 'big', substitute the result for int2byte.
  call te method operator.itemgetter with an argument integer 0, substitute the result for byte2int.
  substitute operator.getitem for indexbytes.
  substitute iter for iterbytes.
  import io.
  substitute io.StringIO for StringIO.
  substitute io.BytesIO for BytesIO.
  if not,
  define the function b with an argument s.
  return s.
  define the function u with an argument s.
  replace every occurrence of raw string '\\' in s with a raw string '\\\\', use the result and string "unicode_escape",
  as arguments for the call to the unicode function, return the result.  substitute unichr for unichr.
  substitute chr for int2byte.
  define the function byte2int with an argument bs.
  get the integer representation of the first element of bs, return it.
  define the function indexbytes with 2 arguments buf and i.
  get the integer representation of the i-th element of buf, return it.
  define the function iterbytes with an argument buf.
  convert byte to its integer representation, return all of the results for every byte in buf.
  import StringIO.
  assign StringIO.StringIO to StringIO and BytesIO.
  call the function _add_doc with 2 arguments: b and string """Byte literal""".
  call the function _add_doc with 2 arguments: u and string """Text literal""".
  if PY3 is true,
  get 'exec' attribute from the moves.builtins object, substitute it for exec_.
  define the function reraise with 3 arguments: tp, value and tb set to None.
  if value.__traceback__ is not tb,
  raise an value.with_traceback exception with an argument tb.
  raise an exception value.
  if not,
  define the function exec with 3 arguments: _code_, _globs_ set to None and _locs_ set to None.
  if _globs_ is None,
  call the method sys._getframe with an argument 1, substitute the result for frame.
  substitute frame.f_globals for _globs_.
  if _locs_ is None,
  substitute if _locs_ is None for _locs_.
  delete frame.
  otherwise if _locs_ is None,
  substitute _globs_ with an argument _locs_.
  execute code statement """exec _code_ in _globs_, _locs_""".
  call the function exec_ with an argument string """def reraise(tp, value, tb=None):    raise tp, value, tb""".
  get attribute 'print' from the moves.builtins object, if it exists substitute it for print_, if not print_ is None.
  if print_ is None,
  define the function print_ with 2 arguments: unpacked list args and unpacked dictionary kwargs.
  remover 'file' key from the kwargs dictionary, if it exists substitute it for fp, if not substitute sys.stdout for fp.
  if fp is None,
  return nothing.
  define the function write with an argument data.
  if data is not an instance of basestring,
  convert data to string, substitute it for data.
  if fp is an instance of file and data is an instance of unicode and fp.encoding is not None,
  get 'errors' attribute from fp object, substitute it for errors if it exists, if not errors is None.
  if errors is None,
  errors is a string "strict".
  call the method data.encode with 2 arguments: fp.encoding and errors, substitute the result for data.
  write data to fp.
  want_unicode is boolean False.
  remove 'sep' key from the kwargs dictionary, if it exists substitute it for sep, if not sep is None.
  if sep is not None,
  if sep is an instance of unicode,
  want_unicode is boolean True.
  otherwise if sep is not an instance of string type,
  raise an TypeError exception with an argument string "sep must be None or a string".
  remove 'end' key from the kwargs dictionary, if it exists substitute it for end, if not end is None.
  if end is not None,
  if end is an instance of unicode,
  want_unicode is boolean True.
  otherwise if end is not an instance of string type,
  raise an TypeError exception with an argument string "end must be None or a string".
  if kwargs is true,
  raise an TypeError exception with an argument string "invalid keyword arguments to print()".
  if want_unicode is false,
  for every arg in args,
  if arg is an instance of unicode,
  want_unicode is boolean True.
  break from the loop execution.
  if want_unicode is true,
  convert newline character to unicode and substitute the result for newline.
  convert whitespace character to unicode and substitute the result for space.
  if not,
  substitute newline character for newline.
  substitute string " " for space.
  if sep is None,
  substitute space for sep.
  if end is None
  substitute space for end.
  for every i and arg in enumerated iterable args,
  if i is true,
  call the function write with an argument sep.
  call the function write with an argument arg.
  call the function write with an argument end.
  call the function _add_doc with 2 arguments: reraise and string """Reraise an exception.""".
  define the function with_metaclass with 2 arguments meta and unpacked list bases.
  derive the class metaclass form the meta base class.
  substitute type.__call__ for __call__.
  substitute type.__init__ for __init__.
  define the method __new__ with 4 arguments: cls, name, this_bases and d.
  if this_bases is None,
  call the method type.__new__ with 4 arguments: cls, name, empty tuple and d, return the result.
  call the function meta with 3 arguments: name, base and d.
  return an instance of metaclass class, created with 3 arguments: string 'temporary_class', None and an empty dictionary.
  define the function add_metaclass with an argument metaclass.
  define the function wrapper with an argument cls.
  call the method cls.__dict__.copy substitute the result for orig_vars.
  remove '__dict__' key from the orig_vars dictionary.
  remove '__weakref__' key from the orig_vars dictionary.
  get the value under the '__slots__' key of the orig_vars dictionary, substitute it for slots.
  if slots is not None,
  if slots is an instance of str,
  slots is a list with an element, slots.
  for every slots_var in slots,
  remove slots_var key from the orig_vars dictionary.
  return an instance of metaclass class, created with 3 arguments: cls.__name__, cls.__bases__ and orig_vars.
  return wrapper.
  if PY3 is true,
  _assertCountEqual is a strnig "assertCountEqual".
   _assertRaisesRegex is a strnig "assertRaisesRegex".
  _assertRegex is a strnig "assertRegex".
  substitute memoryview for memoryview.
  buffer_types is a tuple with 3 elements: bytes, bytearray and memoryview.
  if not,
  _assertCountEqual is a strnig "assertItemsEqual".
  _assertRaisesRegex is a strnig "assertRaisesRegexp".
  _assertRegex is a strnig "assertRegexpMatches".
  if sys.platform starts with a string 'java',
  substitute memoryview for memoryview.
  if not,
  substitute buffer for memoryview.
  buffer_types is a tuple with 2 elements bytearray and memoryview.
  define the function assertCountEqual with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertCountEqual attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRaisesRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRaisesRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   define the function assertRegex with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.
  get _assertRegex attribute of the self object, call the result with 2 arguments: unpacked list args,
  and unpacked dictionary kwargs, return the result.   call the function MovedModule with 2 arguments: strings "_dummy_thread" and "dummy_thread",
  use the result as an argument for the call to the add_move function.   call the function MovedModule with 2 arguments: strings "_thread" and "thread",
  import module contextlib.
  try,
  import threading.
  except ImportError.
  import dummy_threading as threading.
  derive the class RWLock from the object base class.
  define the method __init__ with an argument self.
  call the method threading.RLock, substitute the result for self.mutex.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_read.
  call the method threading.Semaphore with an argument integer 0, substitute the result for self.can_write.
  self.active_readers is an integer 0.
  self.active_writers is an integer 0.
  self.waiting_readers is an integer 0.
  self.waiting_writers is an integer 0.
  define the method reader_enters with an argument self.
  with self.mutex perform,
  if self.active_writers and self.waiting_writers both equal to integer 0,
  increment self.active_readers by 1.
  call the method self.can_read.release.
  if not,
  increment self.waiting_readers by 1.
  call the method self.can_read.acquire.
  define the method reader_leaves with an argument self.
  with self.mutex perform,
  decrement self.active_readers by integer 1,
  if self.active_readers equals integer 0 and self.waiting_writers is not equal to integer 0,
  increment self.active_writers by 1.
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  contextlib.contextmanager decorator,
  define the method reader with an argument self.
  call the method self.reader_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.reader_leaves.
  define the method writer_enters with an argument self.
  with self.mutex perform,
  if self.active_writers equals integer 0 and self.waiting_writers equals integer 0 and self.active_readers equals integer 0,
  increment self.active_writers by integer 1,
  call the method self.can_write.release.
  if not,
  increment self.waiting_writers by integer 1,
  call the method self.can_write.acquire.
  define the method writer_leaves with an argument self.
   with self.mutex perform,
  decrement self.active_writers by integer 1,
  if self.waiting_writers is not equal to integer 0,
  increment self.active_writers by integer 1,
  decrement self.waiting_writers by integer 1,
  call the method self.can_write.release.
  otherwise if self.waiting_readers is not equal to integer 0,
  substitute self.waiting_readers for t.
  self.waiting_readers is integer 0.
  increment self.active_readers by t.
  while t is greater than integer 0,
  call the method self.can_read.release.
  decrement t by integer 1,
  contextlib.contextmanager decorator,
  define the method writer with an argument self.
  call the method self.writer_enters.
  try,
  yield nothing.
  finally perform,
  call the method self.writer_leaves.
  from django.utils import six into default name space.
  color_names is a tuple with 8 elements: strings 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'.
  foreground is a dictionary created with elements: x appended to a string '3' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   background is a dictionary created with elements: x appended to a string '4' for value under the key x of color_names dictionary,
  for every x in sequence of integers from 0 to 7.   RESET is a string '0'.
  opt_dict is an dictionary with 5 elements: '1' for 'bold', '4' for 'underscore', '5' for 'blink', '7' for 'reverse',
  and '8' for 'conceal'.   define the method colorize with 3 arguments: text set to an empty string, opts set to an empty tuple and unpacked dictionary kwargs.
  code_list is an empty list.
  if text is an empty string and length of opts equals integer 1 and first element of opts equals string 'reset',
  format string '\x1b[%sm' with RESET, return the result.
  call the function six.iteritems with an argument kwargs, for every k and v in the result,
  if k equals a string 'fg',
  append value under the key v of foreground dictionary to code_list.
  otherwise if k equals a string 'bg',
  append value under the key v of background dictionary to code_list.
  for every o in opts,
  if o is contained in opt_dict,
  append value under the 0 key of the opt_dict dictionary to code_list.
  if string 'noreset' is not contained in opts,
  if text is true format with it and RESET a string '%s\x1b[%sm', if not format it with an empty string and RESET, substitute the result for text.
  join elements of code_list in a string, separated by ';', format string '\x1b[%sm' with it, append text to the result if exists,
  return the string.   define the function make_style with 2 arguments: opts set to an empty tuple and unpacked dictionary kwargs.
  return lambda function with text as argument and return value being result of the function colorize, called with 3 arguments: text,
  opts and unpacked dictionary kwargs.   NOCOLOR_PALETTE is a string 'nocolor'.
  DARK_PALETTE is a string 'dark'.
  LIGHT_PALETTE is a string 'light'.
  PALETTES is a dictionary containing 3 elements, a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE,
  a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE,   and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE.   substitute DARK_PALETTE for DEFAULT_PALETTE.
  define the function parse_color_setting with an argument config_string.
  if config_string is false,
  return value under the DEFAULT_PALETTE key of the PALETTES dictionary.
  convert config_string to lowercase and split it by ';' character, substitute the result for parts.
  get value under the config_string key of the PALETTES dictionary, call the copy method on the result and substitute it for palette.
  for every part in parts,
  if part is contained in PALETTES,
  get the value under the part key of the PALETTES dictionary, update with it palette dictionary.
  otherwise if '=' is contained in part,
  definition is an empty dictionary,
  split part by '=' character, substitute the result for role and instructions, respectively.
  convert role to uppercase.
  split instructions by ',' character, substitute the result for styles.
  reverse the order of elements of styles.
  remove first element from styles, split it by the '/' character, substitute the result for colors.
  reverse the order of colors elements,
  remove the first element from colors, substitute it for fg.
  if fg is contained in color_names,
  substitute fg for value under the 'fg' key of definition dictionary.
  if colors is true and last element of colors is contained in color_names,
  substitute last element of colors for value under the 'bg' key of definition dictionary.
  opts is a tuple created out of elements s, for every s in styles is s is in the keys of the opt_dict dictionary.
  if opts is true,
  substitute opts for value under the 'opts' key of definition dictionary.
  if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true,
  substitute definition for value under the role key of palette dictionary.
  if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary,
  return None.
  return palette.
  from __future__ import unicode_literals into default name space.
  import module re.
  import module unicodedata.
  from gzip import GzipFile into default name space.
  from io import BytesIO into default name space.
  import module warnings.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils.encoding import force_text into default name space.
  from django.utils.functional import allow_lazy and SimpleLazyObject into default name space.
  from django.utils import six into default name space.
  from django.utils.six.moves import html_entities into default name space.
  from django.utils.translation import ugettext_lazy,  ugettext as _ and pgettext into default name space.
  from django.utils.safestring import mark_safe into default name space.
  if six.PY2 is true,
  from django.utils.encoding import force_unicode.
  if identity lambda function returns false, substitute the x for capfirst, if not call the function force_text with an argument x,
  convert the first element of the result to uppercase, append to it the rest of the result, substitute it for capfirst.   call the function allow_lazy with 3 arguments: capfirst and six.text_type.
  call the function re.compile with 2 arguments: raw string '<.*?>|((?:\w[-\w]*|&.*?;)+)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_words.   call the function re.compile with 2 arguments: raw string '<.*?>|(.)' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with 2 arguments: raw string '<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' and bitwise OR performed with 2 operands,
  re.U and re.S, substitute the result for re_chars.   call the function re.compile with an argument raw string '\r\n|\r', substitute the result for re_newlines.
  call the function re.compile with an argument raw string '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', substitute the result for re_camel_case.
  define the function wrap with 2 arguments text and width.
  call the function force_text with an argument text, substitute the result for text.
  define the function _generator.
  call the method text.splitlines with an argument boolean True, for every line in the result,
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  while length of line is grater than max_width,
  get fist max_width incremented by 1 elements from line, find index of the first occurrenece of whitespace from the right side,
  add integer 1 to it, substitute the result for space.   if space equals integer 0,
  find first index of whitespace occurrence in line, add integer 1 to it, substitute the result for space.
  if space equals integer 0,
  yield line.
  line is an empty string.
  break from the loop execution
  get the first space decremented with integer 1 elements from string line, append newline character to it, and yield the result.
  remove all the elements from space index of line.
  if line ends with a new line character substitute width incremented by integer 1 for max_width, if not substitute width for max_width.
  if line is true,
  yield line.
  call the function _generator, join the result into a string, return the result.
  call the function allow_lazy with 2 arguments: wrap and six.text_type, substitute the result for wrap.
  derive the class Truncator form the SimpleLazyObject class.
  define the method __init__ with 2 arguments: self and text.
  call the method __init__ from the base class of the class Truncator,
  called with with an argument lambda function which returns result of the force_text function called with an argument text.   define the method add_truncation_text with 3 arguments: self, text and truncate set to None.
  if truncate is None,
  call the function pgettext with an argument 'String to return when truncating text', '%(truncated_text)s...', substitute the result for truncate.
  call the function force_text with an argument truncate, substitute the result for truncate.
  if string '%(truncated_text)s' is contained in truncate,
  format truncate with a dictionary with an element: text for 'truncated_text', return the result.
  if text ends with truncate,
  return text.
  append truncate to text, return the result.
  define the method chars with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute it for length.
  call the function unicodedata.normalize with 2 arguments: string 'NFC' and self._wrapped, substitute the result for text.
  substitute length for truncate_len.
  for every char in result of the self.add_truncation_text, called with 2 arguments: an empty string and truncate.
  call the method unicodedata.combining with an argument char, if it evaluates to false,
  decrement truncate_len by integer 1.
  if truncate_len equals integer 0.
  break from the loop execution.
  if html is true,
  call the function self._truncate_html with 5 arguments: length, truncate, text, truncate_len and boolean False, return the result.
  call the method self._text_chars with 4 arguments: length, truncate, text and truncate_len, return the result.
  call the function allow_lazy with an argument chars, substitute the result for chars.
  define the method _text_chars with 5 arguments: self, length, truncate, text and truncate_len.
  s_len is integer 0.
  end_index is None.
  for every i and char in enumerated text,
  call the function unicodedata.combining with an argument char, if it evaluates to true,
  skip this loop iteration,s
  increment s_len by integer 1,
  if end_index is None and s_len is greater than truncate_len,
  substitute i for end_index.
  if s_len is greater than length,
  call the method self.add_truncation_text with 2 arguments: if end_index is greater than zero, first end_index elements of text,
  if not an empty string, and truncate, return the result.   return text.
  define the method words with 4 arguments: self, num, truncate set to None, html set to boolean False.
  convert num to an integer, substitute the result for length.
  if html is true,
  call the method self._truncate_html with 5 arguments: length, truncate, self._wrapped, length and boolean True, return the result.
  call the method self._text_words with 2 arguments length and truncate, return the result.
  call the function allow_lazy with an argument words, substitute the result for words.
  define the method _text_words with 3 arguments: self, length and truncate.
  split self._wrapped into words, substitute the result for words.
  if length of words is greater than length,
  substitute first length elements of words for words.
  call the method self.add_truncation_text with 2 arguments: elements of words joined in a string, separated with whitespaces,
  and truncate, return the result.   return elements of words joined in a string, separated with whitespaces.
  define the method _truncate_html with 6 arguments: self, length, truncate, text, truncate_len and words.
  if words is not empty and length is smaller than or equal to integer 0,
  return an empty string.
  html4_singlets is a tuple with 9 elements: strings 'br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr' and 'input'.
  pos is equal to integer 0.
  end_text_pos is equal to integer 0.
  current_len is equal to integer 0.
  open_tags is an empty list.
  if words is true, substitute re_words for regex, if not substitute re_chars for regex.
  while current_len is smaller than or equal to length,
  call the method regex.search with 2 arguments: text and pos.
  if m is false,
  break from the loop execution,
  call the method m.end with an argument integer 0, substitute the result for pos.
  call the function m.group, if the result evaluates to true,
  increment current_len by integer 1,
  if current_len equals truncate_len,
  substitute pos for end_text_pos.
  skip this loop iteration.
  call the method m.group with an argument integer 0, use it as an argument for the call to the re_tag.match function,
  substitute the result for tag.   if tag is false or current_len is greater or equal to truncate_len,
  skip this loop iteration.
  call the method tag.groups, substitute the result for closing_tag, tagname and self_closing, respectively.
  convert tagname to lowercase, substitute it for tagname.
  if self_closing is true or tagname is contained in html4_singlets,
  do nothing.
  otherwise if closing_tag is true,
  try,
  get the index of the first occurrence of tagname, substitute it for i.
  if ValueError exception is caught,
  do nothing.
  if not,
  create a list out of open_tags elements form (i+1)-th index to the end, substitute it for open_tags.
  if not,
  insert tagname at the beginning of open_tags.
  if current_len is smaller than or equal to length,
  return text.
  create a list out of fist end_text_pos text elemnts, substitue it for out.
  call the method self.add_truncation_text with 2 arguments: an empty string and truncate, substitute it for truncate_text.
  if truncate_text is true,
  append truncate_text to out.
  for every tag in open_tags,
  replace '%s' in string '</%s>' with tag, append the result to out.
  return out.
  define the function get_valid_filename with an argument s.
  call the function force_text with an argument s, strip the result of whitespaces from both ends,
  replace every occurrence of whitespaces in the previous result for '_', substitute the result for s.   call the function re.sub with 3 arguments: raw string '(?u)[^-\w.]', an empty string and s, return the result.
  call the function allow_lazy with 2 arguments: get_valid_filename and six.text_type, substitute the result for get_valid_filename.
  define the function get_text_list with 2 arguments: list_ and last_word set to result of the function ugettext_lazy called with an argument string 'or'.
  is length of list_ equals integer 0,
  return an empty string.
  if length of list_ equals integer 1,
  call the function force_text with first element of list_ as an argument, return the result.
  return a string '%s %s %s' formated with 3 elements: result of the function force_text called with an argument i,
  separated by result of the function _ called with an argument string ', ', for every i in list_ without last element,   result of the function force_text called with an argument last_word, result of the function force_text called with an argument:   last element of list_.   call the function allow_lazy with 2 arguments: get_text_list and six.text_type, substitute the result for get_text_list.
  define the function normalize_newlines with an argument text.
  call the function force_text with an argument text, substitute the result for text.
  call the method re_newlines.sub with 2 arguments: '\n' and text, return the result.
  call the function allow_lazy with 2 arguments: normalize_newlines and six.text_type, substitute the result for normalize_newlines.
  define the function phone2numeric with an argument phone.
  char2number is an dictionary, with 26 elements: 2 for 'a', 2 for 'b', 2 for 'c', 3 for 'd', 3 for 'e', 3 for 'f', 4 for 'g',
  4 for 'h', 4 for 'i', 4 for 'j', 5 for 'k', 5 for 'l', 5 for 'm', 6 for 'n', 6 for 'o', 6 for 'p', 7 for 'q', 7 for 'r', 7 for 'r',   7 for 's', 7 for 't', 8 for 't', 8 for 'u', 8 for 'v', 9 for 'w', 9 for 'x', 9 for 'y' and 9 for 'z'.   for every c in phone converted to lowercase, join the value under the c key of the char2number dictionary into a string, return it.
  call the function allow_lazy with an argument phone2numeric, substitute the result for phone2numeric.
  define the function compress_string with an argument s.
  zbuf is an instance of BytesIO class.
  zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
  and fileobj set to zbuf.   call the method zfile.write with an argument s.
  call the method zfile.close.
  call the method zbuf.getvalue, return the result.
  derive the class StreamingBuffer from the object base class.
  define the method __init__ with an argument self.
  self.vals is an empty list.
  define the method write with 2 arguments: self and val.
  append val to self.vals.
  define the method read with an argument self.
  join elements of self.vals into a bytes string, substitute the result for ret.
  self.vals is an empty list.
  return ret.
  define the method flush with an argument self.
  return nothing.
  define the method close with an argument self.
  return nothing.
  define the function compress_sequence with an argument sequence.
  buf is an instance of StreamingBuffer class.
  zfile is an instance of GzipFile class, created with 3 arguments: mode set to string 'wb', compresslevel set to integer 6,
  and fileobj set to buf.   read data from buf file stream, yield the result.
  for every item in sequence,
  write item to zfile stream.
  flush zfile stream buffer.
  read data from buf, yield the result.
  close zfile stream.
  read data from buf, yield the result.
  call the function re.compile with an argument string "([\u0080-\uffff])", substitute the result for ustring_re.
  define the function javascript_quote with 2 arguments: s and quote_double_quotes set to boolean False.
  msg is an string "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.".
  call the function warnings.warn with 3 arguments: msg, RemovedInDjango19Warning and stacklevel as integer 2.
  define the function fix with an argument match.
  get the unicode representation of result of the method match.group called with an integer 1, format with in a string "\\u%04x",
  return the result.   if type of s equals bytes,
  call the method s.decode with an argument string 'utf-8', substitute the result for s.
  otherwise if, type of s doesnt equal to six.text_type,
  raise an TypeError with an argument s.
  replace every occurrence of '\\' in s with '\\\\'.
  replace every occurrence of '\r' in s with '\\r'.
  replace every occurrence of '\n' in s with '\\n'.
  replace every occurrence of '\t' in s with '\\t'.
  replace every occurrence of "'" in s with "\\'".
  replace every occurrence of '</' in s with '<\\/'.
  if quote_double_quotes is true,
  replace every occurrence of '"' in s with '&quot;'.
  call the method ustring_re.sub with 2 arguments: fix and s, return the result.
  call the function allow_lazy with 2 arguments: javascript_quote and six.text_type, substitute the result for javascript_quote.
  call the function re.compile with 2 arguments: raw string "((?:[^\s'"]*(?:(?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')[^\s'"]*)+) | \+)",
  and re.VERBOSE, substitute the result for smart_split_re.   define the function smart_split with an argument text.
  call the function force_text with an argument text, substitute the result for text.
  call the method smart_split_re.finditer with an argument text, for every bit in result,
  call the method bit.group with an argument integer 0, yield the result.
  define the function _replace_entity with an argument match.
  call the method match.group with an argument integer 1, substitute the result for text.
  if first element of text equals '#',
  remove first element of text.
  try,
  if first element of text is contained in 'xX'.
  convert text without first element to hexadecimal integer, substitute it for c.
  if nor,
  convert text to an integer, substitute it for c.
  call the method six.unichr with an argument c, return the result.
  if ValueError exception is caught,
  call the method match.group with an argument integer 0, return the result.
  if not,
  try,
  call the function six.unichr with value under the text key of the html_entities.name2codepoint dictionary, return the result.
  if OverflowError or ValueError exceptions are caught,
  call the method match.group with an argument integer 0, return the result.
  call the method re.compile with an argument raw string "&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));", substitute the result for _entity_re.
  define the function unescape_entities with an argument text.
  call the method _entity_re.sub with 2 arguments: _replace_entity and text, return the result.
  call the function allow_lazy with 2 arguments: unescape_entities and six.text_type, substitute the result for unescape_entities.
  define the function unescape_string_literal with an argument s.
  if first element of s is not contained in "\"'" or last element of s is not equal to first element of s,
  raise an ValueError exception wit an argument string "Not a string literal: %r", where "%r" is replaced with s.
  substitute first element of s for quote.
  remove first and last elements of s, replace every occurrence of string '\%s' formated with quote with quote,
  replace every occurrence of raw string '\\' in the result with string '\\', return the result.   call the function allow_lazy with an argument unescape_string_literal, substitute the result for unescape_string_literal.
  define the function slugify with an argument value.
  call the method unicodedata.normalize with 2 arguments: string 'NFKD' and value, encode the result with 2 arguments: string 'ascii',
  and string 'ignore', call the method decode on the result with an argument string 'ascii', substitute the result for value.   call the method re.sub with 3 arguments: string '[^\w\s-]', empty string and value, strip the result of whitespaces from both ends,
  and convert it to lowercase, substitute the result for value.   call the function re.sub with 3 arguments: string '[-\s]+', string '-' and value, use the result as an argument for the call to the,
  mark_safe function, return the result.   call the function allow_lazy with 2 arguments: slugify and six.text_type, substitute the result slugify.
  define the function camel_case_to_spaces with an argument value.
  call the method re_camel_case.sub with 2 arguments: raw string ' \1' and value, strip the result of whitespaces from both ends,
  from __future__ import unicode_literals into default name space.
  import module datetime.
  from django.utils.html import avoid_wrapping into default name space.
  from django.utils.timezone import is_aware and utc into default name space.
  from django.utils.translation import ugettext and ungettext_lazy into default name space.
  define the function timesince with d, now defaulting to None, reversed defaulting to False as arguments.
  chunks is a tuple containing 6 initial tuples:
  result of multiplication of integers: 60,60,24,365, and return value of ungettext_lazy with 2 arguments: '%d year', '%d years',   result of multiplication of integers: 60,60,24,30, and return value of ungettext_lazy with 2 arguments: '%d month', '%d month',   result of multiplication of integers: 60,60,24,7, and return value of ungettext_lazy with 2 arguments: '%d weeks', '%d weeks',   result of multiplication of integers: 60,60,24, and return value of ungettext_lazy with 2 arguments: '%d days', '%d days',   result of multiplication of integers: 60,60, and return value of ungettext_lazy with 2 arguments: '%d hours', '%d hours',   result of multiplication of integers: 60, and return value of ungettext_lazy with 2 arguments: '%d minutes', '%d minutes',   if d is not an instance of datetime.datetime,
  call the function datetime.datetime with 3 arguments, d.year, d.month and d.day, substitute the result for d.
  if now equals to boolean True and now is not an instance of datetime.datetime,
  call the function datetime.datetime with 3 arguments, now.year, now.month and now.day, substitute the result for now.
  if now is false,
  call the function datetime.datetime with utc as argument if call to the is_aware(d) returns True, if not None is the argument, store the result in now.
  if reversed is True substitute difference of d and now for delta, if not substitute the difference of now and d for delta.
  multiply delta.days, integer 24, integer 60 and integer 60 add delta.seconds to it, substitute the result for since.
  if since is lesser or equal to integer 0,
  call the function ugettext with '0 minutes' as argument, use the result as the argument for the call to the avoid_wrapping function, return the result.
  for every i and tuple containing 2 elements: seconds and name, in enumerated chunks,
  divide since by seconds, store the floored result in count.
  if count does not equals to integer 0,
  break the execution of the smallest enclosing loop.
  use the remainder of the division of name by count as the argument for the call to the avoid_wrapping function, store the result in result.
  if i incremented by 1 is lesser than length of chunks,
  get the element of chunks at the (i+1)-the index, assign it to the seconds2 and name2, respectively.
  multiply seconds by count, subtract it from since, divide the result by seconds2, store the floored result in count2.
  if count2 does not equals to integer 0,
  call avoid_wrapping function with name2 modulus count2 as argument, call the ugettext with ', ' as argument, add previous 2 results, increment variable result by it.
  return result.
  define the function timeuntil with 2 arguments, d and now defaulting to none.
  evaluate the function timesince with d, now and reversed set to boolean true as arguments, return the result.
  from datetime import datetime,  timedelta and tzinfo into default name space.
  from threading import local into default name space.
  import module sys.
  import module time as _time.
  try,
  import pytz.
  if ImportError exception is caught,
  pytz is None.
  from django.conf import settings into default name space.
  from django.utils import six into default name space.
  __all__ is a list with 15 elements: strings 'utc', 'get_fixed_timezone', 'get_default_timezone', 'get_default_timezone_name',
  'get_current_timezone', 'get_current_timezone_name', 'activate', 'deactivate', 'override', 'localtime', 'now', 'is_aware',   'is_naive', 'make_aware' and 'make_naive'.   call the function timedelta with an argument integer 0, substitute the result for ZERO.
  derive the class UTC from the tzinfo base class.
  define the method __repr__ with an argument self.
  return a string "<UTC>".
  define the method utcoffset with 2 arguments self and dt.
  return ZERO.
  define the method tzname with 2 arguments self and dt.
  return a string "UTC".
  define the method dst with 2 arguments self and dt.
  return ZERO.
  derive the class FixedOffset from the tzinfo base class.
  define the method __init__ with 3 arguments: self, offset set to None, name set to None.
  if offset is not None,
  call the function timedelta with an argument minutes set to offset, substitute the result for self.__offset.
  if name is not None,
  substitute name for self.__name.
  define the method utcoffset with 2 arguments: self and dt.
  return self.__offset.
  define the method tzname with 2 arguments: self and dt.
  return self.__name.
  define the method dst with 2 arguments: self and dt.
  return ZERO.
  derive the class ReferenceLocalTimezone from the tzinfo base class.
  define the method __init__ with an argument self.
  call the function timedelta with an argument seconds set to negative _time.timezone, substitute the result for self.STDOFFSET.
  if _time.daylight is true,
  call the function timedelta with an argument seconds set to negative _time.altzone, substitute the result for self.DSTOFFSET.
  if not,
  substitute self.STDOFFSET for self.DSTOFFSET.
  subtract self.STDOFFSET with self.DSTOFFSET, substitute the result for self.DSTDIFF.
  call the method tzinfo.__init__ with an argument self.
  define the method utcoffset with 2 arguments: self and dt.
  call the method self._isdst with an argument dt, if it evaluates to true,
  return self.DSTOFFSET.
  if not,
  return self.STDOFFSET.
  define the method utcoffset with 2 arguments: self and dt.
  call the method self._isdst with an argument dt, if it evaluates to true,
  return self.DSTDIFF.
  if not,
  return ZERO.
  define the method tzname with 2 arguments: self and dt.
  call the method self._isdst with an argument dt, use it as an key to get the value from the _time.tzname dictionary, return it.
  define the method _isdst with 2 arguments: self and dt.
  tt is a tuple with 9 elements: dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, result of the method dt.weekday,
  ingeter 0 and integer 0.   call the method _time.mktime with an argument tt, substitute the result for stamp.
  call the method _time.localtime with an argument stamp, substitute the result for tt.
  if tt.tm_isdst is greater than integer 0, return the result.
  derive the class LocalTimezone from the ReferenceLocalTimezone base class.
  define the method tzname with 2 arguments: self and dt.
  if dt is None, is_dst is boolean False, otherwise call the method _isdst with an argument dt, substitute the result for is_dst.
  return the value under the is_dst key of the _time.tzname dictionary.
  define the method _isdst with 2 arguments: self and dt.
  try,
  call the method _isdst with an argument dt from the base class of the class LocalTimezone, return the result.
  if OverflowError or ValueError, renamed to exc, exceptions are caught,
  get the type of the exc object, substitute it for exc_type.
  call the function exc_type with an argument string "Unsupported value: %r. You should install pytz.", replace '%s' with dt,
  substitute the result for exc_value.   substitute exc for exc_value.__cause__.
  call the function six.reraise with 3 arguments: exc_type, exc_value and third element of the result of the method sys.exc_info.
  if pytz is true, substitute pytz.utc for utc, otherwise substitute result of the function UTC for utc.
  define the function get_fixed_timezone with an argument offset.
  if offset is an instance of timedelta class,
  substitute offset.seconds for offset.
  if offset is smaller than integer 0, sign is '-', otherwise sign is '+'.
  divide absolute offset by module 60, use the result to format string '%02d%02d', substitute it for hhmm.
  sum sign and hhmm, substitute the result for name.
  return an instance of FixedOffset class, created with 2 arguments: offset and name.
  _localtime is None.
  define the function get_default_timezone.
  use global variable _localtime.
  if _localtime is None,
  if settings.TIME_ZONE is an instance of six.string_types and pytz is not None,
  call the method pytz.timezone with an argument settings.TIME_ZONE, substitute the result for _localtime.
  if not,
  _localtime is an instance of LocalTimezone class.
  return _localtime.
  define the function get_default_timezone_name.
  call the function get_default_timezone, use the result as an argument for the call to the function _get_timezone_name, return the result.
  call the method local, substitute the result for _active.
  define the function get_current_timezone.
  get 'value' attribute of the _active object, if it exists return it, if not, call the function get_default_timezone and return the result.
  define the function get_current_timezone_name.
  call the function get_current_timezone, use the result as an argument for the call to the function _get_timezone_name, return the result.
  define the function _get_timezone_name with an argument timezone.
  try,
  return timezone.zone.
  if AttributeError exception is caught,
<annotation_end_b>#<body_start>          super ( MovedAttribute , self ) . __init__ ( name )
 if PY3 :
              if new_mod is None :
                  new_mod = name
  self . mod = new_mod
 if new_attr is None :
                  if old_attr is None :
                      new_attr = name
  else :
                      new_attr = old_attr
   self . attr = new_attr
  else :
              self . mod = old_mod
 if old_attr is None :
                  old_attr = name
  self . attr = old_attr
    def _resolve ( self ) :
          module = _import_module ( self . mod )
 return getattr ( module , self . attr )
      class _MovedItems ( _LazyModule ) :
    _moved_attributes = [  MovedAttribute ( "cStringIO" , "cStringIO" , "io" , "StringIO" ) ,  MovedAttribute ( "filter" , "itertools" , "builtins" , "ifilter" , "filter" ) ,  MovedAttribute ( "filterfalse" , "itertools" , "itertools" , "ifilterfalse" , "filterfalse" ) ,  MovedAttribute ( "input" , "__builtin__" , "builtins" , "raw_input" , "input" ) ,  MovedAttribute ( "map" , "itertools" , "builtins" , "imap" , "map" ) ,  MovedAttribute ( "range" , "__builtin__" , "builtins" , "xrange" , "range" ) ,  MovedAttribute ( "reload_module" , "__builtin__" , "imp" , "reload" ) ,  MovedAttribute ( "reduce" , "__builtin__" , "functools" ) ,  MovedAttribute ( "StringIO" , "StringIO" , "io" ) ,  MovedAttribute ( "UserString" , "UserString" , "collections" ) ,  MovedAttribute ( "xrange" , "__builtin__" , "builtins" , "xrange" , "range" ) ,  MovedAttribute ( "zip" , "itertools" , "builtins" , "izip" , "zip" ) ,  MovedAttribute ( "zip_longest" , "itertools" , "itertools" , "izip_longest" , "zip_longest" ) ,   MovedModule ( "builtins" , "__builtin__" ) ,  MovedModule ( "configparser" , "ConfigParser" ) ,  MovedModule ( "copyreg" , "copy_reg" ) ,  MovedModule ( "dbm_gnu" , "gdbm" , "dbm.gnu" ) ,  MovedModule ( "http_cookiejar" , "cookielib" , "http.cookiejar" ) ,  MovedModule ( "http_cookies" , "Cookie" , "http.cookies" ) ,  MovedModule ( "html_entities" , "htmlentitydefs" , "html.entities" ) ,  MovedModule ( "html_parser" , "HTMLParser" , "html.parser" ) ,  MovedModule ( "http_client" , "httplib" , "http.client" ) ,  MovedModule ( "email_mime_multipart" , "email.MIMEMultipart" , "email.mime.multipart" ) ,  MovedModule ( "email_mime_text" , "email.MIMEText" , "email.mime.text" ) ,  MovedModule ( "email_mime_base" , "email.MIMEBase" , "email.mime.base" ) ,  MovedModule ( "BaseHTTPServer" , "BaseHTTPServer" , "http.server" ) ,  MovedModule ( "CGIHTTPServer" , "CGIHTTPServer" , "http.server" ) ,  MovedModule ( "SimpleHTTPServer" , "SimpleHTTPServer" , "http.server" ) ,  MovedModule ( "cPickle" , "cPickle" , "pickle" ) ,  MovedModule ( "queue" , "Queue" ) ,  MovedModule ( "reprlib" , "repr" ) ,  MovedModule ( "socketserver" , "SocketServer" ) ,  MovedModule ( "_thread" , "thread" , "_thread" ) ,  MovedModule ( "tkinter" , "Tkinter" ) ,  MovedModule ( "tkinter_dialog" , "Dialog" , "tkinter.dialog" ) ,  MovedModule ( "tkinter_filedialog" , "FileDialog" , "tkinter.filedialog" ) ,  MovedModule ( "tkinter_scrolledtext" , "ScrolledText" , "tkinter.scrolledtext" ) ,  MovedModule ( "tkinter_simpledialog" , "SimpleDialog" , "tkinter.simpledialog" ) ,  MovedModule ( "tkinter_tix" , "Tix" , "tkinter.tix" ) ,  MovedModule ( "tkinter_ttk" , "ttk" , "tkinter.ttk" ) ,  MovedModule ( "tkinter_constants" , "Tkconstants" , "tkinter.constants" ) ,  MovedModule ( "tkinter_dnd" , "Tkdnd" , "tkinter.dnd" ) ,  MovedModule ( "tkinter_colorchooser" , "tkColorChooser" ,  "tkinter.colorchooser" ) ,  MovedModule ( "tkinter_commondialog" , "tkCommonDialog" ,  "tkinter.commondialog" ) ,  MovedModule ( "tkinter_tkfiledialog" , "tkFileDialog" , "tkinter.filedialog" ) ,  MovedModule ( "tkinter_font" , "tkFont" , "tkinter.font" ) ,  MovedModule ( "tkinter_messagebox" , "tkMessageBox" , "tkinter.messagebox" ) ,  MovedModule ( "tkinter_tksimpledialog" , "tkSimpleDialog" ,  "tkinter.simpledialog" ) ,  MovedModule ( "urllib_parse" , __name__ + ".moves.urllib_parse" , "urllib.parse" ) ,  MovedModule ( "urllib_error" , __name__ + ".moves.urllib_error" , "urllib.error" ) ,  MovedModule ( "urllib" , __name__ + ".moves.urllib" , __name__ + ".moves.urllib" ) ,  MovedModule ( "urllib_robotparser" , "robotparser" , "urllib.robotparser" ) ,  MovedModule ( "xmlrpc_client" , "xmlrpclib" , "xmlrpc.client" ) ,  MovedModule ( "xmlrpc_server" , "xmlrpclib" , "xmlrpc.server" ) ,  MovedModule ( "winreg" , "_winreg" ) ,  ]
 for attr in _moved_attributes :
      setattr ( _MovedItems , attr . name , attr )
 if isinstance ( attr , MovedModule ) :
          sys . modules [ __name__ + ".moves." + attr . name ] = attr
   del attr
  _MovedItems . _moved_attributes = _moved_attributes
  moves = sys . modules [ __name__ + ".moves" ] = _MovedItems ( __name__ + ".moves" )
   class Module_six_moves_urllib_parse ( _LazyModule ) :
    _urllib_parse_moved_attributes = [  MovedAttribute ( "ParseResult" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "SplitResult" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "parse_qs" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "parse_qsl" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urldefrag" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urljoin" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlparse" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlsplit" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlunparse" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlunsplit" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "quote" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "quote_plus" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "unquote" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "unquote_plus" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "urlencode" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "splitquery" , "urllib" , "urllib.parse" ) ,  ]
 for attr in _urllib_parse_moved_attributes :
      setattr ( Module_six_moves_urllib_parse , attr . name , attr )
  del attr
  Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_parse" ] = sys . modules [ __name__ + ".moves.urllib.parse" ] = Module_six_moves_urllib_parse ( __name__ + ".moves.urllib_parse" )
   class Module_six_moves_urllib_error ( _LazyModule ) :
    _urllib_error_moved_attributes = [  MovedAttribute ( "URLError" , "urllib2" , "urllib.error" ) ,  MovedAttribute ( "HTTPError" , "urllib2" , "urllib.error" ) ,  MovedAttribute ( "ContentTooShortError" , "urllib" , "urllib.error" ) ,  ]
 for attr in _urllib_error_moved_attributes :
      setattr ( Module_six_moves_urllib_error , attr . name , attr )
  del attr
  Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_error" ] = sys . modules [ __name__ + ".moves.urllib.error" ] = Module_six_moves_urllib_error ( __name__ + ".moves.urllib.error" )
   class Module_six_moves_urllib_request ( _LazyModule ) :
    _urllib_request_moved_attributes = [  MovedAttribute ( "urlopen" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "install_opener" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "build_opener" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "pathname2url" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "url2pathname" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "getproxies" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "Request" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "OpenerDirector" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPDefaultErrorHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPRedirectHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPCookieProcessor" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "BaseHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPPasswordMgr" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPPasswordMgrWithDefaultRealm" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "AbstractBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "AbstractDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPSHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "FileHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "FTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "CacheFTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "UnknownHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPErrorProcessor" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "urlretrieve" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "urlcleanup" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "URLopener" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "FancyURLopener" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "proxy_bypass" , "urllib" , "urllib.request" ) ,  ]
 for attr in _urllib_request_moved_attributes :
      setattr ( Module_six_moves_urllib_request , attr . name , attr )
  del attr
  Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_request" ] = sys . modules [ __name__ + ".moves.urllib.request" ] = Module_six_moves_urllib_request ( __name__ + ".moves.urllib.request" )
  class Module_six_moves_urllib_response ( _LazyModule ) :
    _urllib_response_moved_attributes = [  MovedAttribute ( "addbase" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addclosehook" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addinfo" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addinfourl" , "urllib" , "urllib.response" ) ,  ]
 for attr in _urllib_response_moved_attributes :
      setattr ( Module_six_moves_urllib_response , attr . name , attr )
  del attr
  Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_response" ] = sys . modules [ __name__ + ".moves.urllib.response" ] = Module_six_moves_urllib_response ( __name__ + ".moves.urllib.response" )
   class Module_six_moves_urllib_robotparser ( _LazyModule ) :
    _urllib_robotparser_moved_attributes = [  MovedAttribute ( "RobotFileParser" , "robotparser" , "urllib.robotparser" ) ,  ]
 for attr in _urllib_robotparser_moved_attributes :
      setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )
  del attr
  Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
  sys . modules [ __name__ + ".moves.urllib_robotparser" ] = sys . modules [ __name__ + ".moves.urllib.robotparser" ] = Module_six_moves_urllib_robotparser ( __name__ + ".moves.urllib.robotparser" )
   class Module_six_moves_urllib ( types . ModuleType ) :
 parse = sys . modules [ __name__ + ".moves.urllib_parse" ]
 error = sys . modules [ __name__ + ".moves.urllib_error" ]
 request = sys . modules [ __name__ + ".moves.urllib_request" ]
 response = sys . modules [ __name__ + ".moves.urllib_response" ]
 robotparser = sys . modules [ __name__ + ".moves.urllib_robotparser" ]
  def __dir__ ( self ) :
          return [ 'parse' , 'error' , 'request' , 'response' , 'robotparser' ]
     sys . modules [ __name__ + ".moves.urllib" ] = Module_six_moves_urllib ( __name__ + ".moves.urllib" )
   def add_move ( move ) :
 setattr ( _MovedItems , move . name , move )
    def remove_move ( name ) :
 try :
          delattr ( _MovedItems , name )
  except AttributeError :
          try :
              del moves . __dict__ [ name ]
  except KeyError :
              raise AttributeError ( "no such move, %r" % ( name , ) )
      if PY3 :
      _meth_func = "__func__"
 _meth_self = "__self__"
  _func_closure = "__closure__"
 _func_code = "__code__"
 _func_defaults = "__defaults__"
 _func_globals = "__globals__"
  _iterkeys = "keys"
 _itervalues = "values"
 _iteritems = "items"
 _iterlists = "lists"
  else :
      _meth_func = "im_func"
 _meth_self = "im_self"
  _func_closure = "func_closure"
 _func_code = "func_code"
 _func_defaults = "func_defaults"
 _func_globals = "func_globals"
  _iterkeys = "iterkeys"
 _itervalues = "itervalues"
 _iteritems = "iteritems"
 _iterlists = "iterlists"
    try :
      advance_iterator = next
  except NameError :
      def advance_iterator ( it ) :
          return it . next ( )
   next = advance_iterator
   try :
      callable = callable
  except NameError :
      def callable ( obj ) :
          return any ( "__call__" in klass . __dict__ for klass in type ( obj ) . __mro__ )
     if PY3 :
      def get_unbound_function ( unbound ) :
          return unbound
   create_bound_method = types . MethodType
  Iterator = object
  else :
      def get_unbound_function ( unbound ) :
          return unbound . im_func
   def create_bound_method ( func , obj ) :
          return types . MethodType ( func , obj , obj . __class__ )
   class Iterator ( object ) :
           def next ( self ) :
              return type ( self ) . __next__ ( self )
    callable = callable
  _add_doc ( get_unbound_function ,  """Get the function out of a possibly unbound function""" )
   get_method_function = operator . attrgetter ( _meth_func )
 get_method_self = operator . attrgetter ( _meth_self )
 get_function_closure = operator . attrgetter ( _func_closure )
 get_function_code = operator . attrgetter ( _func_code )
 get_function_defaults = operator . attrgetter ( _func_defaults )
 get_function_globals = operator . attrgetter ( _func_globals )
   def iterkeys ( d , ** kw ) :
 return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
   def itervalues ( d , ** kw ) :
 return iter ( getattr ( d , _itervalues ) ( ** kw ) )
   def iteritems ( d , ** kw ) :
 return iter ( getattr ( d , _iteritems ) ( ** kw ) )
   def iterlists ( d , ** kw ) :
 return iter ( getattr ( d , _iterlists ) ( ** kw ) )
    if PY3 :
      def b ( s ) :
          return s . encode ( "latin-1" )
  def u ( s ) :
          return s
  unichr = chr
 if sys . version_info [ 1 ] <= 1 :
          def int2byte ( i ) :
              return bytes ( ( i , ) )
   else :
           int2byte = operator . methodcaller ( "to_bytes" , 1 , "big" )
  byte2int = operator . itemgetter ( 0 )
 indexbytes = operator . getitem
 iterbytes = iter
 import io
 StringIO = io . StringIO
 BytesIO = io . BytesIO
  else :
      def b ( s ) :
          return s
   def u ( s ) :
          return unicode ( s . replace ( r'\\' , r'\\\\' ) , "unicode_escape" )
  unichr = unichr
 int2byte = chr
 def byte2int ( bs ) :
          return ord ( bs [ 0 ] )
  def indexbytes ( buf , i ) :
          return ord ( buf [ i ] )
  def iterbytes ( buf ) :
          return ( ord ( byte ) for byte in buf )
  import StringIO
 StringIO = BytesIO = StringIO . StringIO
  _add_doc ( b , """Byte literal""" )
 _add_doc ( u , """Text literal""" )
   if PY3 :
      exec_ = getattr ( moves . builtins , "exec" )
   def reraise ( tp , value , tb = None ) :
          if value . __traceback__ is not tb :
              raise value . with_traceback ( tb )
  raise value
    else :
      def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
 if _globs_ is None :
              frame = sys . _getframe ( 1 )
 _globs_ = frame . f_globals
 if _locs_ is None :
                  _locs_ = frame . f_locals
  del frame
  elif _locs_ is None :
              _locs_ = _globs_
  exec ( """exec _code_ in _globs_, _locs_""" )
    exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
    print_ = getattr ( moves . builtins , "print" , None )
 if print_ is None :
      def print_ ( * args , ** kwargs ) :
 fp = kwargs . pop ( "file" , sys . stdout )
 if fp is None :
              return
  def write ( data ) :
              if not isinstance ( data , basestring ) :
                  data = str ( data )
   if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
                  errors = getattr ( fp , "errors" , None )
 if errors is None :
                      errors = "strict"
  data = data . encode ( fp . encoding , errors )
  fp . write ( data )
  want_unicode = False
 sep = kwargs . pop ( "sep" , None )
 if sep is not None :
              if isinstance ( sep , unicode ) :
                  want_unicode = True
  elif not isinstance ( sep , str ) :
                  raise TypeError ( "sep must be None or a string" )
   end = kwargs . pop ( "end" , None )
 if end is not None :
              if isinstance ( end , unicode ) :
                  want_unicode = True
  elif not isinstance ( end , str ) :
                  raise TypeError ( "end must be None or a string" )
   if kwargs :
              raise TypeError ( "invalid keyword arguments to print()" )
  if not want_unicode :
              for arg in args :
                  if isinstance ( arg , unicode ) :
                      want_unicode = True
 break
    if want_unicode :
              newline = unicode ( "\n" )
 space = unicode ( " " )
  else :
              newline = "\n"
 space = " "
  if sep is None :
              sep = space
  if end is None :
              end = newline
  for i , arg in enumerate ( args ) :
              if i :
                  write ( sep )
  write ( arg )
  write ( end )
    _add_doc ( reraise , """Reraise an exception.""" )
   def with_metaclass ( meta , * bases ) :
       class metaclass ( meta ) :
          __call__ = type . __call__
 __init__ = type . __init__
 def __new__ ( cls , name , this_bases , d ) :
              if this_bases is None :
                  return type . __new__ ( cls , name , ( ) , d )
  return meta ( name , bases , d )
   return metaclass ( 'temporary_class' , None , { } )
    def add_metaclass ( metaclass ) :
 def wrapper ( cls ) :
          orig_vars = cls . __dict__ . copy ( )
 orig_vars . pop ( '__dict__' , None )
 orig_vars . pop ( '__weakref__' , None )
 slots = orig_vars . get ( '__slots__' )
 if slots is not None :
              if isinstance ( slots , str ) :
                  slots = [ slots ]
  for slots_var in slots :
                  orig_vars . pop ( slots_var )
   return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
  return wrapper
      if PY3 :
      _assertCountEqual = "assertCountEqual"
 _assertRaisesRegex = "assertRaisesRegex"
 _assertRegex = "assertRegex"
 memoryview = memoryview
 buffer_types = ( bytes , bytearray , memoryview )
  else :
      _assertCountEqual = "assertItemsEqual"
 _assertRaisesRegex = "assertRaisesRegexp"
 _assertRegex = "assertRegexpMatches"
    if sys . platform . startswith ( 'java' ) :
          memoryview = memoryview
  else :
          memoryview = buffer
  buffer_types = ( bytearray , memoryview )
    def assertCountEqual ( self , * args , ** kwargs ) :
      return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
    def assertRaisesRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
    def assertRegex ( self , * args , ** kwargs ) :
      return getattr ( self , _assertRegex ) ( * args , ** kwargs )
    add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
 add_move ( MovedModule ( "_thread" , "thread" ) )
  import contextlib
 try :
      import threading
  except ImportError :
      import dummy_threading as threading
    class RWLock ( object ) :
 def __init__ ( self ) :
          self . mutex = threading . RLock ( )
 self . can_read = threading . Semaphore ( 0 )
 self . can_write = threading . Semaphore ( 0 )
 self . active_readers = 0
 self . active_writers = 0
 self . waiting_readers = 0
 self . waiting_writers = 0
   def reader_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 :
                  self . active_readers += 1
 self . can_read . release ( )
  else :
                  self . waiting_readers += 1
   self . can_read . acquire ( )
   def reader_leaves ( self ) :
          with self . mutex :
              self . active_readers -= 1
 if self . active_readers == 0 and self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
     @ contextlib . contextmanager
 def reader ( self ) :
          self . reader_enters ( )
 try :
              yield
  finally :
              self . reader_leaves ( )
    def writer_enters ( self ) :
          with self . mutex :
              if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
                  self . active_writers += 1
 self . can_write . release ( )
  else :
                  self . waiting_writers += 1
   self . can_write . acquire ( )
   def writer_leaves ( self ) :
          with self . mutex :
              self . active_writers -= 1
 if self . waiting_writers != 0 :
                  self . active_writers += 1
 self . waiting_writers -= 1
 self . can_write . release ( )
  elif self . waiting_readers != 0 :
                  t = self . waiting_readers
 self . waiting_readers = 0
 self . active_readers += t
 while t > 0 :
                      self . can_read . release ( )
 t -= 1
      @ contextlib . contextmanager
 def writer ( self ) :
          self . writer_enters ( )
 try :
              yield
  finally :
              self . writer_leaves ( )
  from django . utils import six
  color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
 foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
 background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
  RESET = '0'
 opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
   def colorize ( text = '' , opts = ( ) , ** kwargs ) :
 code_list = [ ]
 if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
          return '\x1b[%sm' % RESET
  for k , v in six . iteritems ( kwargs ) :
          if k == 'fg' :
              code_list . append ( foreground [ v ] )
  elif k == 'bg' :
              code_list . append ( background [ v ] )
   for o in opts :
          if o in opt_dict :
              code_list . append ( opt_dict [ o ] )
   if 'noreset' not in opts :
          text = '%s\x1b[%sm' % ( text or '' , RESET )
  return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
    def make_style ( opts = ( ) , ** kwargs ) :
 return lambda text : colorize ( text , opts , ** kwargs )
   NOCOLOR_PALETTE = 'nocolor'
 DARK_PALETTE = 'dark'
 LIGHT_PALETTE = 'light'
  PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
 DEFAULT_PALETTE = DARK_PALETTE
   def parse_color_setting ( config_string ) :
 if not config_string :
          return PALETTES [ DEFAULT_PALETTE ]
    parts = config_string . lower ( ) . split ( ';' )
 palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
 for part in parts :
          if part in PALETTES :
               palette . update ( PALETTES [ part ] )
  elif '=' in part :
               definition = { }
     role , instructions = part . split ( '=' )
 role = role . upper ( )
  styles = instructions . split ( ',' )
 styles . reverse ( )
    colors = styles . pop ( ) . split ( '/' )
 colors . reverse ( )
 fg = colors . pop ( )
 if fg in color_names :
                  definition [ 'fg' ] = fg
  if colors and colors [ - 1 ] in color_names :
                  definition [ 'bg' ] = colors [ - 1 ]
    opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
 if opts :
                  definition [ 'opts' ] = opts
      if role in PALETTES [ NOCOLOR_PALETTE ] and definition :
                  palette [ role ] = definition
      if palette == PALETTES [ NOCOLOR_PALETTE ] :
          return None
  return palette
from __future__ import unicode_literals
  import re
 import unicodedata
 from gzip import GzipFile
 from io import BytesIO
 import warnings
  from django . utils . deprecation import RemovedInDjango19Warning
 from django . utils . encoding import force_text
 from django . utils . functional import allow_lazy , SimpleLazyObject
 from django . utils import six
 from django . utils . six . moves import html_entities
 from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
 from django . utils . safestring import mark_safe
  if six . PY2 :
        from django . utils . encoding import force_unicode
     capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
 capfirst = allow_lazy ( capfirst , six . text_type )
   re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
 re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
 re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
 re_newlines = re . compile ( r'\r\n|\r' )
 re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
   def wrap ( text , width ) :
 text = force_text ( text )
  def _generator ( ) :
          for line in text . splitlines ( True ) :
              max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
 while len ( line ) > max_width :
                  space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
 if space == 0 :
                      space = line . find ( ' ' ) + 1
 if space == 0 :
                          yield line
 line = ''
 break
   yield '%s\n' % line [ : space - 1 ]
 line = line [ space : ]
 max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
  if line :
                  yield line
    return '' . join ( _generator ( ) )
  wrap = allow_lazy ( wrap , six . text_type )
   class Truncator ( SimpleLazyObject ) :
 def __init__ ( self , text ) :
          super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
   def add_truncation_text ( self , text , truncate = None ) :
          if truncate is None :
              truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
  truncate = force_text ( truncate )
 if '%(truncated_text)s' in truncate :
              return truncate % { 'truncated_text' : text }
    if text . endswith ( truncate ) :
                return text
  return '%s%s' % ( text , truncate )
   def chars ( self , num , truncate = None , html = False ) :
 length = int ( num )
 text = unicodedata . normalize ( 'NFC' , self . _wrapped )
   truncate_len = length
 for char in self . add_truncation_text ( '' , truncate ) :
              if not unicodedata . combining ( char ) :
                  truncate_len -= 1
 if truncate_len == 0 :
                      break
    if html :
              return self . _truncate_html ( length , truncate , text , truncate_len , False )
  return self . _text_chars ( length , truncate , text , truncate_len )
  chars = allow_lazy ( chars )
  def _text_chars ( self , length , truncate , text , truncate_len ) :
 s_len = 0
 end_index = None
 for i , char in enumerate ( text ) :
              if unicodedata . combining ( char ) :
                    continue
  s_len += 1
 if end_index is None and s_len > truncate_len :
                  end_index = i
  if s_len > length :
                   return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
     return text
   def words ( self , num , truncate = None , html = False ) :
 length = int ( num )
 if html :
              return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
  return self . _text_words ( length , truncate )
  words = allow_lazy ( words )
  def _text_words ( self , length , truncate ) :
 words = self . _wrapped . split ( )
 if len ( words ) > length :
              words = words [ : length ]
 return self . add_truncation_text ( ' ' . join ( words ) , truncate )
  return ' ' . join ( words )
   def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
 if words and length <= 0 :
              return ''
   html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
   pos = 0
 end_text_pos = 0
 current_len = 0
 open_tags = [ ]
  regex = re_words if words else re_chars
  while current_len <= length :
              m = regex . search ( text , pos )
 if not m :
                   break
  pos = m . end ( 0 )
 if m . group ( 1 ) :
                   current_len += 1
 if current_len == truncate_len :
                      end_text_pos = pos
  continue
   tag = re_tag . match ( m . group ( 0 ) )
 if not tag or current_len >= truncate_len :
                   continue
  closing_tag , tagname , self_closing = tag . groups ( )
  tagname = tagname . lower ( )
 if self_closing or tagname in html4_singlets :
                  pass
  elif closing_tag :
                   try :
                      i = open_tags . index ( tagname )
  except ValueError :
                      pass
  else :
                        open_tags = open_tags [ i + 1 : ]
   else :
                   open_tags . insert ( 0 , tagname )
    if current_len <= length :
              return text
  out = text [ : end_text_pos ]
 truncate_text = self . add_truncation_text ( '' , truncate )
 if truncate_text :
              out += truncate_text
   for tag in open_tags :
              out += '</%s>' % tag
   return out
     def get_valid_filename ( s ) :
 s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )
 return re . sub ( r'(?u)[^-\w.]' , '' , s )
  get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
   def get_text_list ( list_ , last_word = ugettext_lazy ( 'or' ) ) :
 if len ( list_ ) == 0 :
          return ''
  if len ( list_ ) == 1 :
          return force_text ( list_ [ 0 ] )
  return '%s %s %s' % (   _ ( ', ' ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) ,  force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )
  get_text_list = allow_lazy ( get_text_list , six . text_type )
   def normalize_newlines ( text ) :
 text = force_text ( text )
 return re_newlines . sub ( '\n' , text )
  normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
   def phone2numeric ( phone ) :
 char2number = { 'a' : '2' , 'b' : '2' , 'c' : '2' , 'd' : '3' , 'e' : '3' , 'f' : '3' ,  'g' : '4' , 'h' : '4' , 'i' : '4' , 'j' : '5' , 'k' : '5' , 'l' : '5' , 'm' : '6' ,  'n' : '6' , 'o' : '6' , 'p' : '7' , 'q' : '7' , 'r' : '7' , 's' : '7' , 't' : '8' ,  'u' : '8' , 'v' : '8' , 'w' : '9' , 'x' : '9' , 'y' : '9' , 'z' : '9' }
 return '' . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
  phone2numeric = allow_lazy ( phone2numeric )
     def compress_string ( s ) :
      zbuf = BytesIO ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = zbuf )
 zfile . write ( s )
 zfile . close ( )
 return zbuf . getvalue ( )
    class StreamingBuffer ( object ) :
      def __init__ ( self ) :
          self . vals = [ ]
   def write ( self , val ) :
          self . vals . append ( val )
   def read ( self ) :
          ret = b'' . join ( self . vals )
 self . vals = [ ]
 return ret
   def flush ( self ) :
          return
   def close ( self ) :
          return
      def compress_sequence ( sequence ) :
      buf = StreamingBuffer ( )
 zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )
  yield buf . read ( )
 for item in sequence :
          zfile . write ( item )
 zfile . flush ( )
 yield buf . read ( )
  zfile . close ( )
 yield buf . read ( )
   ustring_re = re . compile ( "([\u0080-\uffff])" )
   def javascript_quote ( s , quote_double_quotes = False ) :
      msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
 warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
  def fix ( match ) :
          return "\\u%04x" % ord ( match . group ( 1 ) )
   if type ( s ) == bytes :
          s = s . decode ( 'utf-8' )
  elif type ( s ) != six . text_type :
          raise TypeError ( s )
  s = s . replace ( '\\' , '\\\\' )
 s = s . replace ( '\r' , '\\r' )
 s = s . replace ( '\n' , '\\n' )
 s = s . replace ( '\t' , '\\t' )
 s = s . replace ( "'" , "\\'" )
 s = s . replace ( '</' , '<\\/' )
 if quote_double_quotes :
          s = s . replace ( '"' , '&quot;' )
  return ustring_re . sub ( fix , s )
  javascript_quote = allow_lazy ( javascript_quote , six . text_type )
    smart_split_re = re . compile ( r"""     ((?:         [^\s'"]*         (?:             (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) """ , re . VERBOSE )
   def smart_split ( text ) :
 text = force_text ( text )
 for bit in smart_split_re . finditer ( text ) :
          yield bit . group ( 0 )
     def _replace_entity ( match ) :
      text = match . group ( 1 )
 if text [ 0 ] == '#' :
          text = text [ 1 : ]
 try :
              if text [ 0 ] in 'xX' :
                  c = int ( text [ 1 : ] , 16 )
  else :
                  c = int ( text )
  return six . unichr ( c )
  except ValueError :
              return match . group ( 0 )
   else :
          try :
              return six . unichr ( html_entities . name2codepoint [ text ] )
  except ( ValueError , KeyError ) :
              return match . group ( 0 )
     _entity_re = re . compile ( r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));" )
   def unescape_entities ( text ) :
      return _entity_re . sub ( _replace_entity , text )
  unescape_entities = allow_lazy ( unescape_entities , six . text_type )
   def unescape_string_literal ( s ) :
 if s [ 0 ] not in "\"'" or s [ - 1 ] != s [ 0 ] :
          raise ValueError ( "Not a string literal: %r" % s )
  quote = s [ 0 ]
 return s [ 1 : - 1 ] . replace ( r'\%s' % quote , quote ) . replace ( r'\\' , '\\' )
  unescape_string_literal = allow_lazy ( unescape_string_literal )
   def slugify ( value ) :
 value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' )
 value = re . sub ( '[^\w\s-]' , '' , value ) . strip ( ) . lower ( )
 return mark_safe ( re . sub ( '[-\s]+' , '-' , value ) )
  slugify = allow_lazy ( slugify , six . text_type )
   def camel_case_to_spaces ( value ) :
 return re_camel_case . sub ( r' \1' , value ) . strip ( ) . lower ( )
from __future__ import unicode_literals
  import datetime
  from django . utils . html import avoid_wrapping
 from django . utils . timezone import is_aware , utc
 from django . utils . translation import ugettext , ungettext_lazy
   def timesince ( d , now = None , reversed = False ) :
 chunks = (  ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d year' , '%d years' ) ) ,  ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d month' , '%d months' ) ) ,  ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d week' , '%d weeks' ) ) ,  ( 60 * 60 * 24 , ungettext_lazy ( '%d day' , '%d days' ) ) ,  ( 60 * 60 , ungettext_lazy ( '%d hour' , '%d hours' ) ) ,  ( 60 , ungettext_lazy ( '%d minute' , '%d minutes' ) )  )
   if not isinstance ( d , datetime . datetime ) :
          d = datetime . datetime ( d . year , d . month , d . day )
  if now and not isinstance ( now , datetime . datetime ) :
          now = datetime . datetime ( now . year , now . month , now . day )
   if not now :
          now = datetime . datetime . now ( utc if is_aware ( d ) else None )
   delta = ( d - now ) if reversed else ( now - d )
  since = delta . days * 24 * 60 * 60 + delta . seconds
 if since <= 0 :
           return avoid_wrapping ( ugettext ( '0 minutes' ) )
  for i , ( seconds , name ) in enumerate ( chunks ) :
          count = since // seconds
 if count != 0 :
              break
   result = avoid_wrapping ( name % count )
 if i + 1 < len ( chunks ) :
           seconds2 , name2 = chunks [ i + 1 ]
 count2 = ( since - ( seconds * count ) ) // seconds2
 if count2 != 0 :
              result += ugettext ( ', ' ) + avoid_wrapping ( name2 % count2 )
   return result
    def timeuntil ( d , now = None ) :
 return timesince ( d , now , reversed = True )
  from datetime import datetime , timedelta , tzinfo
 from threading import local
 import sys
 import time as _time
  try :
      import pytz
  except ImportError :
      pytz = None
   from django . conf import settings
 from django . utils import six
  __all__ = [  'utc' , 'get_fixed_timezone' ,  'get_default_timezone' , 'get_default_timezone_name' ,  'get_current_timezone' , 'get_current_timezone_name' ,  'activate' , 'deactivate' , 'override' ,  'localtime' , 'now' ,  'is_aware' , 'is_naive' , 'make_aware' , 'make_naive' ,  ]
     ZERO = timedelta ( 0 )
   class UTC ( tzinfo ) :
  def __repr__ ( self ) :
          return "<UTC>"
   def utcoffset ( self , dt ) :
          return ZERO
   def tzname ( self , dt ) :
          return "UTC"
   def dst ( self , dt ) :
          return ZERO
     class FixedOffset ( tzinfo ) :
  def __init__ ( self , offset = None , name = None ) :
          if offset is not None :
              self . __offset = timedelta ( minutes = offset )
  if name is not None :
              self . __name = name
    def utcoffset ( self , dt ) :
          return self . __offset
   def tzname ( self , dt ) :
          return self . __name
   def dst ( self , dt ) :
          return ZERO
     class ReferenceLocalTimezone ( tzinfo ) :
  def __init__ ( self ) :
          self . STDOFFSET = timedelta ( seconds = - _time . timezone )
 if _time . daylight :
              self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
  else :
              self . DSTOFFSET = self . STDOFFSET
  self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
 tzinfo . __init__ ( self )
   def utcoffset ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTOFFSET
  else :
              return self . STDOFFSET
    def dst ( self , dt ) :
          if self . _isdst ( dt ) :
              return self . DSTDIFF
  else :
              return ZERO
    def tzname ( self , dt ) :
          return _time . tzname [ self . _isdst ( dt ) ]
   def _isdst ( self , dt ) :
          tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )
 stamp = _time . mktime ( tt )
 tt = _time . localtime ( stamp )
 return tt . tm_isdst > 0
     class LocalTimezone ( ReferenceLocalTimezone ) :
  def tzname ( self , dt ) :
          is_dst = False if dt is None else self . _isdst ( dt )
 return _time . tzname [ is_dst ]
   def _isdst ( self , dt ) :
          try :
              return super ( LocalTimezone , self ) . _isdst ( dt )
  except ( OverflowError , ValueError ) as exc :
              exc_type = type ( exc )
 exc_value = exc_type (  "Unsupported value: %r. You should install pytz." % dt )
 exc_value . __cause__ = exc
 six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
     utc = pytz . utc if pytz else UTC ( )
   def get_fixed_timezone ( offset ) :
 if isinstance ( offset , timedelta ) :
          offset = offset . seconds // 60
  sign = '-' if offset < 0 else '+'
 hhmm = '%02d%02d' % divmod ( abs ( offset ) , 60 )
 name = sign + hhmm
 return FixedOffset ( offset , name )
     _localtime = None
   def get_default_timezone ( ) :
 global _localtime
 if _localtime is None :
          if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
              _localtime = pytz . timezone ( settings . TIME_ZONE )
  else :
               _localtime = LocalTimezone ( )
   return _localtime
     def get_default_timezone_name ( ) :
 return _get_timezone_name ( get_default_timezone ( ) )
   _active = local ( )
   def get_current_timezone ( ) :
 return getattr ( _active , "value" , get_default_timezone ( ) )
    def get_current_timezone_name ( ) :
 return _get_timezone_name ( get_current_timezone ( ) )
    def _get_timezone_name ( timezone ) :
 try :
           return timezone . zone
  except AttributeError :
<body_end><annotation_start_b>  if value is an instance of datetime and settings.USE_TZ if use_tz is None else use_tz and call to the function is_naive,
<annotation_end_b>#<body_start> should_convert = ( isinstance ( value , datetime )  and ( settings . USE_TZ if use_tz is None else use_tz )  and not is_naive ( value )  and getattr ( value , 'convert_to_local_time' , True ) )
<body_end><annotation_start_b>  if timezone is None,
  call the function get_current_timezone, substitute the result for timezone.
  call the method value.astimezone with an argument timezone, substitute the result for value.
  if timezone has an attribute 'normalize',
  call the method timezone.normalize with an argument value, substitute the result for value.
<annotation_end_b>#<body_start> if timezone is None :
          timezone = get_current_timezone ( )
    value = value . astimezone ( timezone )
 if hasattr ( timezone , 'normalize' ) :
           value = timezone . normalize ( value )
<body_end><annotation_start_b>  if settings.USE_TZ is true,
<annotation_end_b>#<body_start> if settings . USE_TZ :
<body_end><annotation_start_b>  if self.old_timezone is None,
  call the method deactivate.
  if not,
  substitute self.old_timezone for _active.value.
  define the function template_localtime with 2 arguments: value and use_tz set to None.
  if value is an instance of datetime and settings.USE_TZ if use_tz is None else use_tz and call to the function is_naive,
  with an argument value evaluates to false, and if 'convert_to_local_time' attribute of value object doesnt exists,   or is it does is boolean True, should_convert is boolean True, otherwise is boolean False.   if should_convert is true, call the function localtime with an argument value and return the result, otherwise return value.
  define the function localtime with 2 arguments: value and timezone set to None.
  if timezone is None,
  call the function get_current_timezone, substitute the result for timezone.
  call the method value.astimezone with an argument timezone, substitute the result for value.
  if timezone has an attribute 'normalize',
  call the method timezone.normalize with an argument value, substitute the result for value.
  return value.
  define the function now.
  if settings.USE_TZ is true,
  call the method datetime.utcnow, on the result call the method replace with an argument tzinfo set to utc, return the result.
  if not,
<annotation_end_b>#<body_start>          if self . old_timezone is None :
              deactivate ( )
  else :
              _active . value = self . old_timezone
        def template_localtime ( value , use_tz = None ) :
 should_convert = ( isinstance ( value , datetime )  and ( settings . USE_TZ if use_tz is None else use_tz )  and not is_naive ( value )  and getattr ( value , 'convert_to_local_time' , True ) )
 return localtime ( value ) if should_convert else value
      def localtime ( value , timezone = None ) :
 if timezone is None :
          timezone = get_current_timezone ( )
    value = value . astimezone ( timezone )
 if hasattr ( timezone , 'normalize' ) :
           value = timezone . normalize ( value )
  return value
    def now ( ) :
 if settings . USE_TZ :
           return datetime . utcnow ( ) . replace ( tzinfo = utc )
  else :
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if timezone has an attribute 'localize',
<annotation_end_b>#<body_start> if hasattr ( timezone , 'localize' ) :
<body_end><annotation_start_b>  if self.timezone is None,
  call the method deactivate.
  if not,
  call the method activate with an argument self.timezone.
  define the method __exit__ with 4 arguments self, exc_type, exc_value and traceback.
  if self.old_timezone is None,
  call the method deactivate.
  if not,
  substitute self.old_timezone for _active.value.
  define the function template_localtime with 2 arguments: value and use_tz set to None.
  if value is an instance of datetime and settings.USE_TZ if use_tz is None else use_tz and call to the function is_naive,
  with an argument value evaluates to false, and if 'convert_to_local_time' attribute of value object doesnt exists,   or is it does is boolean True, should_convert is boolean True, otherwise is boolean False.   if should_convert is true, call the function localtime with an argument value and return the result, otherwise return value.
  define the function localtime with 2 arguments: value and timezone set to None.
  if timezone is None,
  call the function get_current_timezone, substitute the result for timezone.
  call the method value.astimezone with an argument timezone, substitute the result for value.
  if timezone has an attribute 'normalize',
  call the method timezone.normalize with an argument value, substitute the result for value.
  return value.
  define the function now.
  if settings.USE_TZ is true,
  call the method datetime.utcnow, on the result call the method replace with an argument tzinfo set to utc, return the result.
  if not,
  call the method datetime.now, return the result.
  define the function is_aware with an argument value.
  if value.tzinfo is not None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to not None,
  return boolean True, otherwise return boolean False.   define the function is_naive with an argument value.
  if value.tzinfo is None and call to the method value.tzinfo.utcoffset called with an argument value evaluates to None,
  return boolean True, otherwise return boolean False.   define the function make_aware with 2 arguments: value and timezone.
  if timezone has an attribute 'localize',
  call the method timezone.localize with 2 arguments: value and is_dst as None, return the result.
  if not,
  call the function is_aware with an argument value, if it evaluates to true,
  raise an ValueError exception with an argument string "make_aware expects a naive datetime, got %s", where '%s' is replaced with value.
<annotation_end_b>#<body_start>          if self . timezone is None :
              deactivate ( )
  else :
              activate ( self . timezone )
    def __exit__ ( self , exc_type , exc_value , traceback ) :
          if self . old_timezone is None :
              deactivate ( )
  else :
              _active . value = self . old_timezone
        def template_localtime ( value , use_tz = None ) :
 should_convert = ( isinstance ( value , datetime )  and ( settings . USE_TZ if use_tz is None else use_tz )  and not is_naive ( value )  and getattr ( value , 'convert_to_local_time' , True ) )
 return localtime ( value ) if should_convert else value
      def localtime ( value , timezone = None ) :
 if timezone is None :
          timezone = get_current_timezone ( )
    value = value . astimezone ( timezone )
 if hasattr ( timezone , 'normalize' ) :
           value = timezone . normalize ( value )
  return value
    def now ( ) :
 if settings . USE_TZ :
           return datetime . utcnow ( ) . replace ( tzinfo = utc )
  else :
          return datetime . now ( )
        def is_aware ( value ) :
 return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
    def is_naive ( value ) :
 return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
   def make_aware ( value , timezone ) :
 if hasattr ( timezone , 'localize' ) :
           return timezone . localize ( value , is_dst = None )
  else :
           if is_aware ( value ) :
              raise ValueError (  "make_aware expects a naive datetime, got %s" % value )
<body_end><annotation_start_b>  call the method value.astimezone with an argument timezone, substitute the result for value.
  if timezone has an attribute 'normalize',
  call the method timezone.normalize with an argument value, substitute the result for value.
<annotation_end_b>#<body_start>   value = value . astimezone ( timezone )
 if hasattr ( timezone , 'normalize' ) :
           value = timezone . normalize ( value )
<body_end><annotation_start_b>  from django.conf import settings.
  if settings.USE_I18N is true,
  from django.utils.translation import trans_real as trans.
  if not,
  from django.utils.translation import trans_null as trans.
  set real_name attribute of the self object to value of real_name attribute of trans object.
<annotation_end_b>#<body_start>          from django . conf import settings
 if settings . USE_I18N :
              from django . utils . translation import trans_real as trans
  else :
              from django . utils . translation import trans_null as trans
  setattr ( self , real_name , getattr ( trans , real_name ) )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b>  if rhs is an instance of dict type and number is true,
  try,
  substitute value under the number key of the rhs dictionary for number_value.
  if KeyError exception is caught,
  raise an KeyError with an argument string 'Your dictionary lacks key \'%s\'. Please provide it, because it is required to '
  'determine whether string is singular or plural.', where '%s' is replaced with number.   if not,
  substitute rhs for number_value.
  substitute number_value for kwargs dictionary value under the 'number' key.
  call the function func with unpacked dictionary kwargs as an argument, substitute the result for translated.
  try,
  format translated with rhs, substitute the result for translated.
  if TypeError exception is caught,
  do nothing.
<annotation_end_b>#<body_start>                  if isinstance ( rhs , dict ) and number :
                      try :
                          number_value = rhs [ number ]
  except KeyError :
                          raise KeyError ( 'Your dictionary lacks key \'%s\'. '  'Please provide it, because it is required to '  'determine whether string is singular or plural.'  % number )
   else :
                      number_value = rhs
  kwargs [ 'number' ] = number_value
 translated = func ( ** kwargs )
 try :
                      translated = translated % rhs
  except TypeError :
                       pass
<body_end><annotation_start_b>  if number is an instance of int type.
  substitute number for value under the 'number' key of the kwargs dictionary.
  call the function lazy with 2 arguments: func and resultclass, call the result with an argument, unpacked dictionary kwargs,
  substitute the result for proxy.   if not,
  derive the class NumberAwareString from the resultclass base class.
  define the method __mod__ with 2 arguments: self and rhs.
  if rhs is an instance of dict type and number is true,
  try,
  substitute value under the number key of the rhs dictionary for number_value.
  if KeyError exception is caught,
  raise an KeyError with an argument string 'Your dictionary lacks key \'%s\'. Please provide it, because it is required to '
  'determine whether string is singular or plural.', where '%s' is replaced with number.   if not,
  substitute rhs for number_value.
  substitute number_value for kwargs dictionary value under the 'number' key.
  call the function func with unpacked dictionary kwargs as an argument, substitute the result for translated.
  try,
  format translated with rhs, substitute the result for translated.
  if TypeError exception is caught,
  do nothing.
  return translated.
  call the function lazy with 2 arguments: lambda function with unpacked dictionary kwargs as an argument and return value an instance of NumberAwareString class and NumberAwareString, call the result with an argument unpacked dictionary kwargs, substitute the result for proxy.
<annotation_end_b>#<body_start>      if isinstance ( number , int ) :
          kwargs [ 'number' ] = number
 proxy = lazy ( func , resultclass ) ( ** kwargs )
  else :
          class NumberAwareString ( resultclass ) :
              def __mod__ ( self , rhs ) :
                  if isinstance ( rhs , dict ) and number :
                      try :
                          number_value = rhs [ number ]
  except KeyError :
                          raise KeyError ( 'Your dictionary lacks key \'%s\'. '  'Please provide it, because it is required to '  'determine whether string is singular or plural.'  % number )
   else :
                      number_value = rhs
  kwargs [ 'number' ] = number_value
 translated = func ( ** kwargs )
 try :
                      translated = translated % rhs
  except TypeError :
                       pass
  return translated
    proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )
<body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end><annotation_start_b><annotation_end_b>#<body_start><body_end>